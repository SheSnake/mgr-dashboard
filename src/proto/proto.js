/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const tradeconfig = $root.tradeconfig = (() => {

    /**
     * Namespace tradeconfig.
     * @exports tradeconfig
     * @namespace
     */
    const tradeconfig = {};

    /**
     * LogLevel enum.
     * @name tradeconfig.LogLevel
     * @enum {number}
     * @property {number} TRACE=0 TRACE value
     * @property {number} DEBUG=1 DEBUG value
     * @property {number} INFO=2 INFO value
     * @property {number} WARN=3 WARN value
     * @property {number} ERROR=4 ERROR value
     * @property {number} CRITICAL=5 CRITICAL value
     * @property {number} OFF=6 OFF value
     */
    tradeconfig.LogLevel = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TRACE"] = 0;
        values[valuesById[1] = "DEBUG"] = 1;
        values[valuesById[2] = "INFO"] = 2;
        values[valuesById[3] = "WARN"] = 3;
        values[valuesById[4] = "ERROR"] = 4;
        values[valuesById[5] = "CRITICAL"] = 5;
        values[valuesById[6] = "OFF"] = 6;
        return values;
    })();

    tradeconfig.LogConfig = (function() {

        /**
         * Properties of a LogConfig.
         * @memberof tradeconfig
         * @interface ILogConfig
         * @property {string|null} [logPath] LogConfig logPath
         * @property {tradeconfig.LogLevel|null} [logLevel] LogConfig logLevel
         * @property {number|null} [flushSecondInterval] LogConfig flushSecondInterval
         */

        /**
         * Constructs a new LogConfig.
         * @memberof tradeconfig
         * @classdesc Represents a LogConfig.
         * @implements ILogConfig
         * @constructor
         * @param {tradeconfig.ILogConfig=} [properties] Properties to set
         */
        function LogConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LogConfig logPath.
         * @member {string} logPath
         * @memberof tradeconfig.LogConfig
         * @instance
         */
        LogConfig.prototype.logPath = "";

        /**
         * LogConfig logLevel.
         * @member {tradeconfig.LogLevel} logLevel
         * @memberof tradeconfig.LogConfig
         * @instance
         */
        LogConfig.prototype.logLevel = 0;

        /**
         * LogConfig flushSecondInterval.
         * @member {number} flushSecondInterval
         * @memberof tradeconfig.LogConfig
         * @instance
         */
        LogConfig.prototype.flushSecondInterval = 0;

        /**
         * Creates a new LogConfig instance using the specified properties.
         * @function create
         * @memberof tradeconfig.LogConfig
         * @static
         * @param {tradeconfig.ILogConfig=} [properties] Properties to set
         * @returns {tradeconfig.LogConfig} LogConfig instance
         */
        LogConfig.create = function create(properties) {
            return new LogConfig(properties);
        };

        /**
         * Encodes the specified LogConfig message. Does not implicitly {@link tradeconfig.LogConfig.verify|verify} messages.
         * @function encode
         * @memberof tradeconfig.LogConfig
         * @static
         * @param {tradeconfig.ILogConfig} message LogConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logPath != null && Object.hasOwnProperty.call(message, "logPath"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.logPath);
            if (message.logLevel != null && Object.hasOwnProperty.call(message, "logLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.logLevel);
            if (message.flushSecondInterval != null && Object.hasOwnProperty.call(message, "flushSecondInterval"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.flushSecondInterval);
            return writer;
        };

        /**
         * Encodes the specified LogConfig message, length delimited. Does not implicitly {@link tradeconfig.LogConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tradeconfig.LogConfig
         * @static
         * @param {tradeconfig.ILogConfig} message LogConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LogConfig message from the specified reader or buffer.
         * @function decode
         * @memberof tradeconfig.LogConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tradeconfig.LogConfig} LogConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tradeconfig.LogConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.logPath = reader.string();
                    break;
                case 2:
                    message.logLevel = reader.int32();
                    break;
                case 3:
                    message.flushSecondInterval = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LogConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tradeconfig.LogConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tradeconfig.LogConfig} LogConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LogConfig message.
         * @function verify
         * @memberof tradeconfig.LogConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LogConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logPath != null && message.hasOwnProperty("logPath"))
                if (!$util.isString(message.logPath))
                    return "logPath: string expected";
            if (message.logLevel != null && message.hasOwnProperty("logLevel"))
                switch (message.logLevel) {
                default:
                    return "logLevel: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.flushSecondInterval != null && message.hasOwnProperty("flushSecondInterval"))
                if (!$util.isInteger(message.flushSecondInterval))
                    return "flushSecondInterval: integer expected";
            return null;
        };

        /**
         * Creates a LogConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tradeconfig.LogConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tradeconfig.LogConfig} LogConfig
         */
        LogConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.tradeconfig.LogConfig)
                return object;
            let message = new $root.tradeconfig.LogConfig();
            if (object.logPath != null)
                message.logPath = String(object.logPath);
            switch (object.logLevel) {
            case "TRACE":
            case 0:
                message.logLevel = 0;
                break;
            case "DEBUG":
            case 1:
                message.logLevel = 1;
                break;
            case "INFO":
            case 2:
                message.logLevel = 2;
                break;
            case "WARN":
            case 3:
                message.logLevel = 3;
                break;
            case "ERROR":
            case 4:
                message.logLevel = 4;
                break;
            case "CRITICAL":
            case 5:
                message.logLevel = 5;
                break;
            case "OFF":
            case 6:
                message.logLevel = 6;
                break;
            }
            if (object.flushSecondInterval != null)
                message.flushSecondInterval = object.flushSecondInterval >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a LogConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tradeconfig.LogConfig
         * @static
         * @param {tradeconfig.LogConfig} message LogConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LogConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.logPath = "";
                object.logLevel = options.enums === String ? "TRACE" : 0;
                object.flushSecondInterval = 0;
            }
            if (message.logPath != null && message.hasOwnProperty("logPath"))
                object.logPath = message.logPath;
            if (message.logLevel != null && message.hasOwnProperty("logLevel"))
                object.logLevel = options.enums === String ? $root.tradeconfig.LogLevel[message.logLevel] : message.logLevel;
            if (message.flushSecondInterval != null && message.hasOwnProperty("flushSecondInterval"))
                object.flushSecondInterval = message.flushSecondInterval;
            return object;
        };

        /**
         * Converts this LogConfig to JSON.
         * @function toJSON
         * @memberof tradeconfig.LogConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LogConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LogConfig;
    })();

    tradeconfig.FakeServerConfig = (function() {

        /**
         * Properties of a FakeServerConfig.
         * @memberof tradeconfig
         * @interface IFakeServerConfig
         * @property {string|null} [datapath] FakeServerConfig datapath
         * @property {string|null} [fileformat] FakeServerConfig fileformat
         * @property {number|null} [firstFileTs] FakeServerConfig firstFileTs
         * @property {number|null} [testDay] FakeServerConfig testDay
         * @property {string|null} [summarySavePath] FakeServerConfig summarySavePath
         * @property {string|null} [symbolId] FakeServerConfig symbolId
         */

        /**
         * Constructs a new FakeServerConfig.
         * @memberof tradeconfig
         * @classdesc Represents a FakeServerConfig.
         * @implements IFakeServerConfig
         * @constructor
         * @param {tradeconfig.IFakeServerConfig=} [properties] Properties to set
         */
        function FakeServerConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FakeServerConfig datapath.
         * @member {string} datapath
         * @memberof tradeconfig.FakeServerConfig
         * @instance
         */
        FakeServerConfig.prototype.datapath = "";

        /**
         * FakeServerConfig fileformat.
         * @member {string} fileformat
         * @memberof tradeconfig.FakeServerConfig
         * @instance
         */
        FakeServerConfig.prototype.fileformat = "";

        /**
         * FakeServerConfig firstFileTs.
         * @member {number} firstFileTs
         * @memberof tradeconfig.FakeServerConfig
         * @instance
         */
        FakeServerConfig.prototype.firstFileTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FakeServerConfig testDay.
         * @member {number} testDay
         * @memberof tradeconfig.FakeServerConfig
         * @instance
         */
        FakeServerConfig.prototype.testDay = 0;

        /**
         * FakeServerConfig summarySavePath.
         * @member {string} summarySavePath
         * @memberof tradeconfig.FakeServerConfig
         * @instance
         */
        FakeServerConfig.prototype.summarySavePath = "";

        /**
         * FakeServerConfig symbolId.
         * @member {string} symbolId
         * @memberof tradeconfig.FakeServerConfig
         * @instance
         */
        FakeServerConfig.prototype.symbolId = "";

        /**
         * Creates a new FakeServerConfig instance using the specified properties.
         * @function create
         * @memberof tradeconfig.FakeServerConfig
         * @static
         * @param {tradeconfig.IFakeServerConfig=} [properties] Properties to set
         * @returns {tradeconfig.FakeServerConfig} FakeServerConfig instance
         */
        FakeServerConfig.create = function create(properties) {
            return new FakeServerConfig(properties);
        };

        /**
         * Encodes the specified FakeServerConfig message. Does not implicitly {@link tradeconfig.FakeServerConfig.verify|verify} messages.
         * @function encode
         * @memberof tradeconfig.FakeServerConfig
         * @static
         * @param {tradeconfig.IFakeServerConfig} message FakeServerConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FakeServerConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.datapath != null && Object.hasOwnProperty.call(message, "datapath"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.datapath);
            if (message.fileformat != null && Object.hasOwnProperty.call(message, "fileformat"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileformat);
            if (message.firstFileTs != null && Object.hasOwnProperty.call(message, "firstFileTs"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.firstFileTs);
            if (message.testDay != null && Object.hasOwnProperty.call(message, "testDay"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.testDay);
            if (message.summarySavePath != null && Object.hasOwnProperty.call(message, "summarySavePath"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.summarySavePath);
            if (message.symbolId != null && Object.hasOwnProperty.call(message, "symbolId"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.symbolId);
            return writer;
        };

        /**
         * Encodes the specified FakeServerConfig message, length delimited. Does not implicitly {@link tradeconfig.FakeServerConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tradeconfig.FakeServerConfig
         * @static
         * @param {tradeconfig.IFakeServerConfig} message FakeServerConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FakeServerConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FakeServerConfig message from the specified reader or buffer.
         * @function decode
         * @memberof tradeconfig.FakeServerConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tradeconfig.FakeServerConfig} FakeServerConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FakeServerConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tradeconfig.FakeServerConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.datapath = reader.string();
                    break;
                case 2:
                    message.fileformat = reader.string();
                    break;
                case 3:
                    message.firstFileTs = reader.uint64();
                    break;
                case 4:
                    message.testDay = reader.uint32();
                    break;
                case 5:
                    message.summarySavePath = reader.string();
                    break;
                case 6:
                    message.symbolId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FakeServerConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tradeconfig.FakeServerConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tradeconfig.FakeServerConfig} FakeServerConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FakeServerConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FakeServerConfig message.
         * @function verify
         * @memberof tradeconfig.FakeServerConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FakeServerConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.datapath != null && message.hasOwnProperty("datapath"))
                if (!$util.isString(message.datapath))
                    return "datapath: string expected";
            if (message.fileformat != null && message.hasOwnProperty("fileformat"))
                if (!$util.isString(message.fileformat))
                    return "fileformat: string expected";
            if (message.firstFileTs != null && message.hasOwnProperty("firstFileTs"))
                if (!$util.isInteger(message.firstFileTs) && !(message.firstFileTs && $util.isInteger(message.firstFileTs.low) && $util.isInteger(message.firstFileTs.high)))
                    return "firstFileTs: integer|Long expected";
            if (message.testDay != null && message.hasOwnProperty("testDay"))
                if (!$util.isInteger(message.testDay))
                    return "testDay: integer expected";
            if (message.summarySavePath != null && message.hasOwnProperty("summarySavePath"))
                if (!$util.isString(message.summarySavePath))
                    return "summarySavePath: string expected";
            if (message.symbolId != null && message.hasOwnProperty("symbolId"))
                if (!$util.isString(message.symbolId))
                    return "symbolId: string expected";
            return null;
        };

        /**
         * Creates a FakeServerConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tradeconfig.FakeServerConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tradeconfig.FakeServerConfig} FakeServerConfig
         */
        FakeServerConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.tradeconfig.FakeServerConfig)
                return object;
            let message = new $root.tradeconfig.FakeServerConfig();
            if (object.datapath != null)
                message.datapath = String(object.datapath);
            if (object.fileformat != null)
                message.fileformat = String(object.fileformat);
            if (object.firstFileTs != null)
                if ($util.Long)
                    (message.firstFileTs = $util.Long.fromValue(object.firstFileTs)).unsigned = true;
                else if (typeof object.firstFileTs === "string")
                    message.firstFileTs = parseInt(object.firstFileTs, 10);
                else if (typeof object.firstFileTs === "number")
                    message.firstFileTs = object.firstFileTs;
                else if (typeof object.firstFileTs === "object")
                    message.firstFileTs = new $util.LongBits(object.firstFileTs.low >>> 0, object.firstFileTs.high >>> 0).toNumber(true);
            if (object.testDay != null)
                message.testDay = object.testDay >>> 0;
            if (object.summarySavePath != null)
                message.summarySavePath = String(object.summarySavePath);
            if (object.symbolId != null)
                message.symbolId = String(object.symbolId);
            return message;
        };

        /**
         * Creates a plain object from a FakeServerConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tradeconfig.FakeServerConfig
         * @static
         * @param {tradeconfig.FakeServerConfig} message FakeServerConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FakeServerConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.datapath = "";
                object.fileformat = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.firstFileTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.firstFileTs = options.longs === String ? "0" : 0;
                object.testDay = 0;
                object.summarySavePath = "";
                object.symbolId = "";
            }
            if (message.datapath != null && message.hasOwnProperty("datapath"))
                object.datapath = message.datapath;
            if (message.fileformat != null && message.hasOwnProperty("fileformat"))
                object.fileformat = message.fileformat;
            if (message.firstFileTs != null && message.hasOwnProperty("firstFileTs"))
                if (typeof message.firstFileTs === "number")
                    object.firstFileTs = options.longs === String ? String(message.firstFileTs) : message.firstFileTs;
                else
                    object.firstFileTs = options.longs === String ? $util.Long.prototype.toString.call(message.firstFileTs) : options.longs === Number ? new $util.LongBits(message.firstFileTs.low >>> 0, message.firstFileTs.high >>> 0).toNumber(true) : message.firstFileTs;
            if (message.testDay != null && message.hasOwnProperty("testDay"))
                object.testDay = message.testDay;
            if (message.summarySavePath != null && message.hasOwnProperty("summarySavePath"))
                object.summarySavePath = message.summarySavePath;
            if (message.symbolId != null && message.hasOwnProperty("symbolId"))
                object.symbolId = message.symbolId;
            return object;
        };

        /**
         * Converts this FakeServerConfig to JSON.
         * @function toJSON
         * @memberof tradeconfig.FakeServerConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FakeServerConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FakeServerConfig;
    })();

    tradeconfig.ServerConfig = (function() {

        /**
         * Properties of a ServerConfig.
         * @memberof tradeconfig
         * @interface IServerConfig
         * @property {string|null} [publishAddr] ServerConfig publishAddr
         * @property {string|null} [requestAddr] ServerConfig requestAddr
         * @property {st.Platform|null} [platform] ServerConfig platform
         * @property {string|null} [contract] ServerConfig contract
         * @property {string|null} [futureContractCode] ServerConfig futureContractCode
         * @property {st.ICoinFuture|null} [coinFuture] ServerConfig coinFuture
         * @property {number|null} [baseCont] ServerConfig baseCont
         * @property {string|null} [randomTargetProfitRatio] ServerConfig randomTargetProfitRatio
         * @property {number|null} [pollInterval] ServerConfig pollInterval
         * @property {tradeconfig.IRandomStrategyConfig|null} [randomStrategyConfig] ServerConfig randomStrategyConfig
         * @property {strategyparameter.IRapidTradeTriggerParameter|null} [rapidTradeParameter] ServerConfig rapidTradeParameter
         * @property {tradeconfig.IFakeServerConfig|null} [fakeServerConfig] ServerConfig fakeServerConfig
         */

        /**
         * Constructs a new ServerConfig.
         * @memberof tradeconfig
         * @classdesc Represents a ServerConfig.
         * @implements IServerConfig
         * @constructor
         * @param {tradeconfig.IServerConfig=} [properties] Properties to set
         */
        function ServerConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerConfig publishAddr.
         * @member {string} publishAddr
         * @memberof tradeconfig.ServerConfig
         * @instance
         */
        ServerConfig.prototype.publishAddr = "";

        /**
         * ServerConfig requestAddr.
         * @member {string} requestAddr
         * @memberof tradeconfig.ServerConfig
         * @instance
         */
        ServerConfig.prototype.requestAddr = "";

        /**
         * ServerConfig platform.
         * @member {st.Platform} platform
         * @memberof tradeconfig.ServerConfig
         * @instance
         */
        ServerConfig.prototype.platform = 0;

        /**
         * ServerConfig contract.
         * @member {string} contract
         * @memberof tradeconfig.ServerConfig
         * @instance
         */
        ServerConfig.prototype.contract = "";

        /**
         * ServerConfig futureContractCode.
         * @member {string} futureContractCode
         * @memberof tradeconfig.ServerConfig
         * @instance
         */
        ServerConfig.prototype.futureContractCode = "";

        /**
         * ServerConfig coinFuture.
         * @member {st.ICoinFuture|null|undefined} coinFuture
         * @memberof tradeconfig.ServerConfig
         * @instance
         */
        ServerConfig.prototype.coinFuture = null;

        /**
         * ServerConfig baseCont.
         * @member {number} baseCont
         * @memberof tradeconfig.ServerConfig
         * @instance
         */
        ServerConfig.prototype.baseCont = 0;

        /**
         * ServerConfig randomTargetProfitRatio.
         * @member {string} randomTargetProfitRatio
         * @memberof tradeconfig.ServerConfig
         * @instance
         */
        ServerConfig.prototype.randomTargetProfitRatio = "";

        /**
         * ServerConfig pollInterval.
         * @member {number} pollInterval
         * @memberof tradeconfig.ServerConfig
         * @instance
         */
        ServerConfig.prototype.pollInterval = 0;

        /**
         * ServerConfig randomStrategyConfig.
         * @member {tradeconfig.IRandomStrategyConfig|null|undefined} randomStrategyConfig
         * @memberof tradeconfig.ServerConfig
         * @instance
         */
        ServerConfig.prototype.randomStrategyConfig = null;

        /**
         * ServerConfig rapidTradeParameter.
         * @member {strategyparameter.IRapidTradeTriggerParameter|null|undefined} rapidTradeParameter
         * @memberof tradeconfig.ServerConfig
         * @instance
         */
        ServerConfig.prototype.rapidTradeParameter = null;

        /**
         * ServerConfig fakeServerConfig.
         * @member {tradeconfig.IFakeServerConfig|null|undefined} fakeServerConfig
         * @memberof tradeconfig.ServerConfig
         * @instance
         */
        ServerConfig.prototype.fakeServerConfig = null;

        /**
         * Creates a new ServerConfig instance using the specified properties.
         * @function create
         * @memberof tradeconfig.ServerConfig
         * @static
         * @param {tradeconfig.IServerConfig=} [properties] Properties to set
         * @returns {tradeconfig.ServerConfig} ServerConfig instance
         */
        ServerConfig.create = function create(properties) {
            return new ServerConfig(properties);
        };

        /**
         * Encodes the specified ServerConfig message. Does not implicitly {@link tradeconfig.ServerConfig.verify|verify} messages.
         * @function encode
         * @memberof tradeconfig.ServerConfig
         * @static
         * @param {tradeconfig.IServerConfig} message ServerConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publishAddr != null && Object.hasOwnProperty.call(message, "publishAddr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.publishAddr);
            if (message.requestAddr != null && Object.hasOwnProperty.call(message, "requestAddr"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.requestAddr);
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.platform);
            if (message.contract != null && Object.hasOwnProperty.call(message, "contract"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.contract);
            if (message.futureContractCode != null && Object.hasOwnProperty.call(message, "futureContractCode"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.futureContractCode);
            if (message.coinFuture != null && Object.hasOwnProperty.call(message, "coinFuture"))
                $root.st.CoinFuture.encode(message.coinFuture, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.baseCont != null && Object.hasOwnProperty.call(message, "baseCont"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.baseCont);
            if (message.randomTargetProfitRatio != null && Object.hasOwnProperty.call(message, "randomTargetProfitRatio"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.randomTargetProfitRatio);
            if (message.pollInterval != null && Object.hasOwnProperty.call(message, "pollInterval"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.pollInterval);
            if (message.randomStrategyConfig != null && Object.hasOwnProperty.call(message, "randomStrategyConfig"))
                $root.tradeconfig.RandomStrategyConfig.encode(message.randomStrategyConfig, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.rapidTradeParameter != null && Object.hasOwnProperty.call(message, "rapidTradeParameter"))
                $root.strategyparameter.RapidTradeTriggerParameter.encode(message.rapidTradeParameter, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.fakeServerConfig != null && Object.hasOwnProperty.call(message, "fakeServerConfig"))
                $root.tradeconfig.FakeServerConfig.encode(message.fakeServerConfig, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServerConfig message, length delimited. Does not implicitly {@link tradeconfig.ServerConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tradeconfig.ServerConfig
         * @static
         * @param {tradeconfig.IServerConfig} message ServerConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerConfig message from the specified reader or buffer.
         * @function decode
         * @memberof tradeconfig.ServerConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tradeconfig.ServerConfig} ServerConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tradeconfig.ServerConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publishAddr = reader.string();
                    break;
                case 2:
                    message.requestAddr = reader.string();
                    break;
                case 3:
                    message.platform = reader.int32();
                    break;
                case 4:
                    message.contract = reader.string();
                    break;
                case 5:
                    message.futureContractCode = reader.string();
                    break;
                case 6:
                    message.coinFuture = $root.st.CoinFuture.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.baseCont = reader.uint32();
                    break;
                case 8:
                    message.randomTargetProfitRatio = reader.string();
                    break;
                case 9:
                    message.pollInterval = reader.uint32();
                    break;
                case 10:
                    message.randomStrategyConfig = $root.tradeconfig.RandomStrategyConfig.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.rapidTradeParameter = $root.strategyparameter.RapidTradeTriggerParameter.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.fakeServerConfig = $root.tradeconfig.FakeServerConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tradeconfig.ServerConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tradeconfig.ServerConfig} ServerConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerConfig message.
         * @function verify
         * @memberof tradeconfig.ServerConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publishAddr != null && message.hasOwnProperty("publishAddr"))
                if (!$util.isString(message.publishAddr))
                    return "publishAddr: string expected";
            if (message.requestAddr != null && message.hasOwnProperty("requestAddr"))
                if (!$util.isString(message.requestAddr))
                    return "requestAddr: string expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                switch (message.platform) {
                default:
                    return "platform: enum value expected";
                case 0:
                case 2:
                case 3:
                    break;
                }
            if (message.contract != null && message.hasOwnProperty("contract"))
                if (!$util.isString(message.contract))
                    return "contract: string expected";
            if (message.futureContractCode != null && message.hasOwnProperty("futureContractCode"))
                if (!$util.isString(message.futureContractCode))
                    return "futureContractCode: string expected";
            if (message.coinFuture != null && message.hasOwnProperty("coinFuture")) {
                let error = $root.st.CoinFuture.verify(message.coinFuture);
                if (error)
                    return "coinFuture." + error;
            }
            if (message.baseCont != null && message.hasOwnProperty("baseCont"))
                if (!$util.isInteger(message.baseCont))
                    return "baseCont: integer expected";
            if (message.randomTargetProfitRatio != null && message.hasOwnProperty("randomTargetProfitRatio"))
                if (!$util.isString(message.randomTargetProfitRatio))
                    return "randomTargetProfitRatio: string expected";
            if (message.pollInterval != null && message.hasOwnProperty("pollInterval"))
                if (!$util.isInteger(message.pollInterval))
                    return "pollInterval: integer expected";
            if (message.randomStrategyConfig != null && message.hasOwnProperty("randomStrategyConfig")) {
                let error = $root.tradeconfig.RandomStrategyConfig.verify(message.randomStrategyConfig);
                if (error)
                    return "randomStrategyConfig." + error;
            }
            if (message.rapidTradeParameter != null && message.hasOwnProperty("rapidTradeParameter")) {
                let error = $root.strategyparameter.RapidTradeTriggerParameter.verify(message.rapidTradeParameter);
                if (error)
                    return "rapidTradeParameter." + error;
            }
            if (message.fakeServerConfig != null && message.hasOwnProperty("fakeServerConfig")) {
                let error = $root.tradeconfig.FakeServerConfig.verify(message.fakeServerConfig);
                if (error)
                    return "fakeServerConfig." + error;
            }
            return null;
        };

        /**
         * Creates a ServerConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tradeconfig.ServerConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tradeconfig.ServerConfig} ServerConfig
         */
        ServerConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.tradeconfig.ServerConfig)
                return object;
            let message = new $root.tradeconfig.ServerConfig();
            if (object.publishAddr != null)
                message.publishAddr = String(object.publishAddr);
            if (object.requestAddr != null)
                message.requestAddr = String(object.requestAddr);
            switch (object.platform) {
            case "FAKE":
            case 0:
                message.platform = 0;
                break;
            case "HUOBI":
            case 2:
                message.platform = 2;
                break;
            case "BYBIT":
            case 3:
                message.platform = 3;
                break;
            }
            if (object.contract != null)
                message.contract = String(object.contract);
            if (object.futureContractCode != null)
                message.futureContractCode = String(object.futureContractCode);
            if (object.coinFuture != null) {
                if (typeof object.coinFuture !== "object")
                    throw TypeError(".tradeconfig.ServerConfig.coinFuture: object expected");
                message.coinFuture = $root.st.CoinFuture.fromObject(object.coinFuture);
            }
            if (object.baseCont != null)
                message.baseCont = object.baseCont >>> 0;
            if (object.randomTargetProfitRatio != null)
                message.randomTargetProfitRatio = String(object.randomTargetProfitRatio);
            if (object.pollInterval != null)
                message.pollInterval = object.pollInterval >>> 0;
            if (object.randomStrategyConfig != null) {
                if (typeof object.randomStrategyConfig !== "object")
                    throw TypeError(".tradeconfig.ServerConfig.randomStrategyConfig: object expected");
                message.randomStrategyConfig = $root.tradeconfig.RandomStrategyConfig.fromObject(object.randomStrategyConfig);
            }
            if (object.rapidTradeParameter != null) {
                if (typeof object.rapidTradeParameter !== "object")
                    throw TypeError(".tradeconfig.ServerConfig.rapidTradeParameter: object expected");
                message.rapidTradeParameter = $root.strategyparameter.RapidTradeTriggerParameter.fromObject(object.rapidTradeParameter);
            }
            if (object.fakeServerConfig != null) {
                if (typeof object.fakeServerConfig !== "object")
                    throw TypeError(".tradeconfig.ServerConfig.fakeServerConfig: object expected");
                message.fakeServerConfig = $root.tradeconfig.FakeServerConfig.fromObject(object.fakeServerConfig);
            }
            return message;
        };

        /**
         * Creates a plain object from a ServerConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tradeconfig.ServerConfig
         * @static
         * @param {tradeconfig.ServerConfig} message ServerConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.publishAddr = "";
                object.requestAddr = "";
                object.platform = options.enums === String ? "FAKE" : 0;
                object.contract = "";
                object.futureContractCode = "";
                object.coinFuture = null;
                object.baseCont = 0;
                object.randomTargetProfitRatio = "";
                object.pollInterval = 0;
                object.randomStrategyConfig = null;
                object.rapidTradeParameter = null;
                object.fakeServerConfig = null;
            }
            if (message.publishAddr != null && message.hasOwnProperty("publishAddr"))
                object.publishAddr = message.publishAddr;
            if (message.requestAddr != null && message.hasOwnProperty("requestAddr"))
                object.requestAddr = message.requestAddr;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = options.enums === String ? $root.st.Platform[message.platform] : message.platform;
            if (message.contract != null && message.hasOwnProperty("contract"))
                object.contract = message.contract;
            if (message.futureContractCode != null && message.hasOwnProperty("futureContractCode"))
                object.futureContractCode = message.futureContractCode;
            if (message.coinFuture != null && message.hasOwnProperty("coinFuture"))
                object.coinFuture = $root.st.CoinFuture.toObject(message.coinFuture, options);
            if (message.baseCont != null && message.hasOwnProperty("baseCont"))
                object.baseCont = message.baseCont;
            if (message.randomTargetProfitRatio != null && message.hasOwnProperty("randomTargetProfitRatio"))
                object.randomTargetProfitRatio = message.randomTargetProfitRatio;
            if (message.pollInterval != null && message.hasOwnProperty("pollInterval"))
                object.pollInterval = message.pollInterval;
            if (message.randomStrategyConfig != null && message.hasOwnProperty("randomStrategyConfig"))
                object.randomStrategyConfig = $root.tradeconfig.RandomStrategyConfig.toObject(message.randomStrategyConfig, options);
            if (message.rapidTradeParameter != null && message.hasOwnProperty("rapidTradeParameter"))
                object.rapidTradeParameter = $root.strategyparameter.RapidTradeTriggerParameter.toObject(message.rapidTradeParameter, options);
            if (message.fakeServerConfig != null && message.hasOwnProperty("fakeServerConfig"))
                object.fakeServerConfig = $root.tradeconfig.FakeServerConfig.toObject(message.fakeServerConfig, options);
            return object;
        };

        /**
         * Converts this ServerConfig to JSON.
         * @function toJSON
         * @memberof tradeconfig.ServerConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServerConfig;
    })();

    tradeconfig.ParameterConfig = (function() {

        /**
         * Properties of a ParameterConfig.
         * @memberof tradeconfig
         * @interface IParameterConfig
         * @property {string|null} [apolloAddr] ParameterConfig apolloAddr
         */

        /**
         * Constructs a new ParameterConfig.
         * @memberof tradeconfig
         * @classdesc Represents a ParameterConfig.
         * @implements IParameterConfig
         * @constructor
         * @param {tradeconfig.IParameterConfig=} [properties] Properties to set
         */
        function ParameterConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ParameterConfig apolloAddr.
         * @member {string} apolloAddr
         * @memberof tradeconfig.ParameterConfig
         * @instance
         */
        ParameterConfig.prototype.apolloAddr = "";

        /**
         * Creates a new ParameterConfig instance using the specified properties.
         * @function create
         * @memberof tradeconfig.ParameterConfig
         * @static
         * @param {tradeconfig.IParameterConfig=} [properties] Properties to set
         * @returns {tradeconfig.ParameterConfig} ParameterConfig instance
         */
        ParameterConfig.create = function create(properties) {
            return new ParameterConfig(properties);
        };

        /**
         * Encodes the specified ParameterConfig message. Does not implicitly {@link tradeconfig.ParameterConfig.verify|verify} messages.
         * @function encode
         * @memberof tradeconfig.ParameterConfig
         * @static
         * @param {tradeconfig.IParameterConfig} message ParameterConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ParameterConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.apolloAddr != null && Object.hasOwnProperty.call(message, "apolloAddr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.apolloAddr);
            return writer;
        };

        /**
         * Encodes the specified ParameterConfig message, length delimited. Does not implicitly {@link tradeconfig.ParameterConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tradeconfig.ParameterConfig
         * @static
         * @param {tradeconfig.IParameterConfig} message ParameterConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ParameterConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ParameterConfig message from the specified reader or buffer.
         * @function decode
         * @memberof tradeconfig.ParameterConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tradeconfig.ParameterConfig} ParameterConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ParameterConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tradeconfig.ParameterConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.apolloAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ParameterConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tradeconfig.ParameterConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tradeconfig.ParameterConfig} ParameterConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ParameterConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ParameterConfig message.
         * @function verify
         * @memberof tradeconfig.ParameterConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ParameterConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.apolloAddr != null && message.hasOwnProperty("apolloAddr"))
                if (!$util.isString(message.apolloAddr))
                    return "apolloAddr: string expected";
            return null;
        };

        /**
         * Creates a ParameterConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tradeconfig.ParameterConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tradeconfig.ParameterConfig} ParameterConfig
         */
        ParameterConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.tradeconfig.ParameterConfig)
                return object;
            let message = new $root.tradeconfig.ParameterConfig();
            if (object.apolloAddr != null)
                message.apolloAddr = String(object.apolloAddr);
            return message;
        };

        /**
         * Creates a plain object from a ParameterConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tradeconfig.ParameterConfig
         * @static
         * @param {tradeconfig.ParameterConfig} message ParameterConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ParameterConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.apolloAddr = "";
            if (message.apolloAddr != null && message.hasOwnProperty("apolloAddr"))
                object.apolloAddr = message.apolloAddr;
            return object;
        };

        /**
         * Converts this ParameterConfig to JSON.
         * @function toJSON
         * @memberof tradeconfig.ParameterConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ParameterConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ParameterConfig;
    })();

    tradeconfig.RandomStrategyConfig = (function() {

        /**
         * Properties of a RandomStrategyConfig.
         * @memberof tradeconfig
         * @interface IRandomStrategyConfig
         * @property {string|null} [targetProfit] RandomStrategyConfig targetProfit
         * @property {st.ICoinFuture|null} [future] RandomStrategyConfig future
         */

        /**
         * Constructs a new RandomStrategyConfig.
         * @memberof tradeconfig
         * @classdesc Represents a RandomStrategyConfig.
         * @implements IRandomStrategyConfig
         * @constructor
         * @param {tradeconfig.IRandomStrategyConfig=} [properties] Properties to set
         */
        function RandomStrategyConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RandomStrategyConfig targetProfit.
         * @member {string} targetProfit
         * @memberof tradeconfig.RandomStrategyConfig
         * @instance
         */
        RandomStrategyConfig.prototype.targetProfit = "";

        /**
         * RandomStrategyConfig future.
         * @member {st.ICoinFuture|null|undefined} future
         * @memberof tradeconfig.RandomStrategyConfig
         * @instance
         */
        RandomStrategyConfig.prototype.future = null;

        /**
         * Creates a new RandomStrategyConfig instance using the specified properties.
         * @function create
         * @memberof tradeconfig.RandomStrategyConfig
         * @static
         * @param {tradeconfig.IRandomStrategyConfig=} [properties] Properties to set
         * @returns {tradeconfig.RandomStrategyConfig} RandomStrategyConfig instance
         */
        RandomStrategyConfig.create = function create(properties) {
            return new RandomStrategyConfig(properties);
        };

        /**
         * Encodes the specified RandomStrategyConfig message. Does not implicitly {@link tradeconfig.RandomStrategyConfig.verify|verify} messages.
         * @function encode
         * @memberof tradeconfig.RandomStrategyConfig
         * @static
         * @param {tradeconfig.IRandomStrategyConfig} message RandomStrategyConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RandomStrategyConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targetProfit != null && Object.hasOwnProperty.call(message, "targetProfit"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetProfit);
            if (message.future != null && Object.hasOwnProperty.call(message, "future"))
                $root.st.CoinFuture.encode(message.future, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RandomStrategyConfig message, length delimited. Does not implicitly {@link tradeconfig.RandomStrategyConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tradeconfig.RandomStrategyConfig
         * @static
         * @param {tradeconfig.IRandomStrategyConfig} message RandomStrategyConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RandomStrategyConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RandomStrategyConfig message from the specified reader or buffer.
         * @function decode
         * @memberof tradeconfig.RandomStrategyConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tradeconfig.RandomStrategyConfig} RandomStrategyConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RandomStrategyConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tradeconfig.RandomStrategyConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.targetProfit = reader.string();
                    break;
                case 2:
                    message.future = $root.st.CoinFuture.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RandomStrategyConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tradeconfig.RandomStrategyConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tradeconfig.RandomStrategyConfig} RandomStrategyConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RandomStrategyConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RandomStrategyConfig message.
         * @function verify
         * @memberof tradeconfig.RandomStrategyConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RandomStrategyConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.targetProfit != null && message.hasOwnProperty("targetProfit"))
                if (!$util.isString(message.targetProfit))
                    return "targetProfit: string expected";
            if (message.future != null && message.hasOwnProperty("future")) {
                let error = $root.st.CoinFuture.verify(message.future);
                if (error)
                    return "future." + error;
            }
            return null;
        };

        /**
         * Creates a RandomStrategyConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tradeconfig.RandomStrategyConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tradeconfig.RandomStrategyConfig} RandomStrategyConfig
         */
        RandomStrategyConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.tradeconfig.RandomStrategyConfig)
                return object;
            let message = new $root.tradeconfig.RandomStrategyConfig();
            if (object.targetProfit != null)
                message.targetProfit = String(object.targetProfit);
            if (object.future != null) {
                if (typeof object.future !== "object")
                    throw TypeError(".tradeconfig.RandomStrategyConfig.future: object expected");
                message.future = $root.st.CoinFuture.fromObject(object.future);
            }
            return message;
        };

        /**
         * Creates a plain object from a RandomStrategyConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tradeconfig.RandomStrategyConfig
         * @static
         * @param {tradeconfig.RandomStrategyConfig} message RandomStrategyConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RandomStrategyConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.targetProfit = "";
                object.future = null;
            }
            if (message.targetProfit != null && message.hasOwnProperty("targetProfit"))
                object.targetProfit = message.targetProfit;
            if (message.future != null && message.hasOwnProperty("future"))
                object.future = $root.st.CoinFuture.toObject(message.future, options);
            return object;
        };

        /**
         * Converts this RandomStrategyConfig to JSON.
         * @function toJSON
         * @memberof tradeconfig.RandomStrategyConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RandomStrategyConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RandomStrategyConfig;
    })();

    tradeconfig.RedisConfig = (function() {

        /**
         * Properties of a RedisConfig.
         * @memberof tradeconfig
         * @interface IRedisConfig
         * @property {string|null} [addr] RedisConfig addr
         * @property {string|null} [port] RedisConfig port
         * @property {string|null} [password] RedisConfig password
         */

        /**
         * Constructs a new RedisConfig.
         * @memberof tradeconfig
         * @classdesc Represents a RedisConfig.
         * @implements IRedisConfig
         * @constructor
         * @param {tradeconfig.IRedisConfig=} [properties] Properties to set
         */
        function RedisConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RedisConfig addr.
         * @member {string} addr
         * @memberof tradeconfig.RedisConfig
         * @instance
         */
        RedisConfig.prototype.addr = "";

        /**
         * RedisConfig port.
         * @member {string} port
         * @memberof tradeconfig.RedisConfig
         * @instance
         */
        RedisConfig.prototype.port = "";

        /**
         * RedisConfig password.
         * @member {string} password
         * @memberof tradeconfig.RedisConfig
         * @instance
         */
        RedisConfig.prototype.password = "";

        /**
         * Creates a new RedisConfig instance using the specified properties.
         * @function create
         * @memberof tradeconfig.RedisConfig
         * @static
         * @param {tradeconfig.IRedisConfig=} [properties] Properties to set
         * @returns {tradeconfig.RedisConfig} RedisConfig instance
         */
        RedisConfig.create = function create(properties) {
            return new RedisConfig(properties);
        };

        /**
         * Encodes the specified RedisConfig message. Does not implicitly {@link tradeconfig.RedisConfig.verify|verify} messages.
         * @function encode
         * @memberof tradeconfig.RedisConfig
         * @static
         * @param {tradeconfig.IRedisConfig} message RedisConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedisConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addr != null && Object.hasOwnProperty.call(message, "addr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.addr);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.port);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
            return writer;
        };

        /**
         * Encodes the specified RedisConfig message, length delimited. Does not implicitly {@link tradeconfig.RedisConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tradeconfig.RedisConfig
         * @static
         * @param {tradeconfig.IRedisConfig} message RedisConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedisConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RedisConfig message from the specified reader or buffer.
         * @function decode
         * @memberof tradeconfig.RedisConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tradeconfig.RedisConfig} RedisConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedisConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tradeconfig.RedisConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.addr = reader.string();
                    break;
                case 2:
                    message.port = reader.string();
                    break;
                case 3:
                    message.password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedisConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tradeconfig.RedisConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tradeconfig.RedisConfig} RedisConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedisConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RedisConfig message.
         * @function verify
         * @memberof tradeconfig.RedisConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RedisConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addr != null && message.hasOwnProperty("addr"))
                if (!$util.isString(message.addr))
                    return "addr: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isString(message.port))
                    return "port: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            return null;
        };

        /**
         * Creates a RedisConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tradeconfig.RedisConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tradeconfig.RedisConfig} RedisConfig
         */
        RedisConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.tradeconfig.RedisConfig)
                return object;
            let message = new $root.tradeconfig.RedisConfig();
            if (object.addr != null)
                message.addr = String(object.addr);
            if (object.port != null)
                message.port = String(object.port);
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };

        /**
         * Creates a plain object from a RedisConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tradeconfig.RedisConfig
         * @static
         * @param {tradeconfig.RedisConfig} message RedisConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedisConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.addr = "";
                object.port = "";
                object.password = "";
            }
            if (message.addr != null && message.hasOwnProperty("addr"))
                object.addr = message.addr;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            return object;
        };

        /**
         * Converts this RedisConfig to JSON.
         * @function toJSON
         * @memberof tradeconfig.RedisConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedisConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RedisConfig;
    })();

    tradeconfig.SetUpConfig = (function() {

        /**
         * Properties of a SetUpConfig.
         * @memberof tradeconfig
         * @interface ISetUpConfig
         * @property {tradeconfig.ILogConfig|null} [logConfig] SetUpConfig logConfig
         * @property {tradeconfig.IServerConfig|null} [serverConfig] SetUpConfig serverConfig
         * @property {tradeconfig.IParameterConfig|null} [parameterConfig] SetUpConfig parameterConfig
         * @property {tradeconfig.IRedisConfig|null} [redisConfig] SetUpConfig redisConfig
         */

        /**
         * Constructs a new SetUpConfig.
         * @memberof tradeconfig
         * @classdesc Represents a SetUpConfig.
         * @implements ISetUpConfig
         * @constructor
         * @param {tradeconfig.ISetUpConfig=} [properties] Properties to set
         */
        function SetUpConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetUpConfig logConfig.
         * @member {tradeconfig.ILogConfig|null|undefined} logConfig
         * @memberof tradeconfig.SetUpConfig
         * @instance
         */
        SetUpConfig.prototype.logConfig = null;

        /**
         * SetUpConfig serverConfig.
         * @member {tradeconfig.IServerConfig|null|undefined} serverConfig
         * @memberof tradeconfig.SetUpConfig
         * @instance
         */
        SetUpConfig.prototype.serverConfig = null;

        /**
         * SetUpConfig parameterConfig.
         * @member {tradeconfig.IParameterConfig|null|undefined} parameterConfig
         * @memberof tradeconfig.SetUpConfig
         * @instance
         */
        SetUpConfig.prototype.parameterConfig = null;

        /**
         * SetUpConfig redisConfig.
         * @member {tradeconfig.IRedisConfig|null|undefined} redisConfig
         * @memberof tradeconfig.SetUpConfig
         * @instance
         */
        SetUpConfig.prototype.redisConfig = null;

        /**
         * Creates a new SetUpConfig instance using the specified properties.
         * @function create
         * @memberof tradeconfig.SetUpConfig
         * @static
         * @param {tradeconfig.ISetUpConfig=} [properties] Properties to set
         * @returns {tradeconfig.SetUpConfig} SetUpConfig instance
         */
        SetUpConfig.create = function create(properties) {
            return new SetUpConfig(properties);
        };

        /**
         * Encodes the specified SetUpConfig message. Does not implicitly {@link tradeconfig.SetUpConfig.verify|verify} messages.
         * @function encode
         * @memberof tradeconfig.SetUpConfig
         * @static
         * @param {tradeconfig.ISetUpConfig} message SetUpConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetUpConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logConfig != null && Object.hasOwnProperty.call(message, "logConfig"))
                $root.tradeconfig.LogConfig.encode(message.logConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.serverConfig != null && Object.hasOwnProperty.call(message, "serverConfig"))
                $root.tradeconfig.ServerConfig.encode(message.serverConfig, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.parameterConfig != null && Object.hasOwnProperty.call(message, "parameterConfig"))
                $root.tradeconfig.ParameterConfig.encode(message.parameterConfig, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.redisConfig != null && Object.hasOwnProperty.call(message, "redisConfig"))
                $root.tradeconfig.RedisConfig.encode(message.redisConfig, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SetUpConfig message, length delimited. Does not implicitly {@link tradeconfig.SetUpConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof tradeconfig.SetUpConfig
         * @static
         * @param {tradeconfig.ISetUpConfig} message SetUpConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetUpConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetUpConfig message from the specified reader or buffer.
         * @function decode
         * @memberof tradeconfig.SetUpConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {tradeconfig.SetUpConfig} SetUpConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetUpConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.tradeconfig.SetUpConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.logConfig = $root.tradeconfig.LogConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.serverConfig = $root.tradeconfig.ServerConfig.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.parameterConfig = $root.tradeconfig.ParameterConfig.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.redisConfig = $root.tradeconfig.RedisConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetUpConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof tradeconfig.SetUpConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {tradeconfig.SetUpConfig} SetUpConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetUpConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetUpConfig message.
         * @function verify
         * @memberof tradeconfig.SetUpConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetUpConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logConfig != null && message.hasOwnProperty("logConfig")) {
                let error = $root.tradeconfig.LogConfig.verify(message.logConfig);
                if (error)
                    return "logConfig." + error;
            }
            if (message.serverConfig != null && message.hasOwnProperty("serverConfig")) {
                let error = $root.tradeconfig.ServerConfig.verify(message.serverConfig);
                if (error)
                    return "serverConfig." + error;
            }
            if (message.parameterConfig != null && message.hasOwnProperty("parameterConfig")) {
                let error = $root.tradeconfig.ParameterConfig.verify(message.parameterConfig);
                if (error)
                    return "parameterConfig." + error;
            }
            if (message.redisConfig != null && message.hasOwnProperty("redisConfig")) {
                let error = $root.tradeconfig.RedisConfig.verify(message.redisConfig);
                if (error)
                    return "redisConfig." + error;
            }
            return null;
        };

        /**
         * Creates a SetUpConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof tradeconfig.SetUpConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {tradeconfig.SetUpConfig} SetUpConfig
         */
        SetUpConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.tradeconfig.SetUpConfig)
                return object;
            let message = new $root.tradeconfig.SetUpConfig();
            if (object.logConfig != null) {
                if (typeof object.logConfig !== "object")
                    throw TypeError(".tradeconfig.SetUpConfig.logConfig: object expected");
                message.logConfig = $root.tradeconfig.LogConfig.fromObject(object.logConfig);
            }
            if (object.serverConfig != null) {
                if (typeof object.serverConfig !== "object")
                    throw TypeError(".tradeconfig.SetUpConfig.serverConfig: object expected");
                message.serverConfig = $root.tradeconfig.ServerConfig.fromObject(object.serverConfig);
            }
            if (object.parameterConfig != null) {
                if (typeof object.parameterConfig !== "object")
                    throw TypeError(".tradeconfig.SetUpConfig.parameterConfig: object expected");
                message.parameterConfig = $root.tradeconfig.ParameterConfig.fromObject(object.parameterConfig);
            }
            if (object.redisConfig != null) {
                if (typeof object.redisConfig !== "object")
                    throw TypeError(".tradeconfig.SetUpConfig.redisConfig: object expected");
                message.redisConfig = $root.tradeconfig.RedisConfig.fromObject(object.redisConfig);
            }
            return message;
        };

        /**
         * Creates a plain object from a SetUpConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof tradeconfig.SetUpConfig
         * @static
         * @param {tradeconfig.SetUpConfig} message SetUpConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetUpConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.logConfig = null;
                object.serverConfig = null;
                object.parameterConfig = null;
                object.redisConfig = null;
            }
            if (message.logConfig != null && message.hasOwnProperty("logConfig"))
                object.logConfig = $root.tradeconfig.LogConfig.toObject(message.logConfig, options);
            if (message.serverConfig != null && message.hasOwnProperty("serverConfig"))
                object.serverConfig = $root.tradeconfig.ServerConfig.toObject(message.serverConfig, options);
            if (message.parameterConfig != null && message.hasOwnProperty("parameterConfig"))
                object.parameterConfig = $root.tradeconfig.ParameterConfig.toObject(message.parameterConfig, options);
            if (message.redisConfig != null && message.hasOwnProperty("redisConfig"))
                object.redisConfig = $root.tradeconfig.RedisConfig.toObject(message.redisConfig, options);
            return object;
        };

        /**
         * Converts this SetUpConfig to JSON.
         * @function toJSON
         * @memberof tradeconfig.SetUpConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetUpConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetUpConfig;
    })();

    return tradeconfig;
})();

export const st = $root.st = (() => {

    /**
     * Namespace st.
     * @exports st
     * @namespace
     */
    const st = {};

    /**
     * TradeState enum.
     * @name st.TradeState
     * @enum {number}
     * @property {number} DEFAULT_TRADE_STATE=0 DEFAULT_TRADE_STATE value
     * @property {number} TRADE_UNSUBMIT=1 TRADE_UNSUBMIT value
     * @property {number} TRADE_SUBMITTED=2 TRADE_SUBMITTED value
     * @property {number} TRADE_EXECUTING=3 TRADE_EXECUTING value
     * @property {number} TRADE_FINISHED=4 TRADE_FINISHED value
     * @property {number} TRADE_CLOSING=5 TRADE_CLOSING value
     */
    st.TradeState = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_TRADE_STATE"] = 0;
        values[valuesById[1] = "TRADE_UNSUBMIT"] = 1;
        values[valuesById[2] = "TRADE_SUBMITTED"] = 2;
        values[valuesById[3] = "TRADE_EXECUTING"] = 3;
        values[valuesById[4] = "TRADE_FINISHED"] = 4;
        values[valuesById[5] = "TRADE_CLOSING"] = 5;
        return values;
    })();

    /**
     * TradeSubState enum.
     * @name st.TradeSubState
     * @enum {number}
     * @property {number} DEFAULT_TRADE_SUB_STATE=0 DEFAULT_TRADE_SUB_STATE value
     * @property {number} TRADE_SUB_UNSUBMIT=1 TRADE_SUB_UNSUBMIT value
     * @property {number} TRADE_SUB_SUBMITTED=2 TRADE_SUB_SUBMITTED value
     * @property {number} TRADE_SUB_PARTIAL_FILLED=3 TRADE_SUB_PARTIAL_FILLED value
     * @property {number} TRADE_SUB_FULL_FILLED=4 TRADE_SUB_FULL_FILLED value
     * @property {number} TRADE_SUB_CANCELING=5 TRADE_SUB_CANCELING value
     * @property {number} TRADE_SUB_CANCELED=6 TRADE_SUB_CANCELED value
     * @property {number} TRADE_SUB_REJECTED=7 TRADE_SUB_REJECTED value
     * @property {number} TRADE_SUB_EXECUTING=8 TRADE_SUB_EXECUTING value
     * @property {number} TRADE_TIMEOUT_CLOSED=9 TRADE_TIMEOUT_CLOSED value
     */
    st.TradeSubState = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_TRADE_SUB_STATE"] = 0;
        values[valuesById[1] = "TRADE_SUB_UNSUBMIT"] = 1;
        values[valuesById[2] = "TRADE_SUB_SUBMITTED"] = 2;
        values[valuesById[3] = "TRADE_SUB_PARTIAL_FILLED"] = 3;
        values[valuesById[4] = "TRADE_SUB_FULL_FILLED"] = 4;
        values[valuesById[5] = "TRADE_SUB_CANCELING"] = 5;
        values[valuesById[6] = "TRADE_SUB_CANCELED"] = 6;
        values[valuesById[7] = "TRADE_SUB_REJECTED"] = 7;
        values[valuesById[8] = "TRADE_SUB_EXECUTING"] = 8;
        values[valuesById[9] = "TRADE_TIMEOUT_CLOSED"] = 9;
        return values;
    })();

    /**
     * TradeDir enum.
     * @name st.TradeDir
     * @enum {number}
     * @property {number} DEFAULT_TRADE_DIR=0 DEFAULT_TRADE_DIR value
     * @property {number} BID=1 BID value
     * @property {number} ASK=2 ASK value
     */
    st.TradeDir = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_TRADE_DIR"] = 0;
        values[valuesById[1] = "BID"] = 1;
        values[valuesById[2] = "ASK"] = 2;
        return values;
    })();

    /**
     * TradeType enum.
     * @name st.TradeType
     * @enum {number}
     * @property {number} DEFAULT_TRADE_TYPE=0 DEFAULT_TRADE_TYPE value
     * @property {number} POSITIVE=1 POSITIVE value
     * @property {number} NEG=2 NEG value
     */
    st.TradeType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_TRADE_TYPE"] = 0;
        values[valuesById[1] = "POSITIVE"] = 1;
        values[valuesById[2] = "NEG"] = 2;
        return values;
    })();

    /**
     * TradeTargetType enum.
     * @name st.TradeTargetType
     * @enum {number}
     * @property {number} DEFAULT_TARGET_TYPE=0 DEFAULT_TARGET_TYPE value
     * @property {number} OPEN=1 OPEN value
     * @property {number} CLOSE=2 CLOSE value
     */
    st.TradeTargetType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_TARGET_TYPE"] = 0;
        values[valuesById[1] = "OPEN"] = 1;
        values[valuesById[2] = "CLOSE"] = 2;
        return values;
    })();

    /**
     * Platform enum.
     * @name st.Platform
     * @enum {number}
     * @property {number} FAKE=0 FAKE value
     * @property {number} HUOBI=2 HUOBI value
     * @property {number} BYBIT=3 BYBIT value
     */
    st.Platform = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FAKE"] = 0;
        values[valuesById[2] = "HUOBI"] = 2;
        values[valuesById[3] = "BYBIT"] = 3;
        return values;
    })();

    /**
     * TradeCommandType enum.
     * @name st.TradeCommandType
     * @enum {number}
     * @property {number} DEFAULT_COMMAND_TYPE=0 DEFAULT_COMMAND_TYPE value
     * @property {number} LIMIT_MAKER=1 LIMIT_MAKER value
     * @property {number} FOK_TAKER=2 FOK_TAKER value
     */
    st.TradeCommandType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_COMMAND_TYPE"] = 0;
        values[valuesById[1] = "LIMIT_MAKER"] = 1;
        values[valuesById[2] = "FOK_TAKER"] = 2;
        return values;
    })();

    st.CoinFuture = (function() {

        /**
         * Properties of a CoinFuture.
         * @memberof st
         * @interface ICoinFuture
         * @property {string|null} [symbol] CoinFuture symbol
         * @property {string|null} [currency] CoinFuture currency
         * @property {string|null} [commodity] CoinFuture commodity
         * @property {number|null} [contUnit] CoinFuture contUnit
         * @property {string|null} [priceSlot] CoinFuture priceSlot
         * @property {st.Platform|null} [platform] CoinFuture platform
         */

        /**
         * Constructs a new CoinFuture.
         * @memberof st
         * @classdesc Represents a CoinFuture.
         * @implements ICoinFuture
         * @constructor
         * @param {st.ICoinFuture=} [properties] Properties to set
         */
        function CoinFuture(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoinFuture symbol.
         * @member {string} symbol
         * @memberof st.CoinFuture
         * @instance
         */
        CoinFuture.prototype.symbol = "";

        /**
         * CoinFuture currency.
         * @member {string} currency
         * @memberof st.CoinFuture
         * @instance
         */
        CoinFuture.prototype.currency = "";

        /**
         * CoinFuture commodity.
         * @member {string} commodity
         * @memberof st.CoinFuture
         * @instance
         */
        CoinFuture.prototype.commodity = "";

        /**
         * CoinFuture contUnit.
         * @member {number} contUnit
         * @memberof st.CoinFuture
         * @instance
         */
        CoinFuture.prototype.contUnit = 0;

        /**
         * CoinFuture priceSlot.
         * @member {string} priceSlot
         * @memberof st.CoinFuture
         * @instance
         */
        CoinFuture.prototype.priceSlot = "";

        /**
         * CoinFuture platform.
         * @member {st.Platform} platform
         * @memberof st.CoinFuture
         * @instance
         */
        CoinFuture.prototype.platform = 0;

        /**
         * Creates a new CoinFuture instance using the specified properties.
         * @function create
         * @memberof st.CoinFuture
         * @static
         * @param {st.ICoinFuture=} [properties] Properties to set
         * @returns {st.CoinFuture} CoinFuture instance
         */
        CoinFuture.create = function create(properties) {
            return new CoinFuture(properties);
        };

        /**
         * Encodes the specified CoinFuture message. Does not implicitly {@link st.CoinFuture.verify|verify} messages.
         * @function encode
         * @memberof st.CoinFuture
         * @static
         * @param {st.ICoinFuture} message CoinFuture message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoinFuture.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.symbol);
            if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.currency);
            if (message.commodity != null && Object.hasOwnProperty.call(message, "commodity"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.commodity);
            if (message.contUnit != null && Object.hasOwnProperty.call(message, "contUnit"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.contUnit);
            if (message.priceSlot != null && Object.hasOwnProperty.call(message, "priceSlot"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.priceSlot);
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.platform);
            return writer;
        };

        /**
         * Encodes the specified CoinFuture message, length delimited. Does not implicitly {@link st.CoinFuture.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.CoinFuture
         * @static
         * @param {st.ICoinFuture} message CoinFuture message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoinFuture.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoinFuture message from the specified reader or buffer.
         * @function decode
         * @memberof st.CoinFuture
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.CoinFuture} CoinFuture
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoinFuture.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.CoinFuture();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.symbol = reader.string();
                    break;
                case 2:
                    message.currency = reader.string();
                    break;
                case 3:
                    message.commodity = reader.string();
                    break;
                case 4:
                    message.contUnit = reader.uint32();
                    break;
                case 5:
                    message.priceSlot = reader.string();
                    break;
                case 6:
                    message.platform = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoinFuture message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.CoinFuture
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.CoinFuture} CoinFuture
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoinFuture.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoinFuture message.
         * @function verify
         * @memberof st.CoinFuture
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoinFuture.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                if (!$util.isString(message.symbol))
                    return "symbol: string expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                if (!$util.isString(message.currency))
                    return "currency: string expected";
            if (message.commodity != null && message.hasOwnProperty("commodity"))
                if (!$util.isString(message.commodity))
                    return "commodity: string expected";
            if (message.contUnit != null && message.hasOwnProperty("contUnit"))
                if (!$util.isInteger(message.contUnit))
                    return "contUnit: integer expected";
            if (message.priceSlot != null && message.hasOwnProperty("priceSlot"))
                if (!$util.isString(message.priceSlot))
                    return "priceSlot: string expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                switch (message.platform) {
                default:
                    return "platform: enum value expected";
                case 0:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a CoinFuture message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.CoinFuture
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.CoinFuture} CoinFuture
         */
        CoinFuture.fromObject = function fromObject(object) {
            if (object instanceof $root.st.CoinFuture)
                return object;
            let message = new $root.st.CoinFuture();
            if (object.symbol != null)
                message.symbol = String(object.symbol);
            if (object.currency != null)
                message.currency = String(object.currency);
            if (object.commodity != null)
                message.commodity = String(object.commodity);
            if (object.contUnit != null)
                message.contUnit = object.contUnit >>> 0;
            if (object.priceSlot != null)
                message.priceSlot = String(object.priceSlot);
            switch (object.platform) {
            case "FAKE":
            case 0:
                message.platform = 0;
                break;
            case "HUOBI":
            case 2:
                message.platform = 2;
                break;
            case "BYBIT":
            case 3:
                message.platform = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a CoinFuture message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.CoinFuture
         * @static
         * @param {st.CoinFuture} message CoinFuture
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoinFuture.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.symbol = "";
                object.currency = "";
                object.commodity = "";
                object.contUnit = 0;
                object.priceSlot = "";
                object.platform = options.enums === String ? "FAKE" : 0;
            }
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                object.symbol = message.symbol;
            if (message.currency != null && message.hasOwnProperty("currency"))
                object.currency = message.currency;
            if (message.commodity != null && message.hasOwnProperty("commodity"))
                object.commodity = message.commodity;
            if (message.contUnit != null && message.hasOwnProperty("contUnit"))
                object.contUnit = message.contUnit;
            if (message.priceSlot != null && message.hasOwnProperty("priceSlot"))
                object.priceSlot = message.priceSlot;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = options.enums === String ? $root.st.Platform[message.platform] : message.platform;
            return object;
        };

        /**
         * Converts this CoinFuture to JSON.
         * @function toJSON
         * @memberof st.CoinFuture
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoinFuture.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CoinFuture;
    })();

    st.Trade = (function() {

        /**
         * Properties of a Trade.
         * @memberof st
         * @interface ITrade
         * @property {string|null} [orderId] Trade orderId
         * @property {string|null} [outOrderId] Trade outOrderId
         * @property {st.TradeState|null} [state] Trade state
         * @property {st.TradeDir|null} [tradeDir] Trade tradeDir
         * @property {number|null} [cont] Trade cont
         * @property {number|null} [dealCont] Trade dealCont
         * @property {st.ICoinFuture|null} [future] Trade future
         * @property {string|null} [targetPrice] Trade targetPrice
         * @property {string|null} [dealPrice] Trade dealPrice
         * @property {string|null} [fee] Trade fee
         * @property {st.Platform|null} [platform] Trade platform
         * @property {st.TradeCommandType|null} [tradeType] Trade tradeType
         * @property {number|null} [leverRate] Trade leverRate
         * @property {number|null} [createTs] Trade createTs
         * @property {string|null} [planId] Trade planId
         * @property {number|null} [updateTs] Trade updateTs
         * @property {number|null} [dataVersion] Trade dataVersion
         * @property {st.TradeTargetType|null} [targetType] Trade targetType
         * @property {st.TradeSubState|null} [subState] Trade subState
         * @property {string|null} [exeTradeReason] Trade exeTradeReason
         * @property {string|null} [delTradeReason] Trade delTradeReason
         * @property {number|null} [recvMicroWindow] Trade recvMicroWindow
         */

        /**
         * Constructs a new Trade.
         * @memberof st
         * @classdesc Represents a Trade.
         * @implements ITrade
         * @constructor
         * @param {st.ITrade=} [properties] Properties to set
         */
        function Trade(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Trade orderId.
         * @member {string} orderId
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.orderId = "";

        /**
         * Trade outOrderId.
         * @member {string} outOrderId
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.outOrderId = "";

        /**
         * Trade state.
         * @member {st.TradeState} state
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.state = 0;

        /**
         * Trade tradeDir.
         * @member {st.TradeDir} tradeDir
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.tradeDir = 0;

        /**
         * Trade cont.
         * @member {number} cont
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.cont = 0;

        /**
         * Trade dealCont.
         * @member {number} dealCont
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.dealCont = 0;

        /**
         * Trade future.
         * @member {st.ICoinFuture|null|undefined} future
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.future = null;

        /**
         * Trade targetPrice.
         * @member {string} targetPrice
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.targetPrice = "";

        /**
         * Trade dealPrice.
         * @member {string} dealPrice
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.dealPrice = "";

        /**
         * Trade fee.
         * @member {string} fee
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.fee = "";

        /**
         * Trade platform.
         * @member {st.Platform} platform
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.platform = 0;

        /**
         * Trade tradeType.
         * @member {st.TradeCommandType} tradeType
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.tradeType = 0;

        /**
         * Trade leverRate.
         * @member {number} leverRate
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.leverRate = 0;

        /**
         * Trade createTs.
         * @member {number} createTs
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.createTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Trade planId.
         * @member {string} planId
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.planId = "";

        /**
         * Trade updateTs.
         * @member {number} updateTs
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.updateTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Trade dataVersion.
         * @member {number} dataVersion
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.dataVersion = 0;

        /**
         * Trade targetType.
         * @member {st.TradeTargetType} targetType
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.targetType = 0;

        /**
         * Trade subState.
         * @member {st.TradeSubState} subState
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.subState = 0;

        /**
         * Trade exeTradeReason.
         * @member {string} exeTradeReason
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.exeTradeReason = "";

        /**
         * Trade delTradeReason.
         * @member {string} delTradeReason
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.delTradeReason = "";

        /**
         * Trade recvMicroWindow.
         * @member {number} recvMicroWindow
         * @memberof st.Trade
         * @instance
         */
        Trade.prototype.recvMicroWindow = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Trade instance using the specified properties.
         * @function create
         * @memberof st.Trade
         * @static
         * @param {st.ITrade=} [properties] Properties to set
         * @returns {st.Trade} Trade instance
         */
        Trade.create = function create(properties) {
            return new Trade(properties);
        };

        /**
         * Encodes the specified Trade message. Does not implicitly {@link st.Trade.verify|verify} messages.
         * @function encode
         * @memberof st.Trade
         * @static
         * @param {st.ITrade} message Trade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Trade.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.orderId != null && Object.hasOwnProperty.call(message, "orderId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderId);
            if (message.outOrderId != null && Object.hasOwnProperty.call(message, "outOrderId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.outOrderId);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.state);
            if (message.tradeDir != null && Object.hasOwnProperty.call(message, "tradeDir"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.tradeDir);
            if (message.cont != null && Object.hasOwnProperty.call(message, "cont"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.cont);
            if (message.dealCont != null && Object.hasOwnProperty.call(message, "dealCont"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.dealCont);
            if (message.future != null && Object.hasOwnProperty.call(message, "future"))
                $root.st.CoinFuture.encode(message.future, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.targetPrice != null && Object.hasOwnProperty.call(message, "targetPrice"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.targetPrice);
            if (message.dealPrice != null && Object.hasOwnProperty.call(message, "dealPrice"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.dealPrice);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.fee);
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.platform);
            if (message.tradeType != null && Object.hasOwnProperty.call(message, "tradeType"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.tradeType);
            if (message.leverRate != null && Object.hasOwnProperty.call(message, "leverRate"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.leverRate);
            if (message.createTs != null && Object.hasOwnProperty.call(message, "createTs"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.createTs);
            if (message.planId != null && Object.hasOwnProperty.call(message, "planId"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.planId);
            if (message.updateTs != null && Object.hasOwnProperty.call(message, "updateTs"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.updateTs);
            if (message.dataVersion != null && Object.hasOwnProperty.call(message, "dataVersion"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.dataVersion);
            if (message.targetType != null && Object.hasOwnProperty.call(message, "targetType"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.targetType);
            if (message.subState != null && Object.hasOwnProperty.call(message, "subState"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.subState);
            if (message.exeTradeReason != null && Object.hasOwnProperty.call(message, "exeTradeReason"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.exeTradeReason);
            if (message.delTradeReason != null && Object.hasOwnProperty.call(message, "delTradeReason"))
                writer.uint32(/* id 21, wireType 2 =*/170).string(message.delTradeReason);
            if (message.recvMicroWindow != null && Object.hasOwnProperty.call(message, "recvMicroWindow"))
                writer.uint32(/* id 22, wireType 0 =*/176).uint64(message.recvMicroWindow);
            return writer;
        };

        /**
         * Encodes the specified Trade message, length delimited. Does not implicitly {@link st.Trade.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.Trade
         * @static
         * @param {st.ITrade} message Trade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Trade.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Trade message from the specified reader or buffer.
         * @function decode
         * @memberof st.Trade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.Trade} Trade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Trade.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.Trade();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.orderId = reader.string();
                    break;
                case 2:
                    message.outOrderId = reader.string();
                    break;
                case 3:
                    message.state = reader.int32();
                    break;
                case 4:
                    message.tradeDir = reader.int32();
                    break;
                case 5:
                    message.cont = reader.uint32();
                    break;
                case 6:
                    message.dealCont = reader.uint32();
                    break;
                case 7:
                    message.future = $root.st.CoinFuture.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.targetPrice = reader.string();
                    break;
                case 9:
                    message.dealPrice = reader.string();
                    break;
                case 10:
                    message.fee = reader.string();
                    break;
                case 11:
                    message.platform = reader.int32();
                    break;
                case 12:
                    message.tradeType = reader.int32();
                    break;
                case 13:
                    message.leverRate = reader.int32();
                    break;
                case 14:
                    message.createTs = reader.uint64();
                    break;
                case 15:
                    message.planId = reader.string();
                    break;
                case 16:
                    message.updateTs = reader.uint64();
                    break;
                case 17:
                    message.dataVersion = reader.uint32();
                    break;
                case 18:
                    message.targetType = reader.int32();
                    break;
                case 19:
                    message.subState = reader.int32();
                    break;
                case 20:
                    message.exeTradeReason = reader.string();
                    break;
                case 21:
                    message.delTradeReason = reader.string();
                    break;
                case 22:
                    message.recvMicroWindow = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Trade message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.Trade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.Trade} Trade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Trade.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Trade message.
         * @function verify
         * @memberof st.Trade
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Trade.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                if (!$util.isString(message.orderId))
                    return "orderId: string expected";
            if (message.outOrderId != null && message.hasOwnProperty("outOrderId"))
                if (!$util.isString(message.outOrderId))
                    return "outOrderId: string expected";
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.tradeDir != null && message.hasOwnProperty("tradeDir"))
                switch (message.tradeDir) {
                default:
                    return "tradeDir: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.cont != null && message.hasOwnProperty("cont"))
                if (!$util.isInteger(message.cont))
                    return "cont: integer expected";
            if (message.dealCont != null && message.hasOwnProperty("dealCont"))
                if (!$util.isInteger(message.dealCont))
                    return "dealCont: integer expected";
            if (message.future != null && message.hasOwnProperty("future")) {
                let error = $root.st.CoinFuture.verify(message.future);
                if (error)
                    return "future." + error;
            }
            if (message.targetPrice != null && message.hasOwnProperty("targetPrice"))
                if (!$util.isString(message.targetPrice))
                    return "targetPrice: string expected";
            if (message.dealPrice != null && message.hasOwnProperty("dealPrice"))
                if (!$util.isString(message.dealPrice))
                    return "dealPrice: string expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isString(message.fee))
                    return "fee: string expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                switch (message.platform) {
                default:
                    return "platform: enum value expected";
                case 0:
                case 2:
                case 3:
                    break;
                }
            if (message.tradeType != null && message.hasOwnProperty("tradeType"))
                switch (message.tradeType) {
                default:
                    return "tradeType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.leverRate != null && message.hasOwnProperty("leverRate"))
                if (!$util.isInteger(message.leverRate))
                    return "leverRate: integer expected";
            if (message.createTs != null && message.hasOwnProperty("createTs"))
                if (!$util.isInteger(message.createTs) && !(message.createTs && $util.isInteger(message.createTs.low) && $util.isInteger(message.createTs.high)))
                    return "createTs: integer|Long expected";
            if (message.planId != null && message.hasOwnProperty("planId"))
                if (!$util.isString(message.planId))
                    return "planId: string expected";
            if (message.updateTs != null && message.hasOwnProperty("updateTs"))
                if (!$util.isInteger(message.updateTs) && !(message.updateTs && $util.isInteger(message.updateTs.low) && $util.isInteger(message.updateTs.high)))
                    return "updateTs: integer|Long expected";
            if (message.dataVersion != null && message.hasOwnProperty("dataVersion"))
                if (!$util.isInteger(message.dataVersion))
                    return "dataVersion: integer expected";
            if (message.targetType != null && message.hasOwnProperty("targetType"))
                switch (message.targetType) {
                default:
                    return "targetType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.subState != null && message.hasOwnProperty("subState"))
                switch (message.subState) {
                default:
                    return "subState: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    break;
                }
            if (message.exeTradeReason != null && message.hasOwnProperty("exeTradeReason"))
                if (!$util.isString(message.exeTradeReason))
                    return "exeTradeReason: string expected";
            if (message.delTradeReason != null && message.hasOwnProperty("delTradeReason"))
                if (!$util.isString(message.delTradeReason))
                    return "delTradeReason: string expected";
            if (message.recvMicroWindow != null && message.hasOwnProperty("recvMicroWindow"))
                if (!$util.isInteger(message.recvMicroWindow) && !(message.recvMicroWindow && $util.isInteger(message.recvMicroWindow.low) && $util.isInteger(message.recvMicroWindow.high)))
                    return "recvMicroWindow: integer|Long expected";
            return null;
        };

        /**
         * Creates a Trade message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.Trade
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.Trade} Trade
         */
        Trade.fromObject = function fromObject(object) {
            if (object instanceof $root.st.Trade)
                return object;
            let message = new $root.st.Trade();
            if (object.orderId != null)
                message.orderId = String(object.orderId);
            if (object.outOrderId != null)
                message.outOrderId = String(object.outOrderId);
            switch (object.state) {
            case "DEFAULT_TRADE_STATE":
            case 0:
                message.state = 0;
                break;
            case "TRADE_UNSUBMIT":
            case 1:
                message.state = 1;
                break;
            case "TRADE_SUBMITTED":
            case 2:
                message.state = 2;
                break;
            case "TRADE_EXECUTING":
            case 3:
                message.state = 3;
                break;
            case "TRADE_FINISHED":
            case 4:
                message.state = 4;
                break;
            case "TRADE_CLOSING":
            case 5:
                message.state = 5;
                break;
            }
            switch (object.tradeDir) {
            case "DEFAULT_TRADE_DIR":
            case 0:
                message.tradeDir = 0;
                break;
            case "BID":
            case 1:
                message.tradeDir = 1;
                break;
            case "ASK":
            case 2:
                message.tradeDir = 2;
                break;
            }
            if (object.cont != null)
                message.cont = object.cont >>> 0;
            if (object.dealCont != null)
                message.dealCont = object.dealCont >>> 0;
            if (object.future != null) {
                if (typeof object.future !== "object")
                    throw TypeError(".st.Trade.future: object expected");
                message.future = $root.st.CoinFuture.fromObject(object.future);
            }
            if (object.targetPrice != null)
                message.targetPrice = String(object.targetPrice);
            if (object.dealPrice != null)
                message.dealPrice = String(object.dealPrice);
            if (object.fee != null)
                message.fee = String(object.fee);
            switch (object.platform) {
            case "FAKE":
            case 0:
                message.platform = 0;
                break;
            case "HUOBI":
            case 2:
                message.platform = 2;
                break;
            case "BYBIT":
            case 3:
                message.platform = 3;
                break;
            }
            switch (object.tradeType) {
            case "DEFAULT_COMMAND_TYPE":
            case 0:
                message.tradeType = 0;
                break;
            case "LIMIT_MAKER":
            case 1:
                message.tradeType = 1;
                break;
            case "FOK_TAKER":
            case 2:
                message.tradeType = 2;
                break;
            }
            if (object.leverRate != null)
                message.leverRate = object.leverRate | 0;
            if (object.createTs != null)
                if ($util.Long)
                    (message.createTs = $util.Long.fromValue(object.createTs)).unsigned = true;
                else if (typeof object.createTs === "string")
                    message.createTs = parseInt(object.createTs, 10);
                else if (typeof object.createTs === "number")
                    message.createTs = object.createTs;
                else if (typeof object.createTs === "object")
                    message.createTs = new $util.LongBits(object.createTs.low >>> 0, object.createTs.high >>> 0).toNumber(true);
            if (object.planId != null)
                message.planId = String(object.planId);
            if (object.updateTs != null)
                if ($util.Long)
                    (message.updateTs = $util.Long.fromValue(object.updateTs)).unsigned = true;
                else if (typeof object.updateTs === "string")
                    message.updateTs = parseInt(object.updateTs, 10);
                else if (typeof object.updateTs === "number")
                    message.updateTs = object.updateTs;
                else if (typeof object.updateTs === "object")
                    message.updateTs = new $util.LongBits(object.updateTs.low >>> 0, object.updateTs.high >>> 0).toNumber(true);
            if (object.dataVersion != null)
                message.dataVersion = object.dataVersion >>> 0;
            switch (object.targetType) {
            case "DEFAULT_TARGET_TYPE":
            case 0:
                message.targetType = 0;
                break;
            case "OPEN":
            case 1:
                message.targetType = 1;
                break;
            case "CLOSE":
            case 2:
                message.targetType = 2;
                break;
            }
            switch (object.subState) {
            case "DEFAULT_TRADE_SUB_STATE":
            case 0:
                message.subState = 0;
                break;
            case "TRADE_SUB_UNSUBMIT":
            case 1:
                message.subState = 1;
                break;
            case "TRADE_SUB_SUBMITTED":
            case 2:
                message.subState = 2;
                break;
            case "TRADE_SUB_PARTIAL_FILLED":
            case 3:
                message.subState = 3;
                break;
            case "TRADE_SUB_FULL_FILLED":
            case 4:
                message.subState = 4;
                break;
            case "TRADE_SUB_CANCELING":
            case 5:
                message.subState = 5;
                break;
            case "TRADE_SUB_CANCELED":
            case 6:
                message.subState = 6;
                break;
            case "TRADE_SUB_REJECTED":
            case 7:
                message.subState = 7;
                break;
            case "TRADE_SUB_EXECUTING":
            case 8:
                message.subState = 8;
                break;
            case "TRADE_TIMEOUT_CLOSED":
            case 9:
                message.subState = 9;
                break;
            }
            if (object.exeTradeReason != null)
                message.exeTradeReason = String(object.exeTradeReason);
            if (object.delTradeReason != null)
                message.delTradeReason = String(object.delTradeReason);
            if (object.recvMicroWindow != null)
                if ($util.Long)
                    (message.recvMicroWindow = $util.Long.fromValue(object.recvMicroWindow)).unsigned = true;
                else if (typeof object.recvMicroWindow === "string")
                    message.recvMicroWindow = parseInt(object.recvMicroWindow, 10);
                else if (typeof object.recvMicroWindow === "number")
                    message.recvMicroWindow = object.recvMicroWindow;
                else if (typeof object.recvMicroWindow === "object")
                    message.recvMicroWindow = new $util.LongBits(object.recvMicroWindow.low >>> 0, object.recvMicroWindow.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a Trade message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.Trade
         * @static
         * @param {st.Trade} message Trade
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Trade.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.orderId = "";
                object.outOrderId = "";
                object.state = options.enums === String ? "DEFAULT_TRADE_STATE" : 0;
                object.tradeDir = options.enums === String ? "DEFAULT_TRADE_DIR" : 0;
                object.cont = 0;
                object.dealCont = 0;
                object.future = null;
                object.targetPrice = "";
                object.dealPrice = "";
                object.fee = "";
                object.platform = options.enums === String ? "FAKE" : 0;
                object.tradeType = options.enums === String ? "DEFAULT_COMMAND_TYPE" : 0;
                object.leverRate = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.createTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createTs = options.longs === String ? "0" : 0;
                object.planId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.updateTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.updateTs = options.longs === String ? "0" : 0;
                object.dataVersion = 0;
                object.targetType = options.enums === String ? "DEFAULT_TARGET_TYPE" : 0;
                object.subState = options.enums === String ? "DEFAULT_TRADE_SUB_STATE" : 0;
                object.exeTradeReason = "";
                object.delTradeReason = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.recvMicroWindow = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.recvMicroWindow = options.longs === String ? "0" : 0;
            }
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                object.orderId = message.orderId;
            if (message.outOrderId != null && message.hasOwnProperty("outOrderId"))
                object.outOrderId = message.outOrderId;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.st.TradeState[message.state] : message.state;
            if (message.tradeDir != null && message.hasOwnProperty("tradeDir"))
                object.tradeDir = options.enums === String ? $root.st.TradeDir[message.tradeDir] : message.tradeDir;
            if (message.cont != null && message.hasOwnProperty("cont"))
                object.cont = message.cont;
            if (message.dealCont != null && message.hasOwnProperty("dealCont"))
                object.dealCont = message.dealCont;
            if (message.future != null && message.hasOwnProperty("future"))
                object.future = $root.st.CoinFuture.toObject(message.future, options);
            if (message.targetPrice != null && message.hasOwnProperty("targetPrice"))
                object.targetPrice = message.targetPrice;
            if (message.dealPrice != null && message.hasOwnProperty("dealPrice"))
                object.dealPrice = message.dealPrice;
            if (message.fee != null && message.hasOwnProperty("fee"))
                object.fee = message.fee;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = options.enums === String ? $root.st.Platform[message.platform] : message.platform;
            if (message.tradeType != null && message.hasOwnProperty("tradeType"))
                object.tradeType = options.enums === String ? $root.st.TradeCommandType[message.tradeType] : message.tradeType;
            if (message.leverRate != null && message.hasOwnProperty("leverRate"))
                object.leverRate = message.leverRate;
            if (message.createTs != null && message.hasOwnProperty("createTs"))
                if (typeof message.createTs === "number")
                    object.createTs = options.longs === String ? String(message.createTs) : message.createTs;
                else
                    object.createTs = options.longs === String ? $util.Long.prototype.toString.call(message.createTs) : options.longs === Number ? new $util.LongBits(message.createTs.low >>> 0, message.createTs.high >>> 0).toNumber(true) : message.createTs;
            if (message.planId != null && message.hasOwnProperty("planId"))
                object.planId = message.planId;
            if (message.updateTs != null && message.hasOwnProperty("updateTs"))
                if (typeof message.updateTs === "number")
                    object.updateTs = options.longs === String ? String(message.updateTs) : message.updateTs;
                else
                    object.updateTs = options.longs === String ? $util.Long.prototype.toString.call(message.updateTs) : options.longs === Number ? new $util.LongBits(message.updateTs.low >>> 0, message.updateTs.high >>> 0).toNumber(true) : message.updateTs;
            if (message.dataVersion != null && message.hasOwnProperty("dataVersion"))
                object.dataVersion = message.dataVersion;
            if (message.targetType != null && message.hasOwnProperty("targetType"))
                object.targetType = options.enums === String ? $root.st.TradeTargetType[message.targetType] : message.targetType;
            if (message.subState != null && message.hasOwnProperty("subState"))
                object.subState = options.enums === String ? $root.st.TradeSubState[message.subState] : message.subState;
            if (message.exeTradeReason != null && message.hasOwnProperty("exeTradeReason"))
                object.exeTradeReason = message.exeTradeReason;
            if (message.delTradeReason != null && message.hasOwnProperty("delTradeReason"))
                object.delTradeReason = message.delTradeReason;
            if (message.recvMicroWindow != null && message.hasOwnProperty("recvMicroWindow"))
                if (typeof message.recvMicroWindow === "number")
                    object.recvMicroWindow = options.longs === String ? String(message.recvMicroWindow) : message.recvMicroWindow;
                else
                    object.recvMicroWindow = options.longs === String ? $util.Long.prototype.toString.call(message.recvMicroWindow) : options.longs === Number ? new $util.LongBits(message.recvMicroWindow.low >>> 0, message.recvMicroWindow.high >>> 0).toNumber(true) : message.recvMicroWindow;
            return object;
        };

        /**
         * Converts this Trade to JSON.
         * @function toJSON
         * @memberof st.Trade
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Trade.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Trade;
    })();

    /**
     * PositionModifyType enum.
     * @name st.PositionModifyType
     * @enum {number}
     * @property {number} DEFAULT_POSITION_MODIFY_TYPE=0 DEFAULT_POSITION_MODIFY_TYPE value
     * @property {number} INC_POSITION=1 INC_POSITION value
     * @property {number} DEC_POSITION=2 DEC_POSITION value
     * @property {number} CLEAR_POSITION=3 CLEAR_POSITION value
     */
    st.PositionModifyType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_POSITION_MODIFY_TYPE"] = 0;
        values[valuesById[1] = "INC_POSITION"] = 1;
        values[valuesById[2] = "DEC_POSITION"] = 2;
        values[valuesById[3] = "CLEAR_POSITION"] = 3;
        return values;
    })();

    /**
     * PositionSignalPriority enum.
     * @name st.PositionSignalPriority
     * @enum {number}
     * @property {number} DEFAULT_PRIORITY=0 DEFAULT_PRIORITY value
     * @property {number} ONE_PRIORITY=1 ONE_PRIORITY value
     * @property {number} TWO_PRIORITY=2 TWO_PRIORITY value
     */
    st.PositionSignalPriority = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_PRIORITY"] = 0;
        values[valuesById[1] = "ONE_PRIORITY"] = 1;
        values[valuesById[2] = "TWO_PRIORITY"] = 2;
        return values;
    })();

    /**
     * PositionModifySignalState enum.
     * @name st.PositionModifySignalState
     * @enum {number}
     * @property {number} DEFAULT_SIGNAL_STATE=0 DEFAULT_SIGNAL_STATE value
     * @property {number} SIGNAL_PREPARE=1 SIGNAL_PREPARE value
     * @property {number} SIGNAL_EXECUTING=2 SIGNAL_EXECUTING value
     * @property {number} SIGNAL_FINISH=3 SIGNAL_FINISH value
     */
    st.PositionModifySignalState = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_SIGNAL_STATE"] = 0;
        values[valuesById[1] = "SIGNAL_PREPARE"] = 1;
        values[valuesById[2] = "SIGNAL_EXECUTING"] = 2;
        values[valuesById[3] = "SIGNAL_FINISH"] = 3;
        return values;
    })();

    st.PositionModifySignal = (function() {

        /**
         * Properties of a PositionModifySignal.
         * @memberof st
         * @interface IPositionModifySignal
         * @property {string|null} [signalId] PositionModifySignal signalId
         * @property {number|null} [type] PositionModifySignal type
         * @property {number|null} [priority] PositionModifySignal priority
         * @property {number|null} [signalTs] PositionModifySignal signalTs
         * @property {string|null} [reason] PositionModifySignal reason
         * @property {number|null} [targetPositionCont] PositionModifySignal targetPositionCont
         * @property {string|null} [modifyTradeId] PositionModifySignal modifyTradeId
         * @property {number|null} [state] PositionModifySignal state
         */

        /**
         * Constructs a new PositionModifySignal.
         * @memberof st
         * @classdesc Represents a PositionModifySignal.
         * @implements IPositionModifySignal
         * @constructor
         * @param {st.IPositionModifySignal=} [properties] Properties to set
         */
        function PositionModifySignal(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PositionModifySignal signalId.
         * @member {string} signalId
         * @memberof st.PositionModifySignal
         * @instance
         */
        PositionModifySignal.prototype.signalId = "";

        /**
         * PositionModifySignal type.
         * @member {number} type
         * @memberof st.PositionModifySignal
         * @instance
         */
        PositionModifySignal.prototype.type = 0;

        /**
         * PositionModifySignal priority.
         * @member {number} priority
         * @memberof st.PositionModifySignal
         * @instance
         */
        PositionModifySignal.prototype.priority = 0;

        /**
         * PositionModifySignal signalTs.
         * @member {number} signalTs
         * @memberof st.PositionModifySignal
         * @instance
         */
        PositionModifySignal.prototype.signalTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PositionModifySignal reason.
         * @member {string} reason
         * @memberof st.PositionModifySignal
         * @instance
         */
        PositionModifySignal.prototype.reason = "";

        /**
         * PositionModifySignal targetPositionCont.
         * @member {number} targetPositionCont
         * @memberof st.PositionModifySignal
         * @instance
         */
        PositionModifySignal.prototype.targetPositionCont = 0;

        /**
         * PositionModifySignal modifyTradeId.
         * @member {string} modifyTradeId
         * @memberof st.PositionModifySignal
         * @instance
         */
        PositionModifySignal.prototype.modifyTradeId = "";

        /**
         * PositionModifySignal state.
         * @member {number} state
         * @memberof st.PositionModifySignal
         * @instance
         */
        PositionModifySignal.prototype.state = 0;

        /**
         * Creates a new PositionModifySignal instance using the specified properties.
         * @function create
         * @memberof st.PositionModifySignal
         * @static
         * @param {st.IPositionModifySignal=} [properties] Properties to set
         * @returns {st.PositionModifySignal} PositionModifySignal instance
         */
        PositionModifySignal.create = function create(properties) {
            return new PositionModifySignal(properties);
        };

        /**
         * Encodes the specified PositionModifySignal message. Does not implicitly {@link st.PositionModifySignal.verify|verify} messages.
         * @function encode
         * @memberof st.PositionModifySignal
         * @static
         * @param {st.IPositionModifySignal} message PositionModifySignal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionModifySignal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signalId != null && Object.hasOwnProperty.call(message, "signalId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.signalId);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.priority);
            if (message.signalTs != null && Object.hasOwnProperty.call(message, "signalTs"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.signalTs);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.reason);
            if (message.targetPositionCont != null && Object.hasOwnProperty.call(message, "targetPositionCont"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.targetPositionCont);
            if (message.modifyTradeId != null && Object.hasOwnProperty.call(message, "modifyTradeId"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.modifyTradeId);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.state);
            return writer;
        };

        /**
         * Encodes the specified PositionModifySignal message, length delimited. Does not implicitly {@link st.PositionModifySignal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.PositionModifySignal
         * @static
         * @param {st.IPositionModifySignal} message PositionModifySignal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionModifySignal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PositionModifySignal message from the specified reader or buffer.
         * @function decode
         * @memberof st.PositionModifySignal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.PositionModifySignal} PositionModifySignal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionModifySignal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.PositionModifySignal();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signalId = reader.string();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.priority = reader.uint32();
                    break;
                case 4:
                    message.signalTs = reader.uint64();
                    break;
                case 5:
                    message.reason = reader.string();
                    break;
                case 6:
                    message.targetPositionCont = reader.uint32();
                    break;
                case 7:
                    message.modifyTradeId = reader.string();
                    break;
                case 8:
                    message.state = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PositionModifySignal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.PositionModifySignal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.PositionModifySignal} PositionModifySignal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionModifySignal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PositionModifySignal message.
         * @function verify
         * @memberof st.PositionModifySignal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PositionModifySignal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signalId != null && message.hasOwnProperty("signalId"))
                if (!$util.isString(message.signalId))
                    return "signalId: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.priority != null && message.hasOwnProperty("priority"))
                if (!$util.isInteger(message.priority))
                    return "priority: integer expected";
            if (message.signalTs != null && message.hasOwnProperty("signalTs"))
                if (!$util.isInteger(message.signalTs) && !(message.signalTs && $util.isInteger(message.signalTs.low) && $util.isInteger(message.signalTs.high)))
                    return "signalTs: integer|Long expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            if (message.targetPositionCont != null && message.hasOwnProperty("targetPositionCont"))
                if (!$util.isInteger(message.targetPositionCont))
                    return "targetPositionCont: integer expected";
            if (message.modifyTradeId != null && message.hasOwnProperty("modifyTradeId"))
                if (!$util.isString(message.modifyTradeId))
                    return "modifyTradeId: string expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            return null;
        };

        /**
         * Creates a PositionModifySignal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.PositionModifySignal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.PositionModifySignal} PositionModifySignal
         */
        PositionModifySignal.fromObject = function fromObject(object) {
            if (object instanceof $root.st.PositionModifySignal)
                return object;
            let message = new $root.st.PositionModifySignal();
            if (object.signalId != null)
                message.signalId = String(object.signalId);
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.priority != null)
                message.priority = object.priority >>> 0;
            if (object.signalTs != null)
                if ($util.Long)
                    (message.signalTs = $util.Long.fromValue(object.signalTs)).unsigned = true;
                else if (typeof object.signalTs === "string")
                    message.signalTs = parseInt(object.signalTs, 10);
                else if (typeof object.signalTs === "number")
                    message.signalTs = object.signalTs;
                else if (typeof object.signalTs === "object")
                    message.signalTs = new $util.LongBits(object.signalTs.low >>> 0, object.signalTs.high >>> 0).toNumber(true);
            if (object.reason != null)
                message.reason = String(object.reason);
            if (object.targetPositionCont != null)
                message.targetPositionCont = object.targetPositionCont >>> 0;
            if (object.modifyTradeId != null)
                message.modifyTradeId = String(object.modifyTradeId);
            if (object.state != null)
                message.state = object.state >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PositionModifySignal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.PositionModifySignal
         * @static
         * @param {st.PositionModifySignal} message PositionModifySignal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PositionModifySignal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.signalId = "";
                object.type = 0;
                object.priority = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.signalTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.signalTs = options.longs === String ? "0" : 0;
                object.reason = "";
                object.targetPositionCont = 0;
                object.modifyTradeId = "";
                object.state = 0;
            }
            if (message.signalId != null && message.hasOwnProperty("signalId"))
                object.signalId = message.signalId;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.priority != null && message.hasOwnProperty("priority"))
                object.priority = message.priority;
            if (message.signalTs != null && message.hasOwnProperty("signalTs"))
                if (typeof message.signalTs === "number")
                    object.signalTs = options.longs === String ? String(message.signalTs) : message.signalTs;
                else
                    object.signalTs = options.longs === String ? $util.Long.prototype.toString.call(message.signalTs) : options.longs === Number ? new $util.LongBits(message.signalTs.low >>> 0, message.signalTs.high >>> 0).toNumber(true) : message.signalTs;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.targetPositionCont != null && message.hasOwnProperty("targetPositionCont"))
                object.targetPositionCont = message.targetPositionCont;
            if (message.modifyTradeId != null && message.hasOwnProperty("modifyTradeId"))
                object.modifyTradeId = message.modifyTradeId;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            return object;
        };

        /**
         * Converts this PositionModifySignal to JSON.
         * @function toJSON
         * @memberof st.PositionModifySignal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PositionModifySignal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PositionModifySignal;
    })();

    /**
     * CommandType enum.
     * @name st.CommandType
     * @enum {number}
     * @property {number} DEFAULT=0 DEFAULT value
     * @property {number} QUERY=1 QUERY value
     * @property {number} CANCEL=2 CANCEL value
     * @property {number} PLACE=3 PLACE value
     * @property {number} QUERY_KLINE=4 QUERY_KLINE value
     */
    st.CommandType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT"] = 0;
        values[valuesById[1] = "QUERY"] = 1;
        values[valuesById[2] = "CANCEL"] = 2;
        values[valuesById[3] = "PLACE"] = 3;
        values[valuesById[4] = "QUERY_KLINE"] = 4;
        return values;
    })();

    st.CommandReq = (function() {

        /**
         * Properties of a CommandReq.
         * @memberof st
         * @interface ICommandReq
         * @property {string|null} [identity] CommandReq identity
         * @property {google.protobuf.IAny|null} [request] CommandReq request
         */

        /**
         * Constructs a new CommandReq.
         * @memberof st
         * @classdesc Represents a CommandReq.
         * @implements ICommandReq
         * @constructor
         * @param {st.ICommandReq=} [properties] Properties to set
         */
        function CommandReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommandReq identity.
         * @member {string} identity
         * @memberof st.CommandReq
         * @instance
         */
        CommandReq.prototype.identity = "";

        /**
         * CommandReq request.
         * @member {google.protobuf.IAny|null|undefined} request
         * @memberof st.CommandReq
         * @instance
         */
        CommandReq.prototype.request = null;

        /**
         * Creates a new CommandReq instance using the specified properties.
         * @function create
         * @memberof st.CommandReq
         * @static
         * @param {st.ICommandReq=} [properties] Properties to set
         * @returns {st.CommandReq} CommandReq instance
         */
        CommandReq.create = function create(properties) {
            return new CommandReq(properties);
        };

        /**
         * Encodes the specified CommandReq message. Does not implicitly {@link st.CommandReq.verify|verify} messages.
         * @function encode
         * @memberof st.CommandReq
         * @static
         * @param {st.ICommandReq} message CommandReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identity != null && Object.hasOwnProperty.call(message, "identity"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.identity);
            if (message.request != null && Object.hasOwnProperty.call(message, "request"))
                $root.google.protobuf.Any.encode(message.request, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CommandReq message, length delimited. Does not implicitly {@link st.CommandReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.CommandReq
         * @static
         * @param {st.ICommandReq} message CommandReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommandReq message from the specified reader or buffer.
         * @function decode
         * @memberof st.CommandReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.CommandReq} CommandReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.CommandReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identity = reader.string();
                    break;
                case 2:
                    message.request = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommandReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.CommandReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.CommandReq} CommandReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommandReq message.
         * @function verify
         * @memberof st.CommandReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommandReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identity != null && message.hasOwnProperty("identity"))
                if (!$util.isString(message.identity))
                    return "identity: string expected";
            if (message.request != null && message.hasOwnProperty("request")) {
                let error = $root.google.protobuf.Any.verify(message.request);
                if (error)
                    return "request." + error;
            }
            return null;
        };

        /**
         * Creates a CommandReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.CommandReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.CommandReq} CommandReq
         */
        CommandReq.fromObject = function fromObject(object) {
            if (object instanceof $root.st.CommandReq)
                return object;
            let message = new $root.st.CommandReq();
            if (object.identity != null)
                message.identity = String(object.identity);
            if (object.request != null) {
                if (typeof object.request !== "object")
                    throw TypeError(".st.CommandReq.request: object expected");
                message.request = $root.google.protobuf.Any.fromObject(object.request);
            }
            return message;
        };

        /**
         * Creates a plain object from a CommandReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.CommandReq
         * @static
         * @param {st.CommandReq} message CommandReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommandReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.identity = "";
                object.request = null;
            }
            if (message.identity != null && message.hasOwnProperty("identity"))
                object.identity = message.identity;
            if (message.request != null && message.hasOwnProperty("request"))
                object.request = $root.google.protobuf.Any.toObject(message.request, options);
            return object;
        };

        /**
         * Converts this CommandReq to JSON.
         * @function toJSON
         * @memberof st.CommandReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommandReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommandReq;
    })();

    st.CommandResp = (function() {

        /**
         * Properties of a CommandResp.
         * @memberof st
         * @interface ICommandResp
         * @property {google.protobuf.IAny|null} [result] CommandResp result
         * @property {string|null} [errorMessage] CommandResp errorMessage
         */

        /**
         * Constructs a new CommandResp.
         * @memberof st
         * @classdesc Represents a CommandResp.
         * @implements ICommandResp
         * @constructor
         * @param {st.ICommandResp=} [properties] Properties to set
         */
        function CommandResp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommandResp result.
         * @member {google.protobuf.IAny|null|undefined} result
         * @memberof st.CommandResp
         * @instance
         */
        CommandResp.prototype.result = null;

        /**
         * CommandResp errorMessage.
         * @member {string} errorMessage
         * @memberof st.CommandResp
         * @instance
         */
        CommandResp.prototype.errorMessage = "";

        /**
         * Creates a new CommandResp instance using the specified properties.
         * @function create
         * @memberof st.CommandResp
         * @static
         * @param {st.ICommandResp=} [properties] Properties to set
         * @returns {st.CommandResp} CommandResp instance
         */
        CommandResp.create = function create(properties) {
            return new CommandResp(properties);
        };

        /**
         * Encodes the specified CommandResp message. Does not implicitly {@link st.CommandResp.verify|verify} messages.
         * @function encode
         * @memberof st.CommandResp
         * @static
         * @param {st.ICommandResp} message CommandResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                $root.google.protobuf.Any.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                writer.uint32(/* id 100, wireType 2 =*/802).string(message.errorMessage);
            return writer;
        };

        /**
         * Encodes the specified CommandResp message, length delimited. Does not implicitly {@link st.CommandResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.CommandResp
         * @static
         * @param {st.ICommandResp} message CommandResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommandResp message from the specified reader or buffer.
         * @function decode
         * @memberof st.CommandResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.CommandResp} CommandResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.CommandResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.errorMessage = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommandResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.CommandResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.CommandResp} CommandResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommandResp message.
         * @function verify
         * @memberof st.CommandResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommandResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result")) {
                let error = $root.google.protobuf.Any.verify(message.result);
                if (error)
                    return "result." + error;
            }
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                if (!$util.isString(message.errorMessage))
                    return "errorMessage: string expected";
            return null;
        };

        /**
         * Creates a CommandResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.CommandResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.CommandResp} CommandResp
         */
        CommandResp.fromObject = function fromObject(object) {
            if (object instanceof $root.st.CommandResp)
                return object;
            let message = new $root.st.CommandResp();
            if (object.result != null) {
                if (typeof object.result !== "object")
                    throw TypeError(".st.CommandResp.result: object expected");
                message.result = $root.google.protobuf.Any.fromObject(object.result);
            }
            if (object.errorMessage != null)
                message.errorMessage = String(object.errorMessage);
            return message;
        };

        /**
         * Creates a plain object from a CommandResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.CommandResp
         * @static
         * @param {st.CommandResp} message CommandResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommandResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.result = null;
                object.errorMessage = "";
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = $root.google.protobuf.Any.toObject(message.result, options);
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                object.errorMessage = message.errorMessage;
            return object;
        };

        /**
         * Converts this CommandResp to JSON.
         * @function toJSON
         * @memberof st.CommandResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommandResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CommandResp;
    })();

    st.TradeCommandReq = (function() {

        /**
         * Properties of a TradeCommandReq.
         * @memberof st
         * @interface ITradeCommandReq
         * @property {st.CommandType|null} [type] TradeCommandReq type
         * @property {st.ITrade|null} [trade] TradeCommandReq trade
         */

        /**
         * Constructs a new TradeCommandReq.
         * @memberof st
         * @classdesc Represents a TradeCommandReq.
         * @implements ITradeCommandReq
         * @constructor
         * @param {st.ITradeCommandReq=} [properties] Properties to set
         */
        function TradeCommandReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeCommandReq type.
         * @member {st.CommandType} type
         * @memberof st.TradeCommandReq
         * @instance
         */
        TradeCommandReq.prototype.type = 0;

        /**
         * TradeCommandReq trade.
         * @member {st.ITrade|null|undefined} trade
         * @memberof st.TradeCommandReq
         * @instance
         */
        TradeCommandReq.prototype.trade = null;

        /**
         * Creates a new TradeCommandReq instance using the specified properties.
         * @function create
         * @memberof st.TradeCommandReq
         * @static
         * @param {st.ITradeCommandReq=} [properties] Properties to set
         * @returns {st.TradeCommandReq} TradeCommandReq instance
         */
        TradeCommandReq.create = function create(properties) {
            return new TradeCommandReq(properties);
        };

        /**
         * Encodes the specified TradeCommandReq message. Does not implicitly {@link st.TradeCommandReq.verify|verify} messages.
         * @function encode
         * @memberof st.TradeCommandReq
         * @static
         * @param {st.ITradeCommandReq} message TradeCommandReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeCommandReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.trade != null && Object.hasOwnProperty.call(message, "trade"))
                $root.st.Trade.encode(message.trade, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TradeCommandReq message, length delimited. Does not implicitly {@link st.TradeCommandReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.TradeCommandReq
         * @static
         * @param {st.ITradeCommandReq} message TradeCommandReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeCommandReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeCommandReq message from the specified reader or buffer.
         * @function decode
         * @memberof st.TradeCommandReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.TradeCommandReq} TradeCommandReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeCommandReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.TradeCommandReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.trade = $root.st.Trade.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TradeCommandReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.TradeCommandReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.TradeCommandReq} TradeCommandReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeCommandReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeCommandReq message.
         * @function verify
         * @memberof st.TradeCommandReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeCommandReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.trade != null && message.hasOwnProperty("trade")) {
                let error = $root.st.Trade.verify(message.trade);
                if (error)
                    return "trade." + error;
            }
            return null;
        };

        /**
         * Creates a TradeCommandReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.TradeCommandReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.TradeCommandReq} TradeCommandReq
         */
        TradeCommandReq.fromObject = function fromObject(object) {
            if (object instanceof $root.st.TradeCommandReq)
                return object;
            let message = new $root.st.TradeCommandReq();
            switch (object.type) {
            case "DEFAULT":
            case 0:
                message.type = 0;
                break;
            case "QUERY":
            case 1:
                message.type = 1;
                break;
            case "CANCEL":
            case 2:
                message.type = 2;
                break;
            case "PLACE":
            case 3:
                message.type = 3;
                break;
            case "QUERY_KLINE":
            case 4:
                message.type = 4;
                break;
            }
            if (object.trade != null) {
                if (typeof object.trade !== "object")
                    throw TypeError(".st.TradeCommandReq.trade: object expected");
                message.trade = $root.st.Trade.fromObject(object.trade);
            }
            return message;
        };

        /**
         * Creates a plain object from a TradeCommandReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.TradeCommandReq
         * @static
         * @param {st.TradeCommandReq} message TradeCommandReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeCommandReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "DEFAULT" : 0;
                object.trade = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.st.CommandType[message.type] : message.type;
            if (message.trade != null && message.hasOwnProperty("trade"))
                object.trade = $root.st.Trade.toObject(message.trade, options);
            return object;
        };

        /**
         * Converts this TradeCommandReq to JSON.
         * @function toJSON
         * @memberof st.TradeCommandReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeCommandReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeCommandReq;
    })();

    st.TradeCommandResp = (function() {

        /**
         * Properties of a TradeCommandResp.
         * @memberof st
         * @interface ITradeCommandResp
         * @property {st.ITrade|null} [trade] TradeCommandResp trade
         * @property {string|null} [errorMessage] TradeCommandResp errorMessage
         */

        /**
         * Constructs a new TradeCommandResp.
         * @memberof st
         * @classdesc Represents a TradeCommandResp.
         * @implements ITradeCommandResp
         * @constructor
         * @param {st.ITradeCommandResp=} [properties] Properties to set
         */
        function TradeCommandResp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeCommandResp trade.
         * @member {st.ITrade|null|undefined} trade
         * @memberof st.TradeCommandResp
         * @instance
         */
        TradeCommandResp.prototype.trade = null;

        /**
         * TradeCommandResp errorMessage.
         * @member {string} errorMessage
         * @memberof st.TradeCommandResp
         * @instance
         */
        TradeCommandResp.prototype.errorMessage = "";

        /**
         * Creates a new TradeCommandResp instance using the specified properties.
         * @function create
         * @memberof st.TradeCommandResp
         * @static
         * @param {st.ITradeCommandResp=} [properties] Properties to set
         * @returns {st.TradeCommandResp} TradeCommandResp instance
         */
        TradeCommandResp.create = function create(properties) {
            return new TradeCommandResp(properties);
        };

        /**
         * Encodes the specified TradeCommandResp message. Does not implicitly {@link st.TradeCommandResp.verify|verify} messages.
         * @function encode
         * @memberof st.TradeCommandResp
         * @static
         * @param {st.ITradeCommandResp} message TradeCommandResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeCommandResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trade != null && Object.hasOwnProperty.call(message, "trade"))
                $root.st.Trade.encode(message.trade, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);
            return writer;
        };

        /**
         * Encodes the specified TradeCommandResp message, length delimited. Does not implicitly {@link st.TradeCommandResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.TradeCommandResp
         * @static
         * @param {st.ITradeCommandResp} message TradeCommandResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeCommandResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeCommandResp message from the specified reader or buffer.
         * @function decode
         * @memberof st.TradeCommandResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.TradeCommandResp} TradeCommandResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeCommandResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.TradeCommandResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trade = $root.st.Trade.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.errorMessage = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TradeCommandResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.TradeCommandResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.TradeCommandResp} TradeCommandResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeCommandResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeCommandResp message.
         * @function verify
         * @memberof st.TradeCommandResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeCommandResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.trade != null && message.hasOwnProperty("trade")) {
                let error = $root.st.Trade.verify(message.trade);
                if (error)
                    return "trade." + error;
            }
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                if (!$util.isString(message.errorMessage))
                    return "errorMessage: string expected";
            return null;
        };

        /**
         * Creates a TradeCommandResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.TradeCommandResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.TradeCommandResp} TradeCommandResp
         */
        TradeCommandResp.fromObject = function fromObject(object) {
            if (object instanceof $root.st.TradeCommandResp)
                return object;
            let message = new $root.st.TradeCommandResp();
            if (object.trade != null) {
                if (typeof object.trade !== "object")
                    throw TypeError(".st.TradeCommandResp.trade: object expected");
                message.trade = $root.st.Trade.fromObject(object.trade);
            }
            if (object.errorMessage != null)
                message.errorMessage = String(object.errorMessage);
            return message;
        };

        /**
         * Creates a plain object from a TradeCommandResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.TradeCommandResp
         * @static
         * @param {st.TradeCommandResp} message TradeCommandResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeCommandResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.trade = null;
                object.errorMessage = "";
            }
            if (message.trade != null && message.hasOwnProperty("trade"))
                object.trade = $root.st.Trade.toObject(message.trade, options);
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                object.errorMessage = message.errorMessage;
            return object;
        };

        /**
         * Converts this TradeCommandResp to JSON.
         * @function toJSON
         * @memberof st.TradeCommandResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeCommandResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeCommandResp;
    })();

    st.QueryKlineReq = (function() {

        /**
         * Properties of a QueryKlineReq.
         * @memberof st
         * @interface IQueryKlineReq
         * @property {marketdata.KlineType|null} [type] QueryKlineReq type
         * @property {number|null} [startTs] QueryKlineReq startTs
         * @property {string|null} [symbol] QueryKlineReq symbol
         * @property {number|null} [limit] QueryKlineReq limit
         */

        /**
         * Constructs a new QueryKlineReq.
         * @memberof st
         * @classdesc Represents a QueryKlineReq.
         * @implements IQueryKlineReq
         * @constructor
         * @param {st.IQueryKlineReq=} [properties] Properties to set
         */
        function QueryKlineReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryKlineReq type.
         * @member {marketdata.KlineType} type
         * @memberof st.QueryKlineReq
         * @instance
         */
        QueryKlineReq.prototype.type = 0;

        /**
         * QueryKlineReq startTs.
         * @member {number} startTs
         * @memberof st.QueryKlineReq
         * @instance
         */
        QueryKlineReq.prototype.startTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * QueryKlineReq symbol.
         * @member {string} symbol
         * @memberof st.QueryKlineReq
         * @instance
         */
        QueryKlineReq.prototype.symbol = "";

        /**
         * QueryKlineReq limit.
         * @member {number} limit
         * @memberof st.QueryKlineReq
         * @instance
         */
        QueryKlineReq.prototype.limit = 0;

        /**
         * Creates a new QueryKlineReq instance using the specified properties.
         * @function create
         * @memberof st.QueryKlineReq
         * @static
         * @param {st.IQueryKlineReq=} [properties] Properties to set
         * @returns {st.QueryKlineReq} QueryKlineReq instance
         */
        QueryKlineReq.create = function create(properties) {
            return new QueryKlineReq(properties);
        };

        /**
         * Encodes the specified QueryKlineReq message. Does not implicitly {@link st.QueryKlineReq.verify|verify} messages.
         * @function encode
         * @memberof st.QueryKlineReq
         * @static
         * @param {st.IQueryKlineReq} message QueryKlineReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryKlineReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.startTs != null && Object.hasOwnProperty.call(message, "startTs"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.startTs);
            if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.symbol);
            if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.limit);
            return writer;
        };

        /**
         * Encodes the specified QueryKlineReq message, length delimited. Does not implicitly {@link st.QueryKlineReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.QueryKlineReq
         * @static
         * @param {st.IQueryKlineReq} message QueryKlineReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryKlineReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryKlineReq message from the specified reader or buffer.
         * @function decode
         * @memberof st.QueryKlineReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.QueryKlineReq} QueryKlineReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryKlineReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.QueryKlineReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.startTs = reader.uint64();
                    break;
                case 3:
                    message.symbol = reader.string();
                    break;
                case 4:
                    message.limit = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryKlineReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.QueryKlineReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.QueryKlineReq} QueryKlineReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryKlineReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryKlineReq message.
         * @function verify
         * @memberof st.QueryKlineReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryKlineReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.startTs != null && message.hasOwnProperty("startTs"))
                if (!$util.isInteger(message.startTs) && !(message.startTs && $util.isInteger(message.startTs.low) && $util.isInteger(message.startTs.high)))
                    return "startTs: integer|Long expected";
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                if (!$util.isString(message.symbol))
                    return "symbol: string expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit))
                    return "limit: integer expected";
            return null;
        };

        /**
         * Creates a QueryKlineReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.QueryKlineReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.QueryKlineReq} QueryKlineReq
         */
        QueryKlineReq.fromObject = function fromObject(object) {
            if (object instanceof $root.st.QueryKlineReq)
                return object;
            let message = new $root.st.QueryKlineReq();
            switch (object.type) {
            case "DEFAULT_KLINE_TYPE":
            case 0:
                message.type = 0;
                break;
            case "KLINE_MIN":
            case 1:
                message.type = 1;
                break;
            case "KLINE_15MIN":
            case 2:
                message.type = 2;
                break;
            case "KLINE_HOUR":
            case 3:
                message.type = 3;
                break;
            case "KLINE_DAY":
            case 4:
                message.type = 4;
                break;
            case "KLINE_WEEK":
            case 5:
                message.type = 5;
                break;
            case "KLINE_MONTH":
            case 6:
                message.type = 6;
                break;
            }
            if (object.startTs != null)
                if ($util.Long)
                    (message.startTs = $util.Long.fromValue(object.startTs)).unsigned = true;
                else if (typeof object.startTs === "string")
                    message.startTs = parseInt(object.startTs, 10);
                else if (typeof object.startTs === "number")
                    message.startTs = object.startTs;
                else if (typeof object.startTs === "object")
                    message.startTs = new $util.LongBits(object.startTs.low >>> 0, object.startTs.high >>> 0).toNumber(true);
            if (object.symbol != null)
                message.symbol = String(object.symbol);
            if (object.limit != null)
                message.limit = object.limit >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a QueryKlineReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.QueryKlineReq
         * @static
         * @param {st.QueryKlineReq} message QueryKlineReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryKlineReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "DEFAULT_KLINE_TYPE" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.startTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTs = options.longs === String ? "0" : 0;
                object.symbol = "";
                object.limit = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.marketdata.KlineType[message.type] : message.type;
            if (message.startTs != null && message.hasOwnProperty("startTs"))
                if (typeof message.startTs === "number")
                    object.startTs = options.longs === String ? String(message.startTs) : message.startTs;
                else
                    object.startTs = options.longs === String ? $util.Long.prototype.toString.call(message.startTs) : options.longs === Number ? new $util.LongBits(message.startTs.low >>> 0, message.startTs.high >>> 0).toNumber(true) : message.startTs;
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                object.symbol = message.symbol;
            if (message.limit != null && message.hasOwnProperty("limit"))
                object.limit = message.limit;
            return object;
        };

        /**
         * Converts this QueryKlineReq to JSON.
         * @function toJSON
         * @memberof st.QueryKlineReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryKlineReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryKlineReq;
    })();

    st.QueryKlineResp = (function() {

        /**
         * Properties of a QueryKlineResp.
         * @memberof st
         * @interface IQueryKlineResp
         * @property {Array.<marketdata.IKline>|null} [klines] QueryKlineResp klines
         */

        /**
         * Constructs a new QueryKlineResp.
         * @memberof st
         * @classdesc Represents a QueryKlineResp.
         * @implements IQueryKlineResp
         * @constructor
         * @param {st.IQueryKlineResp=} [properties] Properties to set
         */
        function QueryKlineResp(properties) {
            this.klines = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryKlineResp klines.
         * @member {Array.<marketdata.IKline>} klines
         * @memberof st.QueryKlineResp
         * @instance
         */
        QueryKlineResp.prototype.klines = $util.emptyArray;

        /**
         * Creates a new QueryKlineResp instance using the specified properties.
         * @function create
         * @memberof st.QueryKlineResp
         * @static
         * @param {st.IQueryKlineResp=} [properties] Properties to set
         * @returns {st.QueryKlineResp} QueryKlineResp instance
         */
        QueryKlineResp.create = function create(properties) {
            return new QueryKlineResp(properties);
        };

        /**
         * Encodes the specified QueryKlineResp message. Does not implicitly {@link st.QueryKlineResp.verify|verify} messages.
         * @function encode
         * @memberof st.QueryKlineResp
         * @static
         * @param {st.IQueryKlineResp} message QueryKlineResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryKlineResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.klines != null && message.klines.length)
                for (let i = 0; i < message.klines.length; ++i)
                    $root.marketdata.Kline.encode(message.klines[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryKlineResp message, length delimited. Does not implicitly {@link st.QueryKlineResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.QueryKlineResp
         * @static
         * @param {st.IQueryKlineResp} message QueryKlineResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryKlineResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryKlineResp message from the specified reader or buffer.
         * @function decode
         * @memberof st.QueryKlineResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.QueryKlineResp} QueryKlineResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryKlineResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.QueryKlineResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.klines && message.klines.length))
                        message.klines = [];
                    message.klines.push($root.marketdata.Kline.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryKlineResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.QueryKlineResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.QueryKlineResp} QueryKlineResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryKlineResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryKlineResp message.
         * @function verify
         * @memberof st.QueryKlineResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryKlineResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.klines != null && message.hasOwnProperty("klines")) {
                if (!Array.isArray(message.klines))
                    return "klines: array expected";
                for (let i = 0; i < message.klines.length; ++i) {
                    let error = $root.marketdata.Kline.verify(message.klines[i]);
                    if (error)
                        return "klines." + error;
                }
            }
            return null;
        };

        /**
         * Creates a QueryKlineResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.QueryKlineResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.QueryKlineResp} QueryKlineResp
         */
        QueryKlineResp.fromObject = function fromObject(object) {
            if (object instanceof $root.st.QueryKlineResp)
                return object;
            let message = new $root.st.QueryKlineResp();
            if (object.klines) {
                if (!Array.isArray(object.klines))
                    throw TypeError(".st.QueryKlineResp.klines: array expected");
                message.klines = [];
                for (let i = 0; i < object.klines.length; ++i) {
                    if (typeof object.klines[i] !== "object")
                        throw TypeError(".st.QueryKlineResp.klines: object expected");
                    message.klines[i] = $root.marketdata.Kline.fromObject(object.klines[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryKlineResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.QueryKlineResp
         * @static
         * @param {st.QueryKlineResp} message QueryKlineResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryKlineResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.klines = [];
            if (message.klines && message.klines.length) {
                object.klines = [];
                for (let j = 0; j < message.klines.length; ++j)
                    object.klines[j] = $root.marketdata.Kline.toObject(message.klines[j], options);
            }
            return object;
        };

        /**
         * Converts this QueryKlineResp to JSON.
         * @function toJSON
         * @memberof st.QueryKlineResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryKlineResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryKlineResp;
    })();

    /**
     * PlanState enum.
     * @name st.PlanState
     * @enum {number}
     * @property {number} DEFAULT_PLAN_STATE=0 DEFAULT_PLAN_STATE value
     * @property {number} OPENING=1 OPENING value
     * @property {number} STOP_OPENING=2 STOP_OPENING value
     * @property {number} OPEN_FINISH=3 OPEN_FINISH value
     * @property {number} CLOSING=4 CLOSING value
     * @property {number} CLOSE_FINISH=5 CLOSE_FINISH value
     * @property {number} CANCELED=6 CANCELED value
     * @property {number} QUICK_CLOSING=7 QUICK_CLOSING value
     * @property {number} FUNDING_RATE_RESUME=8 FUNDING_RATE_RESUME value
     * @property {number} FUNDING_RATE_RESTORE=9 FUNDING_RATE_RESTORE value
     * @property {number} ADD_OPENING=10 ADD_OPENING value
     * @property {number} SUB_CLOSING=11 SUB_CLOSING value
     */
    st.PlanState = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_PLAN_STATE"] = 0;
        values[valuesById[1] = "OPENING"] = 1;
        values[valuesById[2] = "STOP_OPENING"] = 2;
        values[valuesById[3] = "OPEN_FINISH"] = 3;
        values[valuesById[4] = "CLOSING"] = 4;
        values[valuesById[5] = "CLOSE_FINISH"] = 5;
        values[valuesById[6] = "CANCELED"] = 6;
        values[valuesById[7] = "QUICK_CLOSING"] = 7;
        values[valuesById[8] = "FUNDING_RATE_RESUME"] = 8;
        values[valuesById[9] = "FUNDING_RATE_RESTORE"] = 9;
        values[valuesById[10] = "ADD_OPENING"] = 10;
        values[valuesById[11] = "SUB_CLOSING"] = 11;
        return values;
    })();

    /**
     * FutureOpenType enum.
     * @name st.FutureOpenType
     * @enum {number}
     * @property {number} DEFAULT_OPEN_TYPE=0 DEFAULT_OPEN_TYPE value
     * @property {number} FUTURE_LONG=1 FUTURE_LONG value
     * @property {number} FUTURE_SHORT=2 FUTURE_SHORT value
     */
    st.FutureOpenType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_OPEN_TYPE"] = 0;
        values[valuesById[1] = "FUTURE_LONG"] = 1;
        values[valuesById[2] = "FUTURE_SHORT"] = 2;
        return values;
    })();

    /**
     * StrategyActionType enum.
     * @name st.StrategyActionType
     * @enum {number}
     * @property {number} DEFAULT_ACTION_TYPE=0 DEFAULT_ACTION_TYPE value
     * @property {number} KEEP=1 KEEP value
     * @property {number} CONTINUE_TRADE=2 CONTINUE_TRADE value
     * @property {number} ADD=3 ADD value
     * @property {number} STOP=4 STOP value
     * @property {number} STOP_SOON=5 STOP_SOON value
     * @property {number} DEC=6 DEC value
     */
    st.StrategyActionType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_ACTION_TYPE"] = 0;
        values[valuesById[1] = "KEEP"] = 1;
        values[valuesById[2] = "CONTINUE_TRADE"] = 2;
        values[valuesById[3] = "ADD"] = 3;
        values[valuesById[4] = "STOP"] = 4;
        values[valuesById[5] = "STOP_SOON"] = 5;
        values[valuesById[6] = "DEC"] = 6;
        return values;
    })();

    /**
     * FundingRateResumeState enum.
     * @name st.FundingRateResumeState
     * @enum {number}
     * @property {number} DEFAULT_FUNDING_RATE_STATE=0 DEFAULT_FUNDING_RATE_STATE value
     */
    st.FundingRateResumeState = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_FUNDING_RATE_STATE"] = 0;
        return values;
    })();

    st.FundingRateSettle = (function() {

        /**
         * Properties of a FundingRateSettle.
         * @memberof st
         * @interface IFundingRateSettle
         * @property {string|null} [recordId] FundingRateSettle recordId
         * @property {string|null} [planId] FundingRateSettle planId
         * @property {string|null} [settleUtc8Date] FundingRateSettle settleUtc8Date
         * @property {string|null} [settleFundingRate] FundingRateSettle settleFundingRate
         * @property {string|null} [settleFee] FundingRateSettle settleFee
         * @property {string|null} [settleCont] FundingRateSettle settleCont
         * @property {st.FutureOpenType|null} [settlePositionType] FundingRateSettle settlePositionType
         */

        /**
         * Constructs a new FundingRateSettle.
         * @memberof st
         * @classdesc Represents a FundingRateSettle.
         * @implements IFundingRateSettle
         * @constructor
         * @param {st.IFundingRateSettle=} [properties] Properties to set
         */
        function FundingRateSettle(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FundingRateSettle recordId.
         * @member {string} recordId
         * @memberof st.FundingRateSettle
         * @instance
         */
        FundingRateSettle.prototype.recordId = "";

        /**
         * FundingRateSettle planId.
         * @member {string} planId
         * @memberof st.FundingRateSettle
         * @instance
         */
        FundingRateSettle.prototype.planId = "";

        /**
         * FundingRateSettle settleUtc8Date.
         * @member {string} settleUtc8Date
         * @memberof st.FundingRateSettle
         * @instance
         */
        FundingRateSettle.prototype.settleUtc8Date = "";

        /**
         * FundingRateSettle settleFundingRate.
         * @member {string} settleFundingRate
         * @memberof st.FundingRateSettle
         * @instance
         */
        FundingRateSettle.prototype.settleFundingRate = "";

        /**
         * FundingRateSettle settleFee.
         * @member {string} settleFee
         * @memberof st.FundingRateSettle
         * @instance
         */
        FundingRateSettle.prototype.settleFee = "";

        /**
         * FundingRateSettle settleCont.
         * @member {string} settleCont
         * @memberof st.FundingRateSettle
         * @instance
         */
        FundingRateSettle.prototype.settleCont = "";

        /**
         * FundingRateSettle settlePositionType.
         * @member {st.FutureOpenType} settlePositionType
         * @memberof st.FundingRateSettle
         * @instance
         */
        FundingRateSettle.prototype.settlePositionType = 0;

        /**
         * Creates a new FundingRateSettle instance using the specified properties.
         * @function create
         * @memberof st.FundingRateSettle
         * @static
         * @param {st.IFundingRateSettle=} [properties] Properties to set
         * @returns {st.FundingRateSettle} FundingRateSettle instance
         */
        FundingRateSettle.create = function create(properties) {
            return new FundingRateSettle(properties);
        };

        /**
         * Encodes the specified FundingRateSettle message. Does not implicitly {@link st.FundingRateSettle.verify|verify} messages.
         * @function encode
         * @memberof st.FundingRateSettle
         * @static
         * @param {st.IFundingRateSettle} message FundingRateSettle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingRateSettle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordId != null && Object.hasOwnProperty.call(message, "recordId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.recordId);
            if (message.planId != null && Object.hasOwnProperty.call(message, "planId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.planId);
            if (message.settleUtc8Date != null && Object.hasOwnProperty.call(message, "settleUtc8Date"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.settleUtc8Date);
            if (message.settleFundingRate != null && Object.hasOwnProperty.call(message, "settleFundingRate"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.settleFundingRate);
            if (message.settleFee != null && Object.hasOwnProperty.call(message, "settleFee"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.settleFee);
            if (message.settleCont != null && Object.hasOwnProperty.call(message, "settleCont"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.settleCont);
            if (message.settlePositionType != null && Object.hasOwnProperty.call(message, "settlePositionType"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.settlePositionType);
            return writer;
        };

        /**
         * Encodes the specified FundingRateSettle message, length delimited. Does not implicitly {@link st.FundingRateSettle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.FundingRateSettle
         * @static
         * @param {st.IFundingRateSettle} message FundingRateSettle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingRateSettle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FundingRateSettle message from the specified reader or buffer.
         * @function decode
         * @memberof st.FundingRateSettle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.FundingRateSettle} FundingRateSettle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingRateSettle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.FundingRateSettle();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordId = reader.string();
                    break;
                case 2:
                    message.planId = reader.string();
                    break;
                case 3:
                    message.settleUtc8Date = reader.string();
                    break;
                case 4:
                    message.settleFundingRate = reader.string();
                    break;
                case 5:
                    message.settleFee = reader.string();
                    break;
                case 6:
                    message.settleCont = reader.string();
                    break;
                case 7:
                    message.settlePositionType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FundingRateSettle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.FundingRateSettle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.FundingRateSettle} FundingRateSettle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingRateSettle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FundingRateSettle message.
         * @function verify
         * @memberof st.FundingRateSettle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FundingRateSettle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordId != null && message.hasOwnProperty("recordId"))
                if (!$util.isString(message.recordId))
                    return "recordId: string expected";
            if (message.planId != null && message.hasOwnProperty("planId"))
                if (!$util.isString(message.planId))
                    return "planId: string expected";
            if (message.settleUtc8Date != null && message.hasOwnProperty("settleUtc8Date"))
                if (!$util.isString(message.settleUtc8Date))
                    return "settleUtc8Date: string expected";
            if (message.settleFundingRate != null && message.hasOwnProperty("settleFundingRate"))
                if (!$util.isString(message.settleFundingRate))
                    return "settleFundingRate: string expected";
            if (message.settleFee != null && message.hasOwnProperty("settleFee"))
                if (!$util.isString(message.settleFee))
                    return "settleFee: string expected";
            if (message.settleCont != null && message.hasOwnProperty("settleCont"))
                if (!$util.isString(message.settleCont))
                    return "settleCont: string expected";
            if (message.settlePositionType != null && message.hasOwnProperty("settlePositionType"))
                switch (message.settlePositionType) {
                default:
                    return "settlePositionType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a FundingRateSettle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.FundingRateSettle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.FundingRateSettle} FundingRateSettle
         */
        FundingRateSettle.fromObject = function fromObject(object) {
            if (object instanceof $root.st.FundingRateSettle)
                return object;
            let message = new $root.st.FundingRateSettle();
            if (object.recordId != null)
                message.recordId = String(object.recordId);
            if (object.planId != null)
                message.planId = String(object.planId);
            if (object.settleUtc8Date != null)
                message.settleUtc8Date = String(object.settleUtc8Date);
            if (object.settleFundingRate != null)
                message.settleFundingRate = String(object.settleFundingRate);
            if (object.settleFee != null)
                message.settleFee = String(object.settleFee);
            if (object.settleCont != null)
                message.settleCont = String(object.settleCont);
            switch (object.settlePositionType) {
            case "DEFAULT_OPEN_TYPE":
            case 0:
                message.settlePositionType = 0;
                break;
            case "FUTURE_LONG":
            case 1:
                message.settlePositionType = 1;
                break;
            case "FUTURE_SHORT":
            case 2:
                message.settlePositionType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a FundingRateSettle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.FundingRateSettle
         * @static
         * @param {st.FundingRateSettle} message FundingRateSettle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FundingRateSettle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.recordId = "";
                object.planId = "";
                object.settleUtc8Date = "";
                object.settleFundingRate = "";
                object.settleFee = "";
                object.settleCont = "";
                object.settlePositionType = options.enums === String ? "DEFAULT_OPEN_TYPE" : 0;
            }
            if (message.recordId != null && message.hasOwnProperty("recordId"))
                object.recordId = message.recordId;
            if (message.planId != null && message.hasOwnProperty("planId"))
                object.planId = message.planId;
            if (message.settleUtc8Date != null && message.hasOwnProperty("settleUtc8Date"))
                object.settleUtc8Date = message.settleUtc8Date;
            if (message.settleFundingRate != null && message.hasOwnProperty("settleFundingRate"))
                object.settleFundingRate = message.settleFundingRate;
            if (message.settleFee != null && message.hasOwnProperty("settleFee"))
                object.settleFee = message.settleFee;
            if (message.settleCont != null && message.hasOwnProperty("settleCont"))
                object.settleCont = message.settleCont;
            if (message.settlePositionType != null && message.hasOwnProperty("settlePositionType"))
                object.settlePositionType = options.enums === String ? $root.st.FutureOpenType[message.settlePositionType] : message.settlePositionType;
            return object;
        };

        /**
         * Converts this FundingRateSettle to JSON.
         * @function toJSON
         * @memberof st.FundingRateSettle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FundingRateSettle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FundingRateSettle;
    })();

    st.FundingRateResumeContext = (function() {

        /**
         * Properties of a FundingRateResumeContext.
         * @memberof st
         * @interface IFundingRateResumeContext
         * @property {string|null} [planId] FundingRateResumeContext planId
         * @property {string|null} [contextId] FundingRateResumeContext contextId
         * @property {string|null} [resumeCont] FundingRateResumeContext resumeCont
         * @property {string|null} [resumePrice] FundingRateResumeContext resumePrice
         * @property {st.FutureOpenType|null} [resumePositionType] FundingRateResumeContext resumePositionType
         * @property {st.FundingRateResumeState|null} [resumeState] FundingRateResumeContext resumeState
         */

        /**
         * Constructs a new FundingRateResumeContext.
         * @memberof st
         * @classdesc Represents a FundingRateResumeContext.
         * @implements IFundingRateResumeContext
         * @constructor
         * @param {st.IFundingRateResumeContext=} [properties] Properties to set
         */
        function FundingRateResumeContext(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FundingRateResumeContext planId.
         * @member {string} planId
         * @memberof st.FundingRateResumeContext
         * @instance
         */
        FundingRateResumeContext.prototype.planId = "";

        /**
         * FundingRateResumeContext contextId.
         * @member {string} contextId
         * @memberof st.FundingRateResumeContext
         * @instance
         */
        FundingRateResumeContext.prototype.contextId = "";

        /**
         * FundingRateResumeContext resumeCont.
         * @member {string} resumeCont
         * @memberof st.FundingRateResumeContext
         * @instance
         */
        FundingRateResumeContext.prototype.resumeCont = "";

        /**
         * FundingRateResumeContext resumePrice.
         * @member {string} resumePrice
         * @memberof st.FundingRateResumeContext
         * @instance
         */
        FundingRateResumeContext.prototype.resumePrice = "";

        /**
         * FundingRateResumeContext resumePositionType.
         * @member {st.FutureOpenType} resumePositionType
         * @memberof st.FundingRateResumeContext
         * @instance
         */
        FundingRateResumeContext.prototype.resumePositionType = 0;

        /**
         * FundingRateResumeContext resumeState.
         * @member {st.FundingRateResumeState} resumeState
         * @memberof st.FundingRateResumeContext
         * @instance
         */
        FundingRateResumeContext.prototype.resumeState = 0;

        /**
         * Creates a new FundingRateResumeContext instance using the specified properties.
         * @function create
         * @memberof st.FundingRateResumeContext
         * @static
         * @param {st.IFundingRateResumeContext=} [properties] Properties to set
         * @returns {st.FundingRateResumeContext} FundingRateResumeContext instance
         */
        FundingRateResumeContext.create = function create(properties) {
            return new FundingRateResumeContext(properties);
        };

        /**
         * Encodes the specified FundingRateResumeContext message. Does not implicitly {@link st.FundingRateResumeContext.verify|verify} messages.
         * @function encode
         * @memberof st.FundingRateResumeContext
         * @static
         * @param {st.IFundingRateResumeContext} message FundingRateResumeContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingRateResumeContext.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.planId != null && Object.hasOwnProperty.call(message, "planId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.planId);
            if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.contextId);
            if (message.resumeCont != null && Object.hasOwnProperty.call(message, "resumeCont"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.resumeCont);
            if (message.resumePrice != null && Object.hasOwnProperty.call(message, "resumePrice"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.resumePrice);
            if (message.resumePositionType != null && Object.hasOwnProperty.call(message, "resumePositionType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.resumePositionType);
            if (message.resumeState != null && Object.hasOwnProperty.call(message, "resumeState"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.resumeState);
            return writer;
        };

        /**
         * Encodes the specified FundingRateResumeContext message, length delimited. Does not implicitly {@link st.FundingRateResumeContext.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.FundingRateResumeContext
         * @static
         * @param {st.IFundingRateResumeContext} message FundingRateResumeContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FundingRateResumeContext.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FundingRateResumeContext message from the specified reader or buffer.
         * @function decode
         * @memberof st.FundingRateResumeContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.FundingRateResumeContext} FundingRateResumeContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingRateResumeContext.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.FundingRateResumeContext();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.planId = reader.string();
                    break;
                case 2:
                    message.contextId = reader.string();
                    break;
                case 3:
                    message.resumeCont = reader.string();
                    break;
                case 4:
                    message.resumePrice = reader.string();
                    break;
                case 5:
                    message.resumePositionType = reader.int32();
                    break;
                case 6:
                    message.resumeState = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FundingRateResumeContext message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.FundingRateResumeContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.FundingRateResumeContext} FundingRateResumeContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FundingRateResumeContext.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FundingRateResumeContext message.
         * @function verify
         * @memberof st.FundingRateResumeContext
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FundingRateResumeContext.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.planId != null && message.hasOwnProperty("planId"))
                if (!$util.isString(message.planId))
                    return "planId: string expected";
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (!$util.isString(message.contextId))
                    return "contextId: string expected";
            if (message.resumeCont != null && message.hasOwnProperty("resumeCont"))
                if (!$util.isString(message.resumeCont))
                    return "resumeCont: string expected";
            if (message.resumePrice != null && message.hasOwnProperty("resumePrice"))
                if (!$util.isString(message.resumePrice))
                    return "resumePrice: string expected";
            if (message.resumePositionType != null && message.hasOwnProperty("resumePositionType"))
                switch (message.resumePositionType) {
                default:
                    return "resumePositionType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.resumeState != null && message.hasOwnProperty("resumeState"))
                switch (message.resumeState) {
                default:
                    return "resumeState: enum value expected";
                case 0:
                    break;
                }
            return null;
        };

        /**
         * Creates a FundingRateResumeContext message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.FundingRateResumeContext
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.FundingRateResumeContext} FundingRateResumeContext
         */
        FundingRateResumeContext.fromObject = function fromObject(object) {
            if (object instanceof $root.st.FundingRateResumeContext)
                return object;
            let message = new $root.st.FundingRateResumeContext();
            if (object.planId != null)
                message.planId = String(object.planId);
            if (object.contextId != null)
                message.contextId = String(object.contextId);
            if (object.resumeCont != null)
                message.resumeCont = String(object.resumeCont);
            if (object.resumePrice != null)
                message.resumePrice = String(object.resumePrice);
            switch (object.resumePositionType) {
            case "DEFAULT_OPEN_TYPE":
            case 0:
                message.resumePositionType = 0;
                break;
            case "FUTURE_LONG":
            case 1:
                message.resumePositionType = 1;
                break;
            case "FUTURE_SHORT":
            case 2:
                message.resumePositionType = 2;
                break;
            }
            switch (object.resumeState) {
            case "DEFAULT_FUNDING_RATE_STATE":
            case 0:
                message.resumeState = 0;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a FundingRateResumeContext message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.FundingRateResumeContext
         * @static
         * @param {st.FundingRateResumeContext} message FundingRateResumeContext
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FundingRateResumeContext.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.planId = "";
                object.contextId = "";
                object.resumeCont = "";
                object.resumePrice = "";
                object.resumePositionType = options.enums === String ? "DEFAULT_OPEN_TYPE" : 0;
                object.resumeState = options.enums === String ? "DEFAULT_FUNDING_RATE_STATE" : 0;
            }
            if (message.planId != null && message.hasOwnProperty("planId"))
                object.planId = message.planId;
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                object.contextId = message.contextId;
            if (message.resumeCont != null && message.hasOwnProperty("resumeCont"))
                object.resumeCont = message.resumeCont;
            if (message.resumePrice != null && message.hasOwnProperty("resumePrice"))
                object.resumePrice = message.resumePrice;
            if (message.resumePositionType != null && message.hasOwnProperty("resumePositionType"))
                object.resumePositionType = options.enums === String ? $root.st.FutureOpenType[message.resumePositionType] : message.resumePositionType;
            if (message.resumeState != null && message.hasOwnProperty("resumeState"))
                object.resumeState = options.enums === String ? $root.st.FundingRateResumeState[message.resumeState] : message.resumeState;
            return object;
        };

        /**
         * Converts this FundingRateResumeContext to JSON.
         * @function toJSON
         * @memberof st.FundingRateResumeContext
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FundingRateResumeContext.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FundingRateResumeContext;
    })();

    st.AddPositionAction = (function() {

        /**
         * Properties of an AddPositionAction.
         * @memberof st
         * @interface IAddPositionAction
         * @property {string|null} [actionId] AddPositionAction actionId
         * @property {number|null} [addCont] AddPositionAction addCont
         * @property {string|null} [curProfitRatio] AddPositionAction curProfitRatio
         * @property {number|null} [priority] AddPositionAction priority
         * @property {number|null} [endTs] AddPositionAction endTs
         */

        /**
         * Constructs a new AddPositionAction.
         * @memberof st
         * @classdesc Represents an AddPositionAction.
         * @implements IAddPositionAction
         * @constructor
         * @param {st.IAddPositionAction=} [properties] Properties to set
         */
        function AddPositionAction(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddPositionAction actionId.
         * @member {string} actionId
         * @memberof st.AddPositionAction
         * @instance
         */
        AddPositionAction.prototype.actionId = "";

        /**
         * AddPositionAction addCont.
         * @member {number} addCont
         * @memberof st.AddPositionAction
         * @instance
         */
        AddPositionAction.prototype.addCont = 0;

        /**
         * AddPositionAction curProfitRatio.
         * @member {string} curProfitRatio
         * @memberof st.AddPositionAction
         * @instance
         */
        AddPositionAction.prototype.curProfitRatio = "";

        /**
         * AddPositionAction priority.
         * @member {number} priority
         * @memberof st.AddPositionAction
         * @instance
         */
        AddPositionAction.prototype.priority = 0;

        /**
         * AddPositionAction endTs.
         * @member {number} endTs
         * @memberof st.AddPositionAction
         * @instance
         */
        AddPositionAction.prototype.endTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new AddPositionAction instance using the specified properties.
         * @function create
         * @memberof st.AddPositionAction
         * @static
         * @param {st.IAddPositionAction=} [properties] Properties to set
         * @returns {st.AddPositionAction} AddPositionAction instance
         */
        AddPositionAction.create = function create(properties) {
            return new AddPositionAction(properties);
        };

        /**
         * Encodes the specified AddPositionAction message. Does not implicitly {@link st.AddPositionAction.verify|verify} messages.
         * @function encode
         * @memberof st.AddPositionAction
         * @static
         * @param {st.IAddPositionAction} message AddPositionAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddPositionAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actionId != null && Object.hasOwnProperty.call(message, "actionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionId);
            if (message.addCont != null && Object.hasOwnProperty.call(message, "addCont"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.addCont);
            if (message.curProfitRatio != null && Object.hasOwnProperty.call(message, "curProfitRatio"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.curProfitRatio);
            if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.priority);
            if (message.endTs != null && Object.hasOwnProperty.call(message, "endTs"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.endTs);
            return writer;
        };

        /**
         * Encodes the specified AddPositionAction message, length delimited. Does not implicitly {@link st.AddPositionAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.AddPositionAction
         * @static
         * @param {st.IAddPositionAction} message AddPositionAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddPositionAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddPositionAction message from the specified reader or buffer.
         * @function decode
         * @memberof st.AddPositionAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.AddPositionAction} AddPositionAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddPositionAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.AddPositionAction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.actionId = reader.string();
                    break;
                case 2:
                    message.addCont = reader.uint32();
                    break;
                case 3:
                    message.curProfitRatio = reader.string();
                    break;
                case 4:
                    message.priority = reader.uint32();
                    break;
                case 5:
                    message.endTs = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddPositionAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.AddPositionAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.AddPositionAction} AddPositionAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddPositionAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddPositionAction message.
         * @function verify
         * @memberof st.AddPositionAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddPositionAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actionId != null && message.hasOwnProperty("actionId"))
                if (!$util.isString(message.actionId))
                    return "actionId: string expected";
            if (message.addCont != null && message.hasOwnProperty("addCont"))
                if (!$util.isInteger(message.addCont))
                    return "addCont: integer expected";
            if (message.curProfitRatio != null && message.hasOwnProperty("curProfitRatio"))
                if (!$util.isString(message.curProfitRatio))
                    return "curProfitRatio: string expected";
            if (message.priority != null && message.hasOwnProperty("priority"))
                if (!$util.isInteger(message.priority))
                    return "priority: integer expected";
            if (message.endTs != null && message.hasOwnProperty("endTs"))
                if (!$util.isInteger(message.endTs) && !(message.endTs && $util.isInteger(message.endTs.low) && $util.isInteger(message.endTs.high)))
                    return "endTs: integer|Long expected";
            return null;
        };

        /**
         * Creates an AddPositionAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.AddPositionAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.AddPositionAction} AddPositionAction
         */
        AddPositionAction.fromObject = function fromObject(object) {
            if (object instanceof $root.st.AddPositionAction)
                return object;
            let message = new $root.st.AddPositionAction();
            if (object.actionId != null)
                message.actionId = String(object.actionId);
            if (object.addCont != null)
                message.addCont = object.addCont >>> 0;
            if (object.curProfitRatio != null)
                message.curProfitRatio = String(object.curProfitRatio);
            if (object.priority != null)
                message.priority = object.priority >>> 0;
            if (object.endTs != null)
                if ($util.Long)
                    (message.endTs = $util.Long.fromValue(object.endTs)).unsigned = true;
                else if (typeof object.endTs === "string")
                    message.endTs = parseInt(object.endTs, 10);
                else if (typeof object.endTs === "number")
                    message.endTs = object.endTs;
                else if (typeof object.endTs === "object")
                    message.endTs = new $util.LongBits(object.endTs.low >>> 0, object.endTs.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an AddPositionAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.AddPositionAction
         * @static
         * @param {st.AddPositionAction} message AddPositionAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddPositionAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.actionId = "";
                object.addCont = 0;
                object.curProfitRatio = "";
                object.priority = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.endTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endTs = options.longs === String ? "0" : 0;
            }
            if (message.actionId != null && message.hasOwnProperty("actionId"))
                object.actionId = message.actionId;
            if (message.addCont != null && message.hasOwnProperty("addCont"))
                object.addCont = message.addCont;
            if (message.curProfitRatio != null && message.hasOwnProperty("curProfitRatio"))
                object.curProfitRatio = message.curProfitRatio;
            if (message.priority != null && message.hasOwnProperty("priority"))
                object.priority = message.priority;
            if (message.endTs != null && message.hasOwnProperty("endTs"))
                if (typeof message.endTs === "number")
                    object.endTs = options.longs === String ? String(message.endTs) : message.endTs;
                else
                    object.endTs = options.longs === String ? $util.Long.prototype.toString.call(message.endTs) : options.longs === Number ? new $util.LongBits(message.endTs.low >>> 0, message.endTs.high >>> 0).toNumber(true) : message.endTs;
            return object;
        };

        /**
         * Converts this AddPositionAction to JSON.
         * @function toJSON
         * @memberof st.AddPositionAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddPositionAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AddPositionAction;
    })();

    st.DecPositionAction = (function() {

        /**
         * Properties of a DecPositionAction.
         * @memberof st
         * @interface IDecPositionAction
         * @property {string|null} [actionId] DecPositionAction actionId
         * @property {number|null} [decCont] DecPositionAction decCont
         * @property {string|null} [curProfitRatio] DecPositionAction curProfitRatio
         * @property {number|null} [priority] DecPositionAction priority
         * @property {number|null} [endTs] DecPositionAction endTs
         * @property {st.ITrade|null} [toCloseTrade] DecPositionAction toCloseTrade
         */

        /**
         * Constructs a new DecPositionAction.
         * @memberof st
         * @classdesc Represents a DecPositionAction.
         * @implements IDecPositionAction
         * @constructor
         * @param {st.IDecPositionAction=} [properties] Properties to set
         */
        function DecPositionAction(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DecPositionAction actionId.
         * @member {string} actionId
         * @memberof st.DecPositionAction
         * @instance
         */
        DecPositionAction.prototype.actionId = "";

        /**
         * DecPositionAction decCont.
         * @member {number} decCont
         * @memberof st.DecPositionAction
         * @instance
         */
        DecPositionAction.prototype.decCont = 0;

        /**
         * DecPositionAction curProfitRatio.
         * @member {string} curProfitRatio
         * @memberof st.DecPositionAction
         * @instance
         */
        DecPositionAction.prototype.curProfitRatio = "";

        /**
         * DecPositionAction priority.
         * @member {number} priority
         * @memberof st.DecPositionAction
         * @instance
         */
        DecPositionAction.prototype.priority = 0;

        /**
         * DecPositionAction endTs.
         * @member {number} endTs
         * @memberof st.DecPositionAction
         * @instance
         */
        DecPositionAction.prototype.endTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DecPositionAction toCloseTrade.
         * @member {st.ITrade|null|undefined} toCloseTrade
         * @memberof st.DecPositionAction
         * @instance
         */
        DecPositionAction.prototype.toCloseTrade = null;

        /**
         * Creates a new DecPositionAction instance using the specified properties.
         * @function create
         * @memberof st.DecPositionAction
         * @static
         * @param {st.IDecPositionAction=} [properties] Properties to set
         * @returns {st.DecPositionAction} DecPositionAction instance
         */
        DecPositionAction.create = function create(properties) {
            return new DecPositionAction(properties);
        };

        /**
         * Encodes the specified DecPositionAction message. Does not implicitly {@link st.DecPositionAction.verify|verify} messages.
         * @function encode
         * @memberof st.DecPositionAction
         * @static
         * @param {st.IDecPositionAction} message DecPositionAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecPositionAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actionId != null && Object.hasOwnProperty.call(message, "actionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionId);
            if (message.decCont != null && Object.hasOwnProperty.call(message, "decCont"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.decCont);
            if (message.curProfitRatio != null && Object.hasOwnProperty.call(message, "curProfitRatio"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.curProfitRatio);
            if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.priority);
            if (message.endTs != null && Object.hasOwnProperty.call(message, "endTs"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.endTs);
            if (message.toCloseTrade != null && Object.hasOwnProperty.call(message, "toCloseTrade"))
                $root.st.Trade.encode(message.toCloseTrade, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DecPositionAction message, length delimited. Does not implicitly {@link st.DecPositionAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.DecPositionAction
         * @static
         * @param {st.IDecPositionAction} message DecPositionAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecPositionAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DecPositionAction message from the specified reader or buffer.
         * @function decode
         * @memberof st.DecPositionAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.DecPositionAction} DecPositionAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecPositionAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.DecPositionAction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.actionId = reader.string();
                    break;
                case 2:
                    message.decCont = reader.uint32();
                    break;
                case 3:
                    message.curProfitRatio = reader.string();
                    break;
                case 4:
                    message.priority = reader.uint32();
                    break;
                case 5:
                    message.endTs = reader.uint64();
                    break;
                case 6:
                    message.toCloseTrade = $root.st.Trade.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DecPositionAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.DecPositionAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.DecPositionAction} DecPositionAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecPositionAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DecPositionAction message.
         * @function verify
         * @memberof st.DecPositionAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DecPositionAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actionId != null && message.hasOwnProperty("actionId"))
                if (!$util.isString(message.actionId))
                    return "actionId: string expected";
            if (message.decCont != null && message.hasOwnProperty("decCont"))
                if (!$util.isInteger(message.decCont))
                    return "decCont: integer expected";
            if (message.curProfitRatio != null && message.hasOwnProperty("curProfitRatio"))
                if (!$util.isString(message.curProfitRatio))
                    return "curProfitRatio: string expected";
            if (message.priority != null && message.hasOwnProperty("priority"))
                if (!$util.isInteger(message.priority))
                    return "priority: integer expected";
            if (message.endTs != null && message.hasOwnProperty("endTs"))
                if (!$util.isInteger(message.endTs) && !(message.endTs && $util.isInteger(message.endTs.low) && $util.isInteger(message.endTs.high)))
                    return "endTs: integer|Long expected";
            if (message.toCloseTrade != null && message.hasOwnProperty("toCloseTrade")) {
                let error = $root.st.Trade.verify(message.toCloseTrade);
                if (error)
                    return "toCloseTrade." + error;
            }
            return null;
        };

        /**
         * Creates a DecPositionAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.DecPositionAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.DecPositionAction} DecPositionAction
         */
        DecPositionAction.fromObject = function fromObject(object) {
            if (object instanceof $root.st.DecPositionAction)
                return object;
            let message = new $root.st.DecPositionAction();
            if (object.actionId != null)
                message.actionId = String(object.actionId);
            if (object.decCont != null)
                message.decCont = object.decCont >>> 0;
            if (object.curProfitRatio != null)
                message.curProfitRatio = String(object.curProfitRatio);
            if (object.priority != null)
                message.priority = object.priority >>> 0;
            if (object.endTs != null)
                if ($util.Long)
                    (message.endTs = $util.Long.fromValue(object.endTs)).unsigned = true;
                else if (typeof object.endTs === "string")
                    message.endTs = parseInt(object.endTs, 10);
                else if (typeof object.endTs === "number")
                    message.endTs = object.endTs;
                else if (typeof object.endTs === "object")
                    message.endTs = new $util.LongBits(object.endTs.low >>> 0, object.endTs.high >>> 0).toNumber(true);
            if (object.toCloseTrade != null) {
                if (typeof object.toCloseTrade !== "object")
                    throw TypeError(".st.DecPositionAction.toCloseTrade: object expected");
                message.toCloseTrade = $root.st.Trade.fromObject(object.toCloseTrade);
            }
            return message;
        };

        /**
         * Creates a plain object from a DecPositionAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.DecPositionAction
         * @static
         * @param {st.DecPositionAction} message DecPositionAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DecPositionAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.actionId = "";
                object.decCont = 0;
                object.curProfitRatio = "";
                object.priority = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.endTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endTs = options.longs === String ? "0" : 0;
                object.toCloseTrade = null;
            }
            if (message.actionId != null && message.hasOwnProperty("actionId"))
                object.actionId = message.actionId;
            if (message.decCont != null && message.hasOwnProperty("decCont"))
                object.decCont = message.decCont;
            if (message.curProfitRatio != null && message.hasOwnProperty("curProfitRatio"))
                object.curProfitRatio = message.curProfitRatio;
            if (message.priority != null && message.hasOwnProperty("priority"))
                object.priority = message.priority;
            if (message.endTs != null && message.hasOwnProperty("endTs"))
                if (typeof message.endTs === "number")
                    object.endTs = options.longs === String ? String(message.endTs) : message.endTs;
                else
                    object.endTs = options.longs === String ? $util.Long.prototype.toString.call(message.endTs) : options.longs === Number ? new $util.LongBits(message.endTs.low >>> 0, message.endTs.high >>> 0).toNumber(true) : message.endTs;
            if (message.toCloseTrade != null && message.hasOwnProperty("toCloseTrade"))
                object.toCloseTrade = $root.st.Trade.toObject(message.toCloseTrade, options);
            return object;
        };

        /**
         * Converts this DecPositionAction to JSON.
         * @function toJSON
         * @memberof st.DecPositionAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DecPositionAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DecPositionAction;
    })();

    st.OpenAction = (function() {

        /**
         * Properties of an OpenAction.
         * @memberof st
         * @interface IOpenAction
         * @property {string|null} [actionId] OpenAction actionId
         * @property {st.StrategyActionType|null} [actionType] OpenAction actionType
         * @property {st.ITrade|null} [toAddTrade] OpenAction toAddTrade
         */

        /**
         * Constructs a new OpenAction.
         * @memberof st
         * @classdesc Represents an OpenAction.
         * @implements IOpenAction
         * @constructor
         * @param {st.IOpenAction=} [properties] Properties to set
         */
        function OpenAction(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenAction actionId.
         * @member {string} actionId
         * @memberof st.OpenAction
         * @instance
         */
        OpenAction.prototype.actionId = "";

        /**
         * OpenAction actionType.
         * @member {st.StrategyActionType} actionType
         * @memberof st.OpenAction
         * @instance
         */
        OpenAction.prototype.actionType = 0;

        /**
         * OpenAction toAddTrade.
         * @member {st.ITrade|null|undefined} toAddTrade
         * @memberof st.OpenAction
         * @instance
         */
        OpenAction.prototype.toAddTrade = null;

        /**
         * Creates a new OpenAction instance using the specified properties.
         * @function create
         * @memberof st.OpenAction
         * @static
         * @param {st.IOpenAction=} [properties] Properties to set
         * @returns {st.OpenAction} OpenAction instance
         */
        OpenAction.create = function create(properties) {
            return new OpenAction(properties);
        };

        /**
         * Encodes the specified OpenAction message. Does not implicitly {@link st.OpenAction.verify|verify} messages.
         * @function encode
         * @memberof st.OpenAction
         * @static
         * @param {st.IOpenAction} message OpenAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actionId != null && Object.hasOwnProperty.call(message, "actionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionId);
            if (message.actionType != null && Object.hasOwnProperty.call(message, "actionType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.actionType);
            if (message.toAddTrade != null && Object.hasOwnProperty.call(message, "toAddTrade"))
                $root.st.Trade.encode(message.toAddTrade, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OpenAction message, length delimited. Does not implicitly {@link st.OpenAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.OpenAction
         * @static
         * @param {st.IOpenAction} message OpenAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenAction message from the specified reader or buffer.
         * @function decode
         * @memberof st.OpenAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.OpenAction} OpenAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.OpenAction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.actionId = reader.string();
                    break;
                case 2:
                    message.actionType = reader.int32();
                    break;
                case 3:
                    message.toAddTrade = $root.st.Trade.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.OpenAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.OpenAction} OpenAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenAction message.
         * @function verify
         * @memberof st.OpenAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actionId != null && message.hasOwnProperty("actionId"))
                if (!$util.isString(message.actionId))
                    return "actionId: string expected";
            if (message.actionType != null && message.hasOwnProperty("actionType"))
                switch (message.actionType) {
                default:
                    return "actionType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.toAddTrade != null && message.hasOwnProperty("toAddTrade")) {
                let error = $root.st.Trade.verify(message.toAddTrade);
                if (error)
                    return "toAddTrade." + error;
            }
            return null;
        };

        /**
         * Creates an OpenAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.OpenAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.OpenAction} OpenAction
         */
        OpenAction.fromObject = function fromObject(object) {
            if (object instanceof $root.st.OpenAction)
                return object;
            let message = new $root.st.OpenAction();
            if (object.actionId != null)
                message.actionId = String(object.actionId);
            switch (object.actionType) {
            case "DEFAULT_ACTION_TYPE":
            case 0:
                message.actionType = 0;
                break;
            case "KEEP":
            case 1:
                message.actionType = 1;
                break;
            case "CONTINUE_TRADE":
            case 2:
                message.actionType = 2;
                break;
            case "ADD":
            case 3:
                message.actionType = 3;
                break;
            case "STOP":
            case 4:
                message.actionType = 4;
                break;
            case "STOP_SOON":
            case 5:
                message.actionType = 5;
                break;
            case "DEC":
            case 6:
                message.actionType = 6;
                break;
            }
            if (object.toAddTrade != null) {
                if (typeof object.toAddTrade !== "object")
                    throw TypeError(".st.OpenAction.toAddTrade: object expected");
                message.toAddTrade = $root.st.Trade.fromObject(object.toAddTrade);
            }
            return message;
        };

        /**
         * Creates a plain object from an OpenAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.OpenAction
         * @static
         * @param {st.OpenAction} message OpenAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OpenAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.actionId = "";
                object.actionType = options.enums === String ? "DEFAULT_ACTION_TYPE" : 0;
                object.toAddTrade = null;
            }
            if (message.actionId != null && message.hasOwnProperty("actionId"))
                object.actionId = message.actionId;
            if (message.actionType != null && message.hasOwnProperty("actionType"))
                object.actionType = options.enums === String ? $root.st.StrategyActionType[message.actionType] : message.actionType;
            if (message.toAddTrade != null && message.hasOwnProperty("toAddTrade"))
                object.toAddTrade = $root.st.Trade.toObject(message.toAddTrade, options);
            return object;
        };

        /**
         * Converts this OpenAction to JSON.
         * @function toJSON
         * @memberof st.OpenAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OpenAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OpenAction;
    })();

    st.CloseAction = (function() {

        /**
         * Properties of a CloseAction.
         * @memberof st
         * @interface ICloseAction
         * @property {string|null} [actionId] CloseAction actionId
         * @property {st.StrategyActionType|null} [actionType] CloseAction actionType
         * @property {st.ITrade|null} [toCloseTrade] CloseAction toCloseTrade
         * @property {st.IPositionModifySignal|null} [signal] CloseAction signal
         */

        /**
         * Constructs a new CloseAction.
         * @memberof st
         * @classdesc Represents a CloseAction.
         * @implements ICloseAction
         * @constructor
         * @param {st.ICloseAction=} [properties] Properties to set
         */
        function CloseAction(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CloseAction actionId.
         * @member {string} actionId
         * @memberof st.CloseAction
         * @instance
         */
        CloseAction.prototype.actionId = "";

        /**
         * CloseAction actionType.
         * @member {st.StrategyActionType} actionType
         * @memberof st.CloseAction
         * @instance
         */
        CloseAction.prototype.actionType = 0;

        /**
         * CloseAction toCloseTrade.
         * @member {st.ITrade|null|undefined} toCloseTrade
         * @memberof st.CloseAction
         * @instance
         */
        CloseAction.prototype.toCloseTrade = null;

        /**
         * CloseAction signal.
         * @member {st.IPositionModifySignal|null|undefined} signal
         * @memberof st.CloseAction
         * @instance
         */
        CloseAction.prototype.signal = null;

        /**
         * Creates a new CloseAction instance using the specified properties.
         * @function create
         * @memberof st.CloseAction
         * @static
         * @param {st.ICloseAction=} [properties] Properties to set
         * @returns {st.CloseAction} CloseAction instance
         */
        CloseAction.create = function create(properties) {
            return new CloseAction(properties);
        };

        /**
         * Encodes the specified CloseAction message. Does not implicitly {@link st.CloseAction.verify|verify} messages.
         * @function encode
         * @memberof st.CloseAction
         * @static
         * @param {st.ICloseAction} message CloseAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actionId != null && Object.hasOwnProperty.call(message, "actionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionId);
            if (message.actionType != null && Object.hasOwnProperty.call(message, "actionType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.actionType);
            if (message.toCloseTrade != null && Object.hasOwnProperty.call(message, "toCloseTrade"))
                $root.st.Trade.encode(message.toCloseTrade, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.signal != null && Object.hasOwnProperty.call(message, "signal"))
                $root.st.PositionModifySignal.encode(message.signal, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CloseAction message, length delimited. Does not implicitly {@link st.CloseAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.CloseAction
         * @static
         * @param {st.ICloseAction} message CloseAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CloseAction message from the specified reader or buffer.
         * @function decode
         * @memberof st.CloseAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.CloseAction} CloseAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.CloseAction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.actionId = reader.string();
                    break;
                case 2:
                    message.actionType = reader.int32();
                    break;
                case 3:
                    message.toCloseTrade = $root.st.Trade.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.signal = $root.st.PositionModifySignal.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CloseAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.CloseAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.CloseAction} CloseAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CloseAction message.
         * @function verify
         * @memberof st.CloseAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CloseAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actionId != null && message.hasOwnProperty("actionId"))
                if (!$util.isString(message.actionId))
                    return "actionId: string expected";
            if (message.actionType != null && message.hasOwnProperty("actionType"))
                switch (message.actionType) {
                default:
                    return "actionType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.toCloseTrade != null && message.hasOwnProperty("toCloseTrade")) {
                let error = $root.st.Trade.verify(message.toCloseTrade);
                if (error)
                    return "toCloseTrade." + error;
            }
            if (message.signal != null && message.hasOwnProperty("signal")) {
                let error = $root.st.PositionModifySignal.verify(message.signal);
                if (error)
                    return "signal." + error;
            }
            return null;
        };

        /**
         * Creates a CloseAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.CloseAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.CloseAction} CloseAction
         */
        CloseAction.fromObject = function fromObject(object) {
            if (object instanceof $root.st.CloseAction)
                return object;
            let message = new $root.st.CloseAction();
            if (object.actionId != null)
                message.actionId = String(object.actionId);
            switch (object.actionType) {
            case "DEFAULT_ACTION_TYPE":
            case 0:
                message.actionType = 0;
                break;
            case "KEEP":
            case 1:
                message.actionType = 1;
                break;
            case "CONTINUE_TRADE":
            case 2:
                message.actionType = 2;
                break;
            case "ADD":
            case 3:
                message.actionType = 3;
                break;
            case "STOP":
            case 4:
                message.actionType = 4;
                break;
            case "STOP_SOON":
            case 5:
                message.actionType = 5;
                break;
            case "DEC":
            case 6:
                message.actionType = 6;
                break;
            }
            if (object.toCloseTrade != null) {
                if (typeof object.toCloseTrade !== "object")
                    throw TypeError(".st.CloseAction.toCloseTrade: object expected");
                message.toCloseTrade = $root.st.Trade.fromObject(object.toCloseTrade);
            }
            if (object.signal != null) {
                if (typeof object.signal !== "object")
                    throw TypeError(".st.CloseAction.signal: object expected");
                message.signal = $root.st.PositionModifySignal.fromObject(object.signal);
            }
            return message;
        };

        /**
         * Creates a plain object from a CloseAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.CloseAction
         * @static
         * @param {st.CloseAction} message CloseAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CloseAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.actionId = "";
                object.actionType = options.enums === String ? "DEFAULT_ACTION_TYPE" : 0;
                object.toCloseTrade = null;
                object.signal = null;
            }
            if (message.actionId != null && message.hasOwnProperty("actionId"))
                object.actionId = message.actionId;
            if (message.actionType != null && message.hasOwnProperty("actionType"))
                object.actionType = options.enums === String ? $root.st.StrategyActionType[message.actionType] : message.actionType;
            if (message.toCloseTrade != null && message.hasOwnProperty("toCloseTrade"))
                object.toCloseTrade = $root.st.Trade.toObject(message.toCloseTrade, options);
            if (message.signal != null && message.hasOwnProperty("signal"))
                object.signal = $root.st.PositionModifySignal.toObject(message.signal, options);
            return object;
        };

        /**
         * Converts this CloseAction to JSON.
         * @function toJSON
         * @memberof st.CloseAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CloseAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CloseAction;
    })();

    st.Action = (function() {

        /**
         * Properties of an Action.
         * @memberof st
         * @interface IAction
         * @property {string|null} [actionId] Action actionId
         * @property {st.StrategyActionType|null} [actionType] Action actionType
         * @property {string|null} [reason] Action reason
         * @property {st.IOpenAction|null} [openAction] Action openAction
         * @property {st.ICloseAction|null} [closeAction] Action closeAction
         * @property {st.IAddPositionAction|null} [addAction] Action addAction
         * @property {st.IDecPositionAction|null} [decAction] Action decAction
         * @property {st.IPositionModifySignal|null} [signal] Action signal
         * @property {string|null} [curProfitRatio] Action curProfitRatio
         */

        /**
         * Constructs a new Action.
         * @memberof st
         * @classdesc Represents an Action.
         * @implements IAction
         * @constructor
         * @param {st.IAction=} [properties] Properties to set
         */
        function Action(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Action actionId.
         * @member {string} actionId
         * @memberof st.Action
         * @instance
         */
        Action.prototype.actionId = "";

        /**
         * Action actionType.
         * @member {st.StrategyActionType} actionType
         * @memberof st.Action
         * @instance
         */
        Action.prototype.actionType = 0;

        /**
         * Action reason.
         * @member {string} reason
         * @memberof st.Action
         * @instance
         */
        Action.prototype.reason = "";

        /**
         * Action openAction.
         * @member {st.IOpenAction|null|undefined} openAction
         * @memberof st.Action
         * @instance
         */
        Action.prototype.openAction = null;

        /**
         * Action closeAction.
         * @member {st.ICloseAction|null|undefined} closeAction
         * @memberof st.Action
         * @instance
         */
        Action.prototype.closeAction = null;

        /**
         * Action addAction.
         * @member {st.IAddPositionAction|null|undefined} addAction
         * @memberof st.Action
         * @instance
         */
        Action.prototype.addAction = null;

        /**
         * Action decAction.
         * @member {st.IDecPositionAction|null|undefined} decAction
         * @memberof st.Action
         * @instance
         */
        Action.prototype.decAction = null;

        /**
         * Action signal.
         * @member {st.IPositionModifySignal|null|undefined} signal
         * @memberof st.Action
         * @instance
         */
        Action.prototype.signal = null;

        /**
         * Action curProfitRatio.
         * @member {string} curProfitRatio
         * @memberof st.Action
         * @instance
         */
        Action.prototype.curProfitRatio = "";

        /**
         * Creates a new Action instance using the specified properties.
         * @function create
         * @memberof st.Action
         * @static
         * @param {st.IAction=} [properties] Properties to set
         * @returns {st.Action} Action instance
         */
        Action.create = function create(properties) {
            return new Action(properties);
        };

        /**
         * Encodes the specified Action message. Does not implicitly {@link st.Action.verify|verify} messages.
         * @function encode
         * @memberof st.Action
         * @static
         * @param {st.IAction} message Action message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Action.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actionId != null && Object.hasOwnProperty.call(message, "actionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionId);
            if (message.actionType != null && Object.hasOwnProperty.call(message, "actionType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.actionType);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.reason);
            if (message.openAction != null && Object.hasOwnProperty.call(message, "openAction"))
                $root.st.OpenAction.encode(message.openAction, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.closeAction != null && Object.hasOwnProperty.call(message, "closeAction"))
                $root.st.CloseAction.encode(message.closeAction, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.addAction != null && Object.hasOwnProperty.call(message, "addAction"))
                $root.st.AddPositionAction.encode(message.addAction, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.decAction != null && Object.hasOwnProperty.call(message, "decAction"))
                $root.st.DecPositionAction.encode(message.decAction, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.signal != null && Object.hasOwnProperty.call(message, "signal"))
                $root.st.PositionModifySignal.encode(message.signal, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.curProfitRatio != null && Object.hasOwnProperty.call(message, "curProfitRatio"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.curProfitRatio);
            return writer;
        };

        /**
         * Encodes the specified Action message, length delimited. Does not implicitly {@link st.Action.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.Action
         * @static
         * @param {st.IAction} message Action message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Action.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Action message from the specified reader or buffer.
         * @function decode
         * @memberof st.Action
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.Action} Action
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Action.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.Action();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.actionId = reader.string();
                    break;
                case 2:
                    message.actionType = reader.int32();
                    break;
                case 3:
                    message.reason = reader.string();
                    break;
                case 4:
                    message.openAction = $root.st.OpenAction.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.closeAction = $root.st.CloseAction.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.addAction = $root.st.AddPositionAction.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.decAction = $root.st.DecPositionAction.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.signal = $root.st.PositionModifySignal.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.curProfitRatio = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Action message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.Action
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.Action} Action
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Action.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Action message.
         * @function verify
         * @memberof st.Action
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Action.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actionId != null && message.hasOwnProperty("actionId"))
                if (!$util.isString(message.actionId))
                    return "actionId: string expected";
            if (message.actionType != null && message.hasOwnProperty("actionType"))
                switch (message.actionType) {
                default:
                    return "actionType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            if (message.openAction != null && message.hasOwnProperty("openAction")) {
                let error = $root.st.OpenAction.verify(message.openAction);
                if (error)
                    return "openAction." + error;
            }
            if (message.closeAction != null && message.hasOwnProperty("closeAction")) {
                let error = $root.st.CloseAction.verify(message.closeAction);
                if (error)
                    return "closeAction." + error;
            }
            if (message.addAction != null && message.hasOwnProperty("addAction")) {
                let error = $root.st.AddPositionAction.verify(message.addAction);
                if (error)
                    return "addAction." + error;
            }
            if (message.decAction != null && message.hasOwnProperty("decAction")) {
                let error = $root.st.DecPositionAction.verify(message.decAction);
                if (error)
                    return "decAction." + error;
            }
            if (message.signal != null && message.hasOwnProperty("signal")) {
                let error = $root.st.PositionModifySignal.verify(message.signal);
                if (error)
                    return "signal." + error;
            }
            if (message.curProfitRatio != null && message.hasOwnProperty("curProfitRatio"))
                if (!$util.isString(message.curProfitRatio))
                    return "curProfitRatio: string expected";
            return null;
        };

        /**
         * Creates an Action message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.Action
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.Action} Action
         */
        Action.fromObject = function fromObject(object) {
            if (object instanceof $root.st.Action)
                return object;
            let message = new $root.st.Action();
            if (object.actionId != null)
                message.actionId = String(object.actionId);
            switch (object.actionType) {
            case "DEFAULT_ACTION_TYPE":
            case 0:
                message.actionType = 0;
                break;
            case "KEEP":
            case 1:
                message.actionType = 1;
                break;
            case "CONTINUE_TRADE":
            case 2:
                message.actionType = 2;
                break;
            case "ADD":
            case 3:
                message.actionType = 3;
                break;
            case "STOP":
            case 4:
                message.actionType = 4;
                break;
            case "STOP_SOON":
            case 5:
                message.actionType = 5;
                break;
            case "DEC":
            case 6:
                message.actionType = 6;
                break;
            }
            if (object.reason != null)
                message.reason = String(object.reason);
            if (object.openAction != null) {
                if (typeof object.openAction !== "object")
                    throw TypeError(".st.Action.openAction: object expected");
                message.openAction = $root.st.OpenAction.fromObject(object.openAction);
            }
            if (object.closeAction != null) {
                if (typeof object.closeAction !== "object")
                    throw TypeError(".st.Action.closeAction: object expected");
                message.closeAction = $root.st.CloseAction.fromObject(object.closeAction);
            }
            if (object.addAction != null) {
                if (typeof object.addAction !== "object")
                    throw TypeError(".st.Action.addAction: object expected");
                message.addAction = $root.st.AddPositionAction.fromObject(object.addAction);
            }
            if (object.decAction != null) {
                if (typeof object.decAction !== "object")
                    throw TypeError(".st.Action.decAction: object expected");
                message.decAction = $root.st.DecPositionAction.fromObject(object.decAction);
            }
            if (object.signal != null) {
                if (typeof object.signal !== "object")
                    throw TypeError(".st.Action.signal: object expected");
                message.signal = $root.st.PositionModifySignal.fromObject(object.signal);
            }
            if (object.curProfitRatio != null)
                message.curProfitRatio = String(object.curProfitRatio);
            return message;
        };

        /**
         * Creates a plain object from an Action message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.Action
         * @static
         * @param {st.Action} message Action
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Action.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.actionId = "";
                object.actionType = options.enums === String ? "DEFAULT_ACTION_TYPE" : 0;
                object.reason = "";
                object.openAction = null;
                object.closeAction = null;
                object.addAction = null;
                object.decAction = null;
                object.signal = null;
                object.curProfitRatio = "";
            }
            if (message.actionId != null && message.hasOwnProperty("actionId"))
                object.actionId = message.actionId;
            if (message.actionType != null && message.hasOwnProperty("actionType"))
                object.actionType = options.enums === String ? $root.st.StrategyActionType[message.actionType] : message.actionType;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.openAction != null && message.hasOwnProperty("openAction"))
                object.openAction = $root.st.OpenAction.toObject(message.openAction, options);
            if (message.closeAction != null && message.hasOwnProperty("closeAction"))
                object.closeAction = $root.st.CloseAction.toObject(message.closeAction, options);
            if (message.addAction != null && message.hasOwnProperty("addAction"))
                object.addAction = $root.st.AddPositionAction.toObject(message.addAction, options);
            if (message.decAction != null && message.hasOwnProperty("decAction"))
                object.decAction = $root.st.DecPositionAction.toObject(message.decAction, options);
            if (message.signal != null && message.hasOwnProperty("signal"))
                object.signal = $root.st.PositionModifySignal.toObject(message.signal, options);
            if (message.curProfitRatio != null && message.hasOwnProperty("curProfitRatio"))
                object.curProfitRatio = message.curProfitRatio;
            return object;
        };

        /**
         * Converts this Action to JSON.
         * @function toJSON
         * @memberof st.Action
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Action.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Action;
    })();

    st.FuturePlan = (function() {

        /**
         * Properties of a FuturePlan.
         * @memberof st
         * @interface IFuturePlan
         * @property {string|null} [planId] FuturePlan planId
         * @property {st.FutureOpenType|null} [openType] FuturePlan openType
         * @property {st.ICoinFuture|null} [coinFuture] FuturePlan coinFuture
         * @property {number|null} [planCont] FuturePlan planCont
         * @property {number|null} [dealCont] FuturePlan dealCont
         * @property {string|null} [planOpenPrice] FuturePlan planOpenPrice
         * @property {string|null} [dealOpenPrice] FuturePlan dealOpenPrice
         * @property {string|null} [planClosePrice] FuturePlan planClosePrice
         * @property {string|null} [dealClosePrice] FuturePlan dealClosePrice
         * @property {string|null} [planProfitRatio] FuturePlan planProfitRatio
         * @property {string|null} [openFee] FuturePlan openFee
         * @property {string|null} [closeFee] FuturePlan closeFee
         * @property {Array.<st.ITrade>|null} [openTradeList] FuturePlan openTradeList
         * @property {Array.<st.ITrade>|null} [closeTradeList] FuturePlan closeTradeList
         * @property {st.PlanState|null} [state] FuturePlan state
         * @property {number|null} [createTs] FuturePlan createTs
         * @property {number|null} [finishTs] FuturePlan finishTs
         * @property {number|null} [dataVersion] FuturePlan dataVersion
         * @property {string|null} [platform] FuturePlan platform
         * @property {string|null} [profit] FuturePlan profit
         * @property {Array.<st.IFundingRateSettle>|null} [settleList] FuturePlan settleList
         * @property {Array.<st.IAction>|null} [actionList] FuturePlan actionList
         * @property {number|null} [stillInOpenCont] FuturePlan stillInOpenCont
         * @property {number|null} [alreadyCloseCont] FuturePlan alreadyCloseCont
         * @property {Array.<string>|null} [signalList] FuturePlan signalList
         */

        /**
         * Constructs a new FuturePlan.
         * @memberof st
         * @classdesc Represents a FuturePlan.
         * @implements IFuturePlan
         * @constructor
         * @param {st.IFuturePlan=} [properties] Properties to set
         */
        function FuturePlan(properties) {
            this.openTradeList = [];
            this.closeTradeList = [];
            this.settleList = [];
            this.actionList = [];
            this.signalList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FuturePlan planId.
         * @member {string} planId
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.planId = "";

        /**
         * FuturePlan openType.
         * @member {st.FutureOpenType} openType
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.openType = 0;

        /**
         * FuturePlan coinFuture.
         * @member {st.ICoinFuture|null|undefined} coinFuture
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.coinFuture = null;

        /**
         * FuturePlan planCont.
         * @member {number} planCont
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.planCont = 0;

        /**
         * FuturePlan dealCont.
         * @member {number} dealCont
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.dealCont = 0;

        /**
         * FuturePlan planOpenPrice.
         * @member {string} planOpenPrice
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.planOpenPrice = "";

        /**
         * FuturePlan dealOpenPrice.
         * @member {string} dealOpenPrice
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.dealOpenPrice = "";

        /**
         * FuturePlan planClosePrice.
         * @member {string} planClosePrice
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.planClosePrice = "";

        /**
         * FuturePlan dealClosePrice.
         * @member {string} dealClosePrice
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.dealClosePrice = "";

        /**
         * FuturePlan planProfitRatio.
         * @member {string} planProfitRatio
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.planProfitRatio = "";

        /**
         * FuturePlan openFee.
         * @member {string} openFee
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.openFee = "";

        /**
         * FuturePlan closeFee.
         * @member {string} closeFee
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.closeFee = "";

        /**
         * FuturePlan openTradeList.
         * @member {Array.<st.ITrade>} openTradeList
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.openTradeList = $util.emptyArray;

        /**
         * FuturePlan closeTradeList.
         * @member {Array.<st.ITrade>} closeTradeList
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.closeTradeList = $util.emptyArray;

        /**
         * FuturePlan state.
         * @member {st.PlanState} state
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.state = 0;

        /**
         * FuturePlan createTs.
         * @member {number} createTs
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.createTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FuturePlan finishTs.
         * @member {number} finishTs
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.finishTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FuturePlan dataVersion.
         * @member {number} dataVersion
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.dataVersion = 0;

        /**
         * FuturePlan platform.
         * @member {string} platform
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.platform = "";

        /**
         * FuturePlan profit.
         * @member {string} profit
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.profit = "";

        /**
         * FuturePlan settleList.
         * @member {Array.<st.IFundingRateSettle>} settleList
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.settleList = $util.emptyArray;

        /**
         * FuturePlan actionList.
         * @member {Array.<st.IAction>} actionList
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.actionList = $util.emptyArray;

        /**
         * FuturePlan stillInOpenCont.
         * @member {number} stillInOpenCont
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.stillInOpenCont = 0;

        /**
         * FuturePlan alreadyCloseCont.
         * @member {number} alreadyCloseCont
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.alreadyCloseCont = 0;

        /**
         * FuturePlan signalList.
         * @member {Array.<string>} signalList
         * @memberof st.FuturePlan
         * @instance
         */
        FuturePlan.prototype.signalList = $util.emptyArray;

        /**
         * Creates a new FuturePlan instance using the specified properties.
         * @function create
         * @memberof st.FuturePlan
         * @static
         * @param {st.IFuturePlan=} [properties] Properties to set
         * @returns {st.FuturePlan} FuturePlan instance
         */
        FuturePlan.create = function create(properties) {
            return new FuturePlan(properties);
        };

        /**
         * Encodes the specified FuturePlan message. Does not implicitly {@link st.FuturePlan.verify|verify} messages.
         * @function encode
         * @memberof st.FuturePlan
         * @static
         * @param {st.IFuturePlan} message FuturePlan message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FuturePlan.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.planId != null && Object.hasOwnProperty.call(message, "planId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.planId);
            if (message.openType != null && Object.hasOwnProperty.call(message, "openType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.openType);
            if (message.coinFuture != null && Object.hasOwnProperty.call(message, "coinFuture"))
                $root.st.CoinFuture.encode(message.coinFuture, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.planCont != null && Object.hasOwnProperty.call(message, "planCont"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.planCont);
            if (message.dealCont != null && Object.hasOwnProperty.call(message, "dealCont"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.dealCont);
            if (message.planOpenPrice != null && Object.hasOwnProperty.call(message, "planOpenPrice"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.planOpenPrice);
            if (message.dealOpenPrice != null && Object.hasOwnProperty.call(message, "dealOpenPrice"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.dealOpenPrice);
            if (message.planClosePrice != null && Object.hasOwnProperty.call(message, "planClosePrice"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.planClosePrice);
            if (message.dealClosePrice != null && Object.hasOwnProperty.call(message, "dealClosePrice"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.dealClosePrice);
            if (message.planProfitRatio != null && Object.hasOwnProperty.call(message, "planProfitRatio"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.planProfitRatio);
            if (message.openFee != null && Object.hasOwnProperty.call(message, "openFee"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.openFee);
            if (message.closeFee != null && Object.hasOwnProperty.call(message, "closeFee"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.closeFee);
            if (message.openTradeList != null && message.openTradeList.length)
                for (let i = 0; i < message.openTradeList.length; ++i)
                    $root.st.Trade.encode(message.openTradeList[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.closeTradeList != null && message.closeTradeList.length)
                for (let i = 0; i < message.closeTradeList.length; ++i)
                    $root.st.Trade.encode(message.closeTradeList[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.state);
            if (message.createTs != null && Object.hasOwnProperty.call(message, "createTs"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.createTs);
            if (message.finishTs != null && Object.hasOwnProperty.call(message, "finishTs"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint64(message.finishTs);
            if (message.dataVersion != null && Object.hasOwnProperty.call(message, "dataVersion"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.dataVersion);
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.platform);
            if (message.profit != null && Object.hasOwnProperty.call(message, "profit"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.profit);
            if (message.settleList != null && message.settleList.length)
                for (let i = 0; i < message.settleList.length; ++i)
                    $root.st.FundingRateSettle.encode(message.settleList[i], writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.actionList != null && message.actionList.length)
                for (let i = 0; i < message.actionList.length; ++i)
                    $root.st.Action.encode(message.actionList[i], writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.stillInOpenCont != null && Object.hasOwnProperty.call(message, "stillInOpenCont"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.stillInOpenCont);
            if (message.alreadyCloseCont != null && Object.hasOwnProperty.call(message, "alreadyCloseCont"))
                writer.uint32(/* id 24, wireType 0 =*/192).uint32(message.alreadyCloseCont);
            if (message.signalList != null && message.signalList.length)
                for (let i = 0; i < message.signalList.length; ++i)
                    writer.uint32(/* id 25, wireType 2 =*/202).string(message.signalList[i]);
            return writer;
        };

        /**
         * Encodes the specified FuturePlan message, length delimited. Does not implicitly {@link st.FuturePlan.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.FuturePlan
         * @static
         * @param {st.IFuturePlan} message FuturePlan message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FuturePlan.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FuturePlan message from the specified reader or buffer.
         * @function decode
         * @memberof st.FuturePlan
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.FuturePlan} FuturePlan
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FuturePlan.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.FuturePlan();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.planId = reader.string();
                    break;
                case 2:
                    message.openType = reader.int32();
                    break;
                case 3:
                    message.coinFuture = $root.st.CoinFuture.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.planCont = reader.uint32();
                    break;
                case 5:
                    message.dealCont = reader.uint32();
                    break;
                case 6:
                    message.planOpenPrice = reader.string();
                    break;
                case 7:
                    message.dealOpenPrice = reader.string();
                    break;
                case 8:
                    message.planClosePrice = reader.string();
                    break;
                case 9:
                    message.dealClosePrice = reader.string();
                    break;
                case 10:
                    message.planProfitRatio = reader.string();
                    break;
                case 11:
                    message.openFee = reader.string();
                    break;
                case 12:
                    message.closeFee = reader.string();
                    break;
                case 13:
                    if (!(message.openTradeList && message.openTradeList.length))
                        message.openTradeList = [];
                    message.openTradeList.push($root.st.Trade.decode(reader, reader.uint32()));
                    break;
                case 14:
                    if (!(message.closeTradeList && message.closeTradeList.length))
                        message.closeTradeList = [];
                    message.closeTradeList.push($root.st.Trade.decode(reader, reader.uint32()));
                    break;
                case 15:
                    message.state = reader.int32();
                    break;
                case 16:
                    message.createTs = reader.uint64();
                    break;
                case 17:
                    message.finishTs = reader.uint64();
                    break;
                case 18:
                    message.dataVersion = reader.uint32();
                    break;
                case 19:
                    message.platform = reader.string();
                    break;
                case 20:
                    message.profit = reader.string();
                    break;
                case 21:
                    if (!(message.settleList && message.settleList.length))
                        message.settleList = [];
                    message.settleList.push($root.st.FundingRateSettle.decode(reader, reader.uint32()));
                    break;
                case 22:
                    if (!(message.actionList && message.actionList.length))
                        message.actionList = [];
                    message.actionList.push($root.st.Action.decode(reader, reader.uint32()));
                    break;
                case 23:
                    message.stillInOpenCont = reader.uint32();
                    break;
                case 24:
                    message.alreadyCloseCont = reader.uint32();
                    break;
                case 25:
                    if (!(message.signalList && message.signalList.length))
                        message.signalList = [];
                    message.signalList.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FuturePlan message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.FuturePlan
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.FuturePlan} FuturePlan
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FuturePlan.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FuturePlan message.
         * @function verify
         * @memberof st.FuturePlan
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FuturePlan.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.planId != null && message.hasOwnProperty("planId"))
                if (!$util.isString(message.planId))
                    return "planId: string expected";
            if (message.openType != null && message.hasOwnProperty("openType"))
                switch (message.openType) {
                default:
                    return "openType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.coinFuture != null && message.hasOwnProperty("coinFuture")) {
                let error = $root.st.CoinFuture.verify(message.coinFuture);
                if (error)
                    return "coinFuture." + error;
            }
            if (message.planCont != null && message.hasOwnProperty("planCont"))
                if (!$util.isInteger(message.planCont))
                    return "planCont: integer expected";
            if (message.dealCont != null && message.hasOwnProperty("dealCont"))
                if (!$util.isInteger(message.dealCont))
                    return "dealCont: integer expected";
            if (message.planOpenPrice != null && message.hasOwnProperty("planOpenPrice"))
                if (!$util.isString(message.planOpenPrice))
                    return "planOpenPrice: string expected";
            if (message.dealOpenPrice != null && message.hasOwnProperty("dealOpenPrice"))
                if (!$util.isString(message.dealOpenPrice))
                    return "dealOpenPrice: string expected";
            if (message.planClosePrice != null && message.hasOwnProperty("planClosePrice"))
                if (!$util.isString(message.planClosePrice))
                    return "planClosePrice: string expected";
            if (message.dealClosePrice != null && message.hasOwnProperty("dealClosePrice"))
                if (!$util.isString(message.dealClosePrice))
                    return "dealClosePrice: string expected";
            if (message.planProfitRatio != null && message.hasOwnProperty("planProfitRatio"))
                if (!$util.isString(message.planProfitRatio))
                    return "planProfitRatio: string expected";
            if (message.openFee != null && message.hasOwnProperty("openFee"))
                if (!$util.isString(message.openFee))
                    return "openFee: string expected";
            if (message.closeFee != null && message.hasOwnProperty("closeFee"))
                if (!$util.isString(message.closeFee))
                    return "closeFee: string expected";
            if (message.openTradeList != null && message.hasOwnProperty("openTradeList")) {
                if (!Array.isArray(message.openTradeList))
                    return "openTradeList: array expected";
                for (let i = 0; i < message.openTradeList.length; ++i) {
                    let error = $root.st.Trade.verify(message.openTradeList[i]);
                    if (error)
                        return "openTradeList." + error;
                }
            }
            if (message.closeTradeList != null && message.hasOwnProperty("closeTradeList")) {
                if (!Array.isArray(message.closeTradeList))
                    return "closeTradeList: array expected";
                for (let i = 0; i < message.closeTradeList.length; ++i) {
                    let error = $root.st.Trade.verify(message.closeTradeList[i]);
                    if (error)
                        return "closeTradeList." + error;
                }
            }
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.createTs != null && message.hasOwnProperty("createTs"))
                if (!$util.isInteger(message.createTs) && !(message.createTs && $util.isInteger(message.createTs.low) && $util.isInteger(message.createTs.high)))
                    return "createTs: integer|Long expected";
            if (message.finishTs != null && message.hasOwnProperty("finishTs"))
                if (!$util.isInteger(message.finishTs) && !(message.finishTs && $util.isInteger(message.finishTs.low) && $util.isInteger(message.finishTs.high)))
                    return "finishTs: integer|Long expected";
            if (message.dataVersion != null && message.hasOwnProperty("dataVersion"))
                if (!$util.isInteger(message.dataVersion))
                    return "dataVersion: integer expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                if (!$util.isString(message.platform))
                    return "platform: string expected";
            if (message.profit != null && message.hasOwnProperty("profit"))
                if (!$util.isString(message.profit))
                    return "profit: string expected";
            if (message.settleList != null && message.hasOwnProperty("settleList")) {
                if (!Array.isArray(message.settleList))
                    return "settleList: array expected";
                for (let i = 0; i < message.settleList.length; ++i) {
                    let error = $root.st.FundingRateSettle.verify(message.settleList[i]);
                    if (error)
                        return "settleList." + error;
                }
            }
            if (message.actionList != null && message.hasOwnProperty("actionList")) {
                if (!Array.isArray(message.actionList))
                    return "actionList: array expected";
                for (let i = 0; i < message.actionList.length; ++i) {
                    let error = $root.st.Action.verify(message.actionList[i]);
                    if (error)
                        return "actionList." + error;
                }
            }
            if (message.stillInOpenCont != null && message.hasOwnProperty("stillInOpenCont"))
                if (!$util.isInteger(message.stillInOpenCont))
                    return "stillInOpenCont: integer expected";
            if (message.alreadyCloseCont != null && message.hasOwnProperty("alreadyCloseCont"))
                if (!$util.isInteger(message.alreadyCloseCont))
                    return "alreadyCloseCont: integer expected";
            if (message.signalList != null && message.hasOwnProperty("signalList")) {
                if (!Array.isArray(message.signalList))
                    return "signalList: array expected";
                for (let i = 0; i < message.signalList.length; ++i)
                    if (!$util.isString(message.signalList[i]))
                        return "signalList: string[] expected";
            }
            return null;
        };

        /**
         * Creates a FuturePlan message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.FuturePlan
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.FuturePlan} FuturePlan
         */
        FuturePlan.fromObject = function fromObject(object) {
            if (object instanceof $root.st.FuturePlan)
                return object;
            let message = new $root.st.FuturePlan();
            if (object.planId != null)
                message.planId = String(object.planId);
            switch (object.openType) {
            case "DEFAULT_OPEN_TYPE":
            case 0:
                message.openType = 0;
                break;
            case "FUTURE_LONG":
            case 1:
                message.openType = 1;
                break;
            case "FUTURE_SHORT":
            case 2:
                message.openType = 2;
                break;
            }
            if (object.coinFuture != null) {
                if (typeof object.coinFuture !== "object")
                    throw TypeError(".st.FuturePlan.coinFuture: object expected");
                message.coinFuture = $root.st.CoinFuture.fromObject(object.coinFuture);
            }
            if (object.planCont != null)
                message.planCont = object.planCont >>> 0;
            if (object.dealCont != null)
                message.dealCont = object.dealCont >>> 0;
            if (object.planOpenPrice != null)
                message.planOpenPrice = String(object.planOpenPrice);
            if (object.dealOpenPrice != null)
                message.dealOpenPrice = String(object.dealOpenPrice);
            if (object.planClosePrice != null)
                message.planClosePrice = String(object.planClosePrice);
            if (object.dealClosePrice != null)
                message.dealClosePrice = String(object.dealClosePrice);
            if (object.planProfitRatio != null)
                message.planProfitRatio = String(object.planProfitRatio);
            if (object.openFee != null)
                message.openFee = String(object.openFee);
            if (object.closeFee != null)
                message.closeFee = String(object.closeFee);
            if (object.openTradeList) {
                if (!Array.isArray(object.openTradeList))
                    throw TypeError(".st.FuturePlan.openTradeList: array expected");
                message.openTradeList = [];
                for (let i = 0; i < object.openTradeList.length; ++i) {
                    if (typeof object.openTradeList[i] !== "object")
                        throw TypeError(".st.FuturePlan.openTradeList: object expected");
                    message.openTradeList[i] = $root.st.Trade.fromObject(object.openTradeList[i]);
                }
            }
            if (object.closeTradeList) {
                if (!Array.isArray(object.closeTradeList))
                    throw TypeError(".st.FuturePlan.closeTradeList: array expected");
                message.closeTradeList = [];
                for (let i = 0; i < object.closeTradeList.length; ++i) {
                    if (typeof object.closeTradeList[i] !== "object")
                        throw TypeError(".st.FuturePlan.closeTradeList: object expected");
                    message.closeTradeList[i] = $root.st.Trade.fromObject(object.closeTradeList[i]);
                }
            }
            switch (object.state) {
            case "DEFAULT_PLAN_STATE":
            case 0:
                message.state = 0;
                break;
            case "OPENING":
            case 1:
                message.state = 1;
                break;
            case "STOP_OPENING":
            case 2:
                message.state = 2;
                break;
            case "OPEN_FINISH":
            case 3:
                message.state = 3;
                break;
            case "CLOSING":
            case 4:
                message.state = 4;
                break;
            case "CLOSE_FINISH":
            case 5:
                message.state = 5;
                break;
            case "CANCELED":
            case 6:
                message.state = 6;
                break;
            case "QUICK_CLOSING":
            case 7:
                message.state = 7;
                break;
            case "FUNDING_RATE_RESUME":
            case 8:
                message.state = 8;
                break;
            case "FUNDING_RATE_RESTORE":
            case 9:
                message.state = 9;
                break;
            case "ADD_OPENING":
            case 10:
                message.state = 10;
                break;
            case "SUB_CLOSING":
            case 11:
                message.state = 11;
                break;
            }
            if (object.createTs != null)
                if ($util.Long)
                    (message.createTs = $util.Long.fromValue(object.createTs)).unsigned = true;
                else if (typeof object.createTs === "string")
                    message.createTs = parseInt(object.createTs, 10);
                else if (typeof object.createTs === "number")
                    message.createTs = object.createTs;
                else if (typeof object.createTs === "object")
                    message.createTs = new $util.LongBits(object.createTs.low >>> 0, object.createTs.high >>> 0).toNumber(true);
            if (object.finishTs != null)
                if ($util.Long)
                    (message.finishTs = $util.Long.fromValue(object.finishTs)).unsigned = true;
                else if (typeof object.finishTs === "string")
                    message.finishTs = parseInt(object.finishTs, 10);
                else if (typeof object.finishTs === "number")
                    message.finishTs = object.finishTs;
                else if (typeof object.finishTs === "object")
                    message.finishTs = new $util.LongBits(object.finishTs.low >>> 0, object.finishTs.high >>> 0).toNumber(true);
            if (object.dataVersion != null)
                message.dataVersion = object.dataVersion >>> 0;
            if (object.platform != null)
                message.platform = String(object.platform);
            if (object.profit != null)
                message.profit = String(object.profit);
            if (object.settleList) {
                if (!Array.isArray(object.settleList))
                    throw TypeError(".st.FuturePlan.settleList: array expected");
                message.settleList = [];
                for (let i = 0; i < object.settleList.length; ++i) {
                    if (typeof object.settleList[i] !== "object")
                        throw TypeError(".st.FuturePlan.settleList: object expected");
                    message.settleList[i] = $root.st.FundingRateSettle.fromObject(object.settleList[i]);
                }
            }
            if (object.actionList) {
                if (!Array.isArray(object.actionList))
                    throw TypeError(".st.FuturePlan.actionList: array expected");
                message.actionList = [];
                for (let i = 0; i < object.actionList.length; ++i) {
                    if (typeof object.actionList[i] !== "object")
                        throw TypeError(".st.FuturePlan.actionList: object expected");
                    message.actionList[i] = $root.st.Action.fromObject(object.actionList[i]);
                }
            }
            if (object.stillInOpenCont != null)
                message.stillInOpenCont = object.stillInOpenCont >>> 0;
            if (object.alreadyCloseCont != null)
                message.alreadyCloseCont = object.alreadyCloseCont >>> 0;
            if (object.signalList) {
                if (!Array.isArray(object.signalList))
                    throw TypeError(".st.FuturePlan.signalList: array expected");
                message.signalList = [];
                for (let i = 0; i < object.signalList.length; ++i)
                    message.signalList[i] = String(object.signalList[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a FuturePlan message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.FuturePlan
         * @static
         * @param {st.FuturePlan} message FuturePlan
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FuturePlan.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.openTradeList = [];
                object.closeTradeList = [];
                object.settleList = [];
                object.actionList = [];
                object.signalList = [];
            }
            if (options.defaults) {
                object.planId = "";
                object.openType = options.enums === String ? "DEFAULT_OPEN_TYPE" : 0;
                object.coinFuture = null;
                object.planCont = 0;
                object.dealCont = 0;
                object.planOpenPrice = "";
                object.dealOpenPrice = "";
                object.planClosePrice = "";
                object.dealClosePrice = "";
                object.planProfitRatio = "";
                object.openFee = "";
                object.closeFee = "";
                object.state = options.enums === String ? "DEFAULT_PLAN_STATE" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.createTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createTs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.finishTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.finishTs = options.longs === String ? "0" : 0;
                object.dataVersion = 0;
                object.platform = "";
                object.profit = "";
                object.stillInOpenCont = 0;
                object.alreadyCloseCont = 0;
            }
            if (message.planId != null && message.hasOwnProperty("planId"))
                object.planId = message.planId;
            if (message.openType != null && message.hasOwnProperty("openType"))
                object.openType = options.enums === String ? $root.st.FutureOpenType[message.openType] : message.openType;
            if (message.coinFuture != null && message.hasOwnProperty("coinFuture"))
                object.coinFuture = $root.st.CoinFuture.toObject(message.coinFuture, options);
            if (message.planCont != null && message.hasOwnProperty("planCont"))
                object.planCont = message.planCont;
            if (message.dealCont != null && message.hasOwnProperty("dealCont"))
                object.dealCont = message.dealCont;
            if (message.planOpenPrice != null && message.hasOwnProperty("planOpenPrice"))
                object.planOpenPrice = message.planOpenPrice;
            if (message.dealOpenPrice != null && message.hasOwnProperty("dealOpenPrice"))
                object.dealOpenPrice = message.dealOpenPrice;
            if (message.planClosePrice != null && message.hasOwnProperty("planClosePrice"))
                object.planClosePrice = message.planClosePrice;
            if (message.dealClosePrice != null && message.hasOwnProperty("dealClosePrice"))
                object.dealClosePrice = message.dealClosePrice;
            if (message.planProfitRatio != null && message.hasOwnProperty("planProfitRatio"))
                object.planProfitRatio = message.planProfitRatio;
            if (message.openFee != null && message.hasOwnProperty("openFee"))
                object.openFee = message.openFee;
            if (message.closeFee != null && message.hasOwnProperty("closeFee"))
                object.closeFee = message.closeFee;
            if (message.openTradeList && message.openTradeList.length) {
                object.openTradeList = [];
                for (let j = 0; j < message.openTradeList.length; ++j)
                    object.openTradeList[j] = $root.st.Trade.toObject(message.openTradeList[j], options);
            }
            if (message.closeTradeList && message.closeTradeList.length) {
                object.closeTradeList = [];
                for (let j = 0; j < message.closeTradeList.length; ++j)
                    object.closeTradeList[j] = $root.st.Trade.toObject(message.closeTradeList[j], options);
            }
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.st.PlanState[message.state] : message.state;
            if (message.createTs != null && message.hasOwnProperty("createTs"))
                if (typeof message.createTs === "number")
                    object.createTs = options.longs === String ? String(message.createTs) : message.createTs;
                else
                    object.createTs = options.longs === String ? $util.Long.prototype.toString.call(message.createTs) : options.longs === Number ? new $util.LongBits(message.createTs.low >>> 0, message.createTs.high >>> 0).toNumber(true) : message.createTs;
            if (message.finishTs != null && message.hasOwnProperty("finishTs"))
                if (typeof message.finishTs === "number")
                    object.finishTs = options.longs === String ? String(message.finishTs) : message.finishTs;
                else
                    object.finishTs = options.longs === String ? $util.Long.prototype.toString.call(message.finishTs) : options.longs === Number ? new $util.LongBits(message.finishTs.low >>> 0, message.finishTs.high >>> 0).toNumber(true) : message.finishTs;
            if (message.dataVersion != null && message.hasOwnProperty("dataVersion"))
                object.dataVersion = message.dataVersion;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = message.platform;
            if (message.profit != null && message.hasOwnProperty("profit"))
                object.profit = message.profit;
            if (message.settleList && message.settleList.length) {
                object.settleList = [];
                for (let j = 0; j < message.settleList.length; ++j)
                    object.settleList[j] = $root.st.FundingRateSettle.toObject(message.settleList[j], options);
            }
            if (message.actionList && message.actionList.length) {
                object.actionList = [];
                for (let j = 0; j < message.actionList.length; ++j)
                    object.actionList[j] = $root.st.Action.toObject(message.actionList[j], options);
            }
            if (message.stillInOpenCont != null && message.hasOwnProperty("stillInOpenCont"))
                object.stillInOpenCont = message.stillInOpenCont;
            if (message.alreadyCloseCont != null && message.hasOwnProperty("alreadyCloseCont"))
                object.alreadyCloseCont = message.alreadyCloseCont;
            if (message.signalList && message.signalList.length) {
                object.signalList = [];
                for (let j = 0; j < message.signalList.length; ++j)
                    object.signalList[j] = message.signalList[j];
            }
            return object;
        };

        /**
         * Converts this FuturePlan to JSON.
         * @function toJSON
         * @memberof st.FuturePlan
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FuturePlan.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FuturePlan;
    })();

    /**
     * TradeLogType enum.
     * @name st.TradeLogType
     * @enum {number}
     * @property {number} NORMAL_LOG=0 NORMAL_LOG value
     * @property {number} CREATE_TRADE=1 CREATE_TRADE value
     * @property {number} CANCEL_TRADE=2 CANCEL_TRADE value
     * @property {number} DEAL_TRADE=3 DEAL_TRADE value
     * @property {number} PLAN_OPEN=4 PLAN_OPEN value
     * @property {number} PLAN_OVER=5 PLAN_OVER value
     */
    st.TradeLogType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NORMAL_LOG"] = 0;
        values[valuesById[1] = "CREATE_TRADE"] = 1;
        values[valuesById[2] = "CANCEL_TRADE"] = 2;
        values[valuesById[3] = "DEAL_TRADE"] = 3;
        values[valuesById[4] = "PLAN_OPEN"] = 4;
        values[valuesById[5] = "PLAN_OVER"] = 5;
        return values;
    })();

    st.TradeLog = (function() {

        /**
         * Properties of a TradeLog.
         * @memberof st
         * @interface ITradeLog
         * @property {string|null} [id] TradeLog id
         * @property {string|null} [symbolId] TradeLog symbolId
         * @property {st.TradeLogType|null} [type] TradeLog type
         * @property {st.TradeSubState|null} [tradeSubState] TradeLog tradeSubState
         * @property {string|null} [info] TradeLog info
         * @property {number|null} [tsUsec] TradeLog tsUsec
         * @property {string|null} [date] TradeLog date
         * @property {string|null} [targetPrice] TradeLog targetPrice
         * @property {string|null} [dealPrice] TradeLog dealPrice
         * @property {string|null} [targetQty] TradeLog targetQty
         * @property {string|null} [dealQty] TradeLog dealQty
         * @property {string|null} [curProfit] TradeLog curProfit
         * @property {st.FutureOpenType|null} [futureOpenType] TradeLog futureOpenType
         * @property {st.TradeDir|null} [tradeDir] TradeLog tradeDir
         * @property {string|null} [accProfit] TradeLog accProfit
         */

        /**
         * Constructs a new TradeLog.
         * @memberof st
         * @classdesc Represents a TradeLog.
         * @implements ITradeLog
         * @constructor
         * @param {st.ITradeLog=} [properties] Properties to set
         */
        function TradeLog(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeLog id.
         * @member {string} id
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.id = "";

        /**
         * TradeLog symbolId.
         * @member {string} symbolId
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.symbolId = "";

        /**
         * TradeLog type.
         * @member {st.TradeLogType} type
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.type = 0;

        /**
         * TradeLog tradeSubState.
         * @member {st.TradeSubState} tradeSubState
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.tradeSubState = 0;

        /**
         * TradeLog info.
         * @member {string} info
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.info = "";

        /**
         * TradeLog tsUsec.
         * @member {number} tsUsec
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.tsUsec = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TradeLog date.
         * @member {string} date
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.date = "";

        /**
         * TradeLog targetPrice.
         * @member {string} targetPrice
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.targetPrice = "";

        /**
         * TradeLog dealPrice.
         * @member {string} dealPrice
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.dealPrice = "";

        /**
         * TradeLog targetQty.
         * @member {string} targetQty
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.targetQty = "";

        /**
         * TradeLog dealQty.
         * @member {string} dealQty
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.dealQty = "";

        /**
         * TradeLog curProfit.
         * @member {string} curProfit
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.curProfit = "";

        /**
         * TradeLog futureOpenType.
         * @member {st.FutureOpenType} futureOpenType
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.futureOpenType = 0;

        /**
         * TradeLog tradeDir.
         * @member {st.TradeDir} tradeDir
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.tradeDir = 0;

        /**
         * TradeLog accProfit.
         * @member {string} accProfit
         * @memberof st.TradeLog
         * @instance
         */
        TradeLog.prototype.accProfit = "";

        /**
         * Creates a new TradeLog instance using the specified properties.
         * @function create
         * @memberof st.TradeLog
         * @static
         * @param {st.ITradeLog=} [properties] Properties to set
         * @returns {st.TradeLog} TradeLog instance
         */
        TradeLog.create = function create(properties) {
            return new TradeLog(properties);
        };

        /**
         * Encodes the specified TradeLog message. Does not implicitly {@link st.TradeLog.verify|verify} messages.
         * @function encode
         * @memberof st.TradeLog
         * @static
         * @param {st.ITradeLog} message TradeLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.symbolId != null && Object.hasOwnProperty.call(message, "symbolId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbolId);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.tradeSubState != null && Object.hasOwnProperty.call(message, "tradeSubState"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.tradeSubState);
            if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.info);
            if (message.tsUsec != null && Object.hasOwnProperty.call(message, "tsUsec"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.tsUsec);
            if (message.date != null && Object.hasOwnProperty.call(message, "date"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.date);
            if (message.targetPrice != null && Object.hasOwnProperty.call(message, "targetPrice"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.targetPrice);
            if (message.dealPrice != null && Object.hasOwnProperty.call(message, "dealPrice"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.dealPrice);
            if (message.targetQty != null && Object.hasOwnProperty.call(message, "targetQty"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.targetQty);
            if (message.dealQty != null && Object.hasOwnProperty.call(message, "dealQty"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.dealQty);
            if (message.curProfit != null && Object.hasOwnProperty.call(message, "curProfit"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.curProfit);
            if (message.futureOpenType != null && Object.hasOwnProperty.call(message, "futureOpenType"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.futureOpenType);
            if (message.tradeDir != null && Object.hasOwnProperty.call(message, "tradeDir"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.tradeDir);
            if (message.accProfit != null && Object.hasOwnProperty.call(message, "accProfit"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.accProfit);
            return writer;
        };

        /**
         * Encodes the specified TradeLog message, length delimited. Does not implicitly {@link st.TradeLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.TradeLog
         * @static
         * @param {st.ITradeLog} message TradeLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeLog message from the specified reader or buffer.
         * @function decode
         * @memberof st.TradeLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.TradeLog} TradeLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.TradeLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.symbolId = reader.string();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.tradeSubState = reader.int32();
                    break;
                case 5:
                    message.info = reader.string();
                    break;
                case 6:
                    message.tsUsec = reader.uint64();
                    break;
                case 7:
                    message.date = reader.string();
                    break;
                case 8:
                    message.targetPrice = reader.string();
                    break;
                case 9:
                    message.dealPrice = reader.string();
                    break;
                case 10:
                    message.targetQty = reader.string();
                    break;
                case 11:
                    message.dealQty = reader.string();
                    break;
                case 12:
                    message.curProfit = reader.string();
                    break;
                case 13:
                    message.futureOpenType = reader.int32();
                    break;
                case 14:
                    message.tradeDir = reader.int32();
                    break;
                case 15:
                    message.accProfit = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TradeLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.TradeLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.TradeLog} TradeLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeLog message.
         * @function verify
         * @memberof st.TradeLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.symbolId != null && message.hasOwnProperty("symbolId"))
                if (!$util.isString(message.symbolId))
                    return "symbolId: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.tradeSubState != null && message.hasOwnProperty("tradeSubState"))
                switch (message.tradeSubState) {
                default:
                    return "tradeSubState: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    break;
                }
            if (message.info != null && message.hasOwnProperty("info"))
                if (!$util.isString(message.info))
                    return "info: string expected";
            if (message.tsUsec != null && message.hasOwnProperty("tsUsec"))
                if (!$util.isInteger(message.tsUsec) && !(message.tsUsec && $util.isInteger(message.tsUsec.low) && $util.isInteger(message.tsUsec.high)))
                    return "tsUsec: integer|Long expected";
            if (message.date != null && message.hasOwnProperty("date"))
                if (!$util.isString(message.date))
                    return "date: string expected";
            if (message.targetPrice != null && message.hasOwnProperty("targetPrice"))
                if (!$util.isString(message.targetPrice))
                    return "targetPrice: string expected";
            if (message.dealPrice != null && message.hasOwnProperty("dealPrice"))
                if (!$util.isString(message.dealPrice))
                    return "dealPrice: string expected";
            if (message.targetQty != null && message.hasOwnProperty("targetQty"))
                if (!$util.isString(message.targetQty))
                    return "targetQty: string expected";
            if (message.dealQty != null && message.hasOwnProperty("dealQty"))
                if (!$util.isString(message.dealQty))
                    return "dealQty: string expected";
            if (message.curProfit != null && message.hasOwnProperty("curProfit"))
                if (!$util.isString(message.curProfit))
                    return "curProfit: string expected";
            if (message.futureOpenType != null && message.hasOwnProperty("futureOpenType"))
                switch (message.futureOpenType) {
                default:
                    return "futureOpenType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.tradeDir != null && message.hasOwnProperty("tradeDir"))
                switch (message.tradeDir) {
                default:
                    return "tradeDir: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.accProfit != null && message.hasOwnProperty("accProfit"))
                if (!$util.isString(message.accProfit))
                    return "accProfit: string expected";
            return null;
        };

        /**
         * Creates a TradeLog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.TradeLog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.TradeLog} TradeLog
         */
        TradeLog.fromObject = function fromObject(object) {
            if (object instanceof $root.st.TradeLog)
                return object;
            let message = new $root.st.TradeLog();
            if (object.id != null)
                message.id = String(object.id);
            if (object.symbolId != null)
                message.symbolId = String(object.symbolId);
            switch (object.type) {
            case "NORMAL_LOG":
            case 0:
                message.type = 0;
                break;
            case "CREATE_TRADE":
            case 1:
                message.type = 1;
                break;
            case "CANCEL_TRADE":
            case 2:
                message.type = 2;
                break;
            case "DEAL_TRADE":
            case 3:
                message.type = 3;
                break;
            case "PLAN_OPEN":
            case 4:
                message.type = 4;
                break;
            case "PLAN_OVER":
            case 5:
                message.type = 5;
                break;
            }
            switch (object.tradeSubState) {
            case "DEFAULT_TRADE_SUB_STATE":
            case 0:
                message.tradeSubState = 0;
                break;
            case "TRADE_SUB_UNSUBMIT":
            case 1:
                message.tradeSubState = 1;
                break;
            case "TRADE_SUB_SUBMITTED":
            case 2:
                message.tradeSubState = 2;
                break;
            case "TRADE_SUB_PARTIAL_FILLED":
            case 3:
                message.tradeSubState = 3;
                break;
            case "TRADE_SUB_FULL_FILLED":
            case 4:
                message.tradeSubState = 4;
                break;
            case "TRADE_SUB_CANCELING":
            case 5:
                message.tradeSubState = 5;
                break;
            case "TRADE_SUB_CANCELED":
            case 6:
                message.tradeSubState = 6;
                break;
            case "TRADE_SUB_REJECTED":
            case 7:
                message.tradeSubState = 7;
                break;
            case "TRADE_SUB_EXECUTING":
            case 8:
                message.tradeSubState = 8;
                break;
            case "TRADE_TIMEOUT_CLOSED":
            case 9:
                message.tradeSubState = 9;
                break;
            }
            if (object.info != null)
                message.info = String(object.info);
            if (object.tsUsec != null)
                if ($util.Long)
                    (message.tsUsec = $util.Long.fromValue(object.tsUsec)).unsigned = true;
                else if (typeof object.tsUsec === "string")
                    message.tsUsec = parseInt(object.tsUsec, 10);
                else if (typeof object.tsUsec === "number")
                    message.tsUsec = object.tsUsec;
                else if (typeof object.tsUsec === "object")
                    message.tsUsec = new $util.LongBits(object.tsUsec.low >>> 0, object.tsUsec.high >>> 0).toNumber(true);
            if (object.date != null)
                message.date = String(object.date);
            if (object.targetPrice != null)
                message.targetPrice = String(object.targetPrice);
            if (object.dealPrice != null)
                message.dealPrice = String(object.dealPrice);
            if (object.targetQty != null)
                message.targetQty = String(object.targetQty);
            if (object.dealQty != null)
                message.dealQty = String(object.dealQty);
            if (object.curProfit != null)
                message.curProfit = String(object.curProfit);
            switch (object.futureOpenType) {
            case "DEFAULT_OPEN_TYPE":
            case 0:
                message.futureOpenType = 0;
                break;
            case "FUTURE_LONG":
            case 1:
                message.futureOpenType = 1;
                break;
            case "FUTURE_SHORT":
            case 2:
                message.futureOpenType = 2;
                break;
            }
            switch (object.tradeDir) {
            case "DEFAULT_TRADE_DIR":
            case 0:
                message.tradeDir = 0;
                break;
            case "BID":
            case 1:
                message.tradeDir = 1;
                break;
            case "ASK":
            case 2:
                message.tradeDir = 2;
                break;
            }
            if (object.accProfit != null)
                message.accProfit = String(object.accProfit);
            return message;
        };

        /**
         * Creates a plain object from a TradeLog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.TradeLog
         * @static
         * @param {st.TradeLog} message TradeLog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeLog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = "";
                object.symbolId = "";
                object.type = options.enums === String ? "NORMAL_LOG" : 0;
                object.tradeSubState = options.enums === String ? "DEFAULT_TRADE_SUB_STATE" : 0;
                object.info = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.tsUsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.tsUsec = options.longs === String ? "0" : 0;
                object.date = "";
                object.targetPrice = "";
                object.dealPrice = "";
                object.targetQty = "";
                object.dealQty = "";
                object.curProfit = "";
                object.futureOpenType = options.enums === String ? "DEFAULT_OPEN_TYPE" : 0;
                object.tradeDir = options.enums === String ? "DEFAULT_TRADE_DIR" : 0;
                object.accProfit = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.symbolId != null && message.hasOwnProperty("symbolId"))
                object.symbolId = message.symbolId;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.st.TradeLogType[message.type] : message.type;
            if (message.tradeSubState != null && message.hasOwnProperty("tradeSubState"))
                object.tradeSubState = options.enums === String ? $root.st.TradeSubState[message.tradeSubState] : message.tradeSubState;
            if (message.info != null && message.hasOwnProperty("info"))
                object.info = message.info;
            if (message.tsUsec != null && message.hasOwnProperty("tsUsec"))
                if (typeof message.tsUsec === "number")
                    object.tsUsec = options.longs === String ? String(message.tsUsec) : message.tsUsec;
                else
                    object.tsUsec = options.longs === String ? $util.Long.prototype.toString.call(message.tsUsec) : options.longs === Number ? new $util.LongBits(message.tsUsec.low >>> 0, message.tsUsec.high >>> 0).toNumber(true) : message.tsUsec;
            if (message.date != null && message.hasOwnProperty("date"))
                object.date = message.date;
            if (message.targetPrice != null && message.hasOwnProperty("targetPrice"))
                object.targetPrice = message.targetPrice;
            if (message.dealPrice != null && message.hasOwnProperty("dealPrice"))
                object.dealPrice = message.dealPrice;
            if (message.targetQty != null && message.hasOwnProperty("targetQty"))
                object.targetQty = message.targetQty;
            if (message.dealQty != null && message.hasOwnProperty("dealQty"))
                object.dealQty = message.dealQty;
            if (message.curProfit != null && message.hasOwnProperty("curProfit"))
                object.curProfit = message.curProfit;
            if (message.futureOpenType != null && message.hasOwnProperty("futureOpenType"))
                object.futureOpenType = options.enums === String ? $root.st.FutureOpenType[message.futureOpenType] : message.futureOpenType;
            if (message.tradeDir != null && message.hasOwnProperty("tradeDir"))
                object.tradeDir = options.enums === String ? $root.st.TradeDir[message.tradeDir] : message.tradeDir;
            if (message.accProfit != null && message.hasOwnProperty("accProfit"))
                object.accProfit = message.accProfit;
            return object;
        };

        /**
         * Converts this TradeLog to JSON.
         * @function toJSON
         * @memberof st.TradeLog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeLog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeLog;
    })();

    st.TradeSummary = (function() {

        /**
         * Properties of a TradeSummary.
         * @memberof st
         * @interface ITradeSummary
         * @property {string|null} [summaryId] TradeSummary summaryId
         * @property {string|null} [profit] TradeSummary profit
         * @property {Array.<string>|null} [releatedSymbolId] TradeSummary releatedSymbolId
         * @property {Array.<marketdata.IHistoryMarketDataIndex>|null} [dataIndex] TradeSummary dataIndex
         * @property {Array.<st.ITradeLog>|null} [logs] TradeSummary logs
         * @property {number|null} [totalCnt] TradeSummary totalCnt
         * @property {number|null} [successCnt] TradeSummary successCnt
         * @property {number|null} [successRatio] TradeSummary successRatio
         * @property {number|null} [avgProfit] TradeSummary avgProfit
         * @property {number|null} [avgLoss] TradeSummary avgLoss
         * @property {number|null} [profitLossRatio] TradeSummary profitLossRatio
         * @property {number|null} [startUsec] TradeSummary startUsec
         * @property {number|null} [endUsec] TradeSummary endUsec
         */

        /**
         * Constructs a new TradeSummary.
         * @memberof st
         * @classdesc Represents a TradeSummary.
         * @implements ITradeSummary
         * @constructor
         * @param {st.ITradeSummary=} [properties] Properties to set
         */
        function TradeSummary(properties) {
            this.releatedSymbolId = [];
            this.dataIndex = [];
            this.logs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeSummary summaryId.
         * @member {string} summaryId
         * @memberof st.TradeSummary
         * @instance
         */
        TradeSummary.prototype.summaryId = "";

        /**
         * TradeSummary profit.
         * @member {string} profit
         * @memberof st.TradeSummary
         * @instance
         */
        TradeSummary.prototype.profit = "";

        /**
         * TradeSummary releatedSymbolId.
         * @member {Array.<string>} releatedSymbolId
         * @memberof st.TradeSummary
         * @instance
         */
        TradeSummary.prototype.releatedSymbolId = $util.emptyArray;

        /**
         * TradeSummary dataIndex.
         * @member {Array.<marketdata.IHistoryMarketDataIndex>} dataIndex
         * @memberof st.TradeSummary
         * @instance
         */
        TradeSummary.prototype.dataIndex = $util.emptyArray;

        /**
         * TradeSummary logs.
         * @member {Array.<st.ITradeLog>} logs
         * @memberof st.TradeSummary
         * @instance
         */
        TradeSummary.prototype.logs = $util.emptyArray;

        /**
         * TradeSummary totalCnt.
         * @member {number} totalCnt
         * @memberof st.TradeSummary
         * @instance
         */
        TradeSummary.prototype.totalCnt = 0;

        /**
         * TradeSummary successCnt.
         * @member {number} successCnt
         * @memberof st.TradeSummary
         * @instance
         */
        TradeSummary.prototype.successCnt = 0;

        /**
         * TradeSummary successRatio.
         * @member {number} successRatio
         * @memberof st.TradeSummary
         * @instance
         */
        TradeSummary.prototype.successRatio = 0;

        /**
         * TradeSummary avgProfit.
         * @member {number} avgProfit
         * @memberof st.TradeSummary
         * @instance
         */
        TradeSummary.prototype.avgProfit = 0;

        /**
         * TradeSummary avgLoss.
         * @member {number} avgLoss
         * @memberof st.TradeSummary
         * @instance
         */
        TradeSummary.prototype.avgLoss = 0;

        /**
         * TradeSummary profitLossRatio.
         * @member {number} profitLossRatio
         * @memberof st.TradeSummary
         * @instance
         */
        TradeSummary.prototype.profitLossRatio = 0;

        /**
         * TradeSummary startUsec.
         * @member {number} startUsec
         * @memberof st.TradeSummary
         * @instance
         */
        TradeSummary.prototype.startUsec = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TradeSummary endUsec.
         * @member {number} endUsec
         * @memberof st.TradeSummary
         * @instance
         */
        TradeSummary.prototype.endUsec = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new TradeSummary instance using the specified properties.
         * @function create
         * @memberof st.TradeSummary
         * @static
         * @param {st.ITradeSummary=} [properties] Properties to set
         * @returns {st.TradeSummary} TradeSummary instance
         */
        TradeSummary.create = function create(properties) {
            return new TradeSummary(properties);
        };

        /**
         * Encodes the specified TradeSummary message. Does not implicitly {@link st.TradeSummary.verify|verify} messages.
         * @function encode
         * @memberof st.TradeSummary
         * @static
         * @param {st.ITradeSummary} message TradeSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeSummary.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.summaryId != null && Object.hasOwnProperty.call(message, "summaryId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.summaryId);
            if (message.profit != null && Object.hasOwnProperty.call(message, "profit"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.profit);
            if (message.releatedSymbolId != null && message.releatedSymbolId.length)
                for (let i = 0; i < message.releatedSymbolId.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.releatedSymbolId[i]);
            if (message.dataIndex != null && message.dataIndex.length)
                for (let i = 0; i < message.dataIndex.length; ++i)
                    $root.marketdata.HistoryMarketDataIndex.encode(message.dataIndex[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.logs != null && message.logs.length)
                for (let i = 0; i < message.logs.length; ++i)
                    $root.st.TradeLog.encode(message.logs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.totalCnt != null && Object.hasOwnProperty.call(message, "totalCnt"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.totalCnt);
            if (message.successCnt != null && Object.hasOwnProperty.call(message, "successCnt"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.successCnt);
            if (message.successRatio != null && Object.hasOwnProperty.call(message, "successRatio"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.successRatio);
            if (message.avgProfit != null && Object.hasOwnProperty.call(message, "avgProfit"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.avgProfit);
            if (message.avgLoss != null && Object.hasOwnProperty.call(message, "avgLoss"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.avgLoss);
            if (message.profitLossRatio != null && Object.hasOwnProperty.call(message, "profitLossRatio"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.profitLossRatio);
            if (message.startUsec != null && Object.hasOwnProperty.call(message, "startUsec"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.startUsec);
            if (message.endUsec != null && Object.hasOwnProperty.call(message, "endUsec"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.endUsec);
            return writer;
        };

        /**
         * Encodes the specified TradeSummary message, length delimited. Does not implicitly {@link st.TradeSummary.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.TradeSummary
         * @static
         * @param {st.ITradeSummary} message TradeSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeSummary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeSummary message from the specified reader or buffer.
         * @function decode
         * @memberof st.TradeSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.TradeSummary} TradeSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeSummary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.TradeSummary();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.summaryId = reader.string();
                    break;
                case 2:
                    message.profit = reader.string();
                    break;
                case 3:
                    if (!(message.releatedSymbolId && message.releatedSymbolId.length))
                        message.releatedSymbolId = [];
                    message.releatedSymbolId.push(reader.string());
                    break;
                case 4:
                    if (!(message.dataIndex && message.dataIndex.length))
                        message.dataIndex = [];
                    message.dataIndex.push($root.marketdata.HistoryMarketDataIndex.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.logs && message.logs.length))
                        message.logs = [];
                    message.logs.push($root.st.TradeLog.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.totalCnt = reader.uint32();
                    break;
                case 7:
                    message.successCnt = reader.uint32();
                    break;
                case 8:
                    message.successRatio = reader.double();
                    break;
                case 9:
                    message.avgProfit = reader.double();
                    break;
                case 10:
                    message.avgLoss = reader.double();
                    break;
                case 11:
                    message.profitLossRatio = reader.double();
                    break;
                case 12:
                    message.startUsec = reader.uint64();
                    break;
                case 13:
                    message.endUsec = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TradeSummary message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.TradeSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.TradeSummary} TradeSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeSummary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeSummary message.
         * @function verify
         * @memberof st.TradeSummary
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeSummary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.summaryId != null && message.hasOwnProperty("summaryId"))
                if (!$util.isString(message.summaryId))
                    return "summaryId: string expected";
            if (message.profit != null && message.hasOwnProperty("profit"))
                if (!$util.isString(message.profit))
                    return "profit: string expected";
            if (message.releatedSymbolId != null && message.hasOwnProperty("releatedSymbolId")) {
                if (!Array.isArray(message.releatedSymbolId))
                    return "releatedSymbolId: array expected";
                for (let i = 0; i < message.releatedSymbolId.length; ++i)
                    if (!$util.isString(message.releatedSymbolId[i]))
                        return "releatedSymbolId: string[] expected";
            }
            if (message.dataIndex != null && message.hasOwnProperty("dataIndex")) {
                if (!Array.isArray(message.dataIndex))
                    return "dataIndex: array expected";
                for (let i = 0; i < message.dataIndex.length; ++i) {
                    let error = $root.marketdata.HistoryMarketDataIndex.verify(message.dataIndex[i]);
                    if (error)
                        return "dataIndex." + error;
                }
            }
            if (message.logs != null && message.hasOwnProperty("logs")) {
                if (!Array.isArray(message.logs))
                    return "logs: array expected";
                for (let i = 0; i < message.logs.length; ++i) {
                    let error = $root.st.TradeLog.verify(message.logs[i]);
                    if (error)
                        return "logs." + error;
                }
            }
            if (message.totalCnt != null && message.hasOwnProperty("totalCnt"))
                if (!$util.isInteger(message.totalCnt))
                    return "totalCnt: integer expected";
            if (message.successCnt != null && message.hasOwnProperty("successCnt"))
                if (!$util.isInteger(message.successCnt))
                    return "successCnt: integer expected";
            if (message.successRatio != null && message.hasOwnProperty("successRatio"))
                if (typeof message.successRatio !== "number")
                    return "successRatio: number expected";
            if (message.avgProfit != null && message.hasOwnProperty("avgProfit"))
                if (typeof message.avgProfit !== "number")
                    return "avgProfit: number expected";
            if (message.avgLoss != null && message.hasOwnProperty("avgLoss"))
                if (typeof message.avgLoss !== "number")
                    return "avgLoss: number expected";
            if (message.profitLossRatio != null && message.hasOwnProperty("profitLossRatio"))
                if (typeof message.profitLossRatio !== "number")
                    return "profitLossRatio: number expected";
            if (message.startUsec != null && message.hasOwnProperty("startUsec"))
                if (!$util.isInteger(message.startUsec) && !(message.startUsec && $util.isInteger(message.startUsec.low) && $util.isInteger(message.startUsec.high)))
                    return "startUsec: integer|Long expected";
            if (message.endUsec != null && message.hasOwnProperty("endUsec"))
                if (!$util.isInteger(message.endUsec) && !(message.endUsec && $util.isInteger(message.endUsec.low) && $util.isInteger(message.endUsec.high)))
                    return "endUsec: integer|Long expected";
            return null;
        };

        /**
         * Creates a TradeSummary message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.TradeSummary
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.TradeSummary} TradeSummary
         */
        TradeSummary.fromObject = function fromObject(object) {
            if (object instanceof $root.st.TradeSummary)
                return object;
            let message = new $root.st.TradeSummary();
            if (object.summaryId != null)
                message.summaryId = String(object.summaryId);
            if (object.profit != null)
                message.profit = String(object.profit);
            if (object.releatedSymbolId) {
                if (!Array.isArray(object.releatedSymbolId))
                    throw TypeError(".st.TradeSummary.releatedSymbolId: array expected");
                message.releatedSymbolId = [];
                for (let i = 0; i < object.releatedSymbolId.length; ++i)
                    message.releatedSymbolId[i] = String(object.releatedSymbolId[i]);
            }
            if (object.dataIndex) {
                if (!Array.isArray(object.dataIndex))
                    throw TypeError(".st.TradeSummary.dataIndex: array expected");
                message.dataIndex = [];
                for (let i = 0; i < object.dataIndex.length; ++i) {
                    if (typeof object.dataIndex[i] !== "object")
                        throw TypeError(".st.TradeSummary.dataIndex: object expected");
                    message.dataIndex[i] = $root.marketdata.HistoryMarketDataIndex.fromObject(object.dataIndex[i]);
                }
            }
            if (object.logs) {
                if (!Array.isArray(object.logs))
                    throw TypeError(".st.TradeSummary.logs: array expected");
                message.logs = [];
                for (let i = 0; i < object.logs.length; ++i) {
                    if (typeof object.logs[i] !== "object")
                        throw TypeError(".st.TradeSummary.logs: object expected");
                    message.logs[i] = $root.st.TradeLog.fromObject(object.logs[i]);
                }
            }
            if (object.totalCnt != null)
                message.totalCnt = object.totalCnt >>> 0;
            if (object.successCnt != null)
                message.successCnt = object.successCnt >>> 0;
            if (object.successRatio != null)
                message.successRatio = Number(object.successRatio);
            if (object.avgProfit != null)
                message.avgProfit = Number(object.avgProfit);
            if (object.avgLoss != null)
                message.avgLoss = Number(object.avgLoss);
            if (object.profitLossRatio != null)
                message.profitLossRatio = Number(object.profitLossRatio);
            if (object.startUsec != null)
                if ($util.Long)
                    (message.startUsec = $util.Long.fromValue(object.startUsec)).unsigned = true;
                else if (typeof object.startUsec === "string")
                    message.startUsec = parseInt(object.startUsec, 10);
                else if (typeof object.startUsec === "number")
                    message.startUsec = object.startUsec;
                else if (typeof object.startUsec === "object")
                    message.startUsec = new $util.LongBits(object.startUsec.low >>> 0, object.startUsec.high >>> 0).toNumber(true);
            if (object.endUsec != null)
                if ($util.Long)
                    (message.endUsec = $util.Long.fromValue(object.endUsec)).unsigned = true;
                else if (typeof object.endUsec === "string")
                    message.endUsec = parseInt(object.endUsec, 10);
                else if (typeof object.endUsec === "number")
                    message.endUsec = object.endUsec;
                else if (typeof object.endUsec === "object")
                    message.endUsec = new $util.LongBits(object.endUsec.low >>> 0, object.endUsec.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a TradeSummary message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.TradeSummary
         * @static
         * @param {st.TradeSummary} message TradeSummary
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeSummary.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.releatedSymbolId = [];
                object.dataIndex = [];
                object.logs = [];
            }
            if (options.defaults) {
                object.summaryId = "";
                object.profit = "";
                object.totalCnt = 0;
                object.successCnt = 0;
                object.successRatio = 0;
                object.avgProfit = 0;
                object.avgLoss = 0;
                object.profitLossRatio = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.startUsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startUsec = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.endUsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endUsec = options.longs === String ? "0" : 0;
            }
            if (message.summaryId != null && message.hasOwnProperty("summaryId"))
                object.summaryId = message.summaryId;
            if (message.profit != null && message.hasOwnProperty("profit"))
                object.profit = message.profit;
            if (message.releatedSymbolId && message.releatedSymbolId.length) {
                object.releatedSymbolId = [];
                for (let j = 0; j < message.releatedSymbolId.length; ++j)
                    object.releatedSymbolId[j] = message.releatedSymbolId[j];
            }
            if (message.dataIndex && message.dataIndex.length) {
                object.dataIndex = [];
                for (let j = 0; j < message.dataIndex.length; ++j)
                    object.dataIndex[j] = $root.marketdata.HistoryMarketDataIndex.toObject(message.dataIndex[j], options);
            }
            if (message.logs && message.logs.length) {
                object.logs = [];
                for (let j = 0; j < message.logs.length; ++j)
                    object.logs[j] = $root.st.TradeLog.toObject(message.logs[j], options);
            }
            if (message.totalCnt != null && message.hasOwnProperty("totalCnt"))
                object.totalCnt = message.totalCnt;
            if (message.successCnt != null && message.hasOwnProperty("successCnt"))
                object.successCnt = message.successCnt;
            if (message.successRatio != null && message.hasOwnProperty("successRatio"))
                object.successRatio = options.json && !isFinite(message.successRatio) ? String(message.successRatio) : message.successRatio;
            if (message.avgProfit != null && message.hasOwnProperty("avgProfit"))
                object.avgProfit = options.json && !isFinite(message.avgProfit) ? String(message.avgProfit) : message.avgProfit;
            if (message.avgLoss != null && message.hasOwnProperty("avgLoss"))
                object.avgLoss = options.json && !isFinite(message.avgLoss) ? String(message.avgLoss) : message.avgLoss;
            if (message.profitLossRatio != null && message.hasOwnProperty("profitLossRatio"))
                object.profitLossRatio = options.json && !isFinite(message.profitLossRatio) ? String(message.profitLossRatio) : message.profitLossRatio;
            if (message.startUsec != null && message.hasOwnProperty("startUsec"))
                if (typeof message.startUsec === "number")
                    object.startUsec = options.longs === String ? String(message.startUsec) : message.startUsec;
                else
                    object.startUsec = options.longs === String ? $util.Long.prototype.toString.call(message.startUsec) : options.longs === Number ? new $util.LongBits(message.startUsec.low >>> 0, message.startUsec.high >>> 0).toNumber(true) : message.startUsec;
            if (message.endUsec != null && message.hasOwnProperty("endUsec"))
                if (typeof message.endUsec === "number")
                    object.endUsec = options.longs === String ? String(message.endUsec) : message.endUsec;
                else
                    object.endUsec = options.longs === String ? $util.Long.prototype.toString.call(message.endUsec) : options.longs === Number ? new $util.LongBits(message.endUsec.low >>> 0, message.endUsec.high >>> 0).toNumber(true) : message.endUsec;
            return object;
        };

        /**
         * Converts this TradeSummary to JSON.
         * @function toJSON
         * @memberof st.TradeSummary
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeSummary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeSummary;
    })();

    st.TradeMeta = (function() {

        /**
         * Properties of a TradeMeta.
         * @memberof st
         * @interface ITradeMeta
         * @property {string|null} [ticker] TradeMeta ticker
         * @property {string|null} [summaryId] TradeMeta summaryId
         * @property {string|null} [symbolInfo] TradeMeta symbolInfo
         */

        /**
         * Constructs a new TradeMeta.
         * @memberof st
         * @classdesc Represents a TradeMeta.
         * @implements ITradeMeta
         * @constructor
         * @param {st.ITradeMeta=} [properties] Properties to set
         */
        function TradeMeta(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeMeta ticker.
         * @member {string} ticker
         * @memberof st.TradeMeta
         * @instance
         */
        TradeMeta.prototype.ticker = "";

        /**
         * TradeMeta summaryId.
         * @member {string} summaryId
         * @memberof st.TradeMeta
         * @instance
         */
        TradeMeta.prototype.summaryId = "";

        /**
         * TradeMeta symbolInfo.
         * @member {string} symbolInfo
         * @memberof st.TradeMeta
         * @instance
         */
        TradeMeta.prototype.symbolInfo = "";

        /**
         * Creates a new TradeMeta instance using the specified properties.
         * @function create
         * @memberof st.TradeMeta
         * @static
         * @param {st.ITradeMeta=} [properties] Properties to set
         * @returns {st.TradeMeta} TradeMeta instance
         */
        TradeMeta.create = function create(properties) {
            return new TradeMeta(properties);
        };

        /**
         * Encodes the specified TradeMeta message. Does not implicitly {@link st.TradeMeta.verify|verify} messages.
         * @function encode
         * @memberof st.TradeMeta
         * @static
         * @param {st.ITradeMeta} message TradeMeta message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeMeta.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ticker != null && Object.hasOwnProperty.call(message, "ticker"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ticker);
            if (message.summaryId != null && Object.hasOwnProperty.call(message, "summaryId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.summaryId);
            if (message.symbolInfo != null && Object.hasOwnProperty.call(message, "symbolInfo"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.symbolInfo);
            return writer;
        };

        /**
         * Encodes the specified TradeMeta message, length delimited. Does not implicitly {@link st.TradeMeta.verify|verify} messages.
         * @function encodeDelimited
         * @memberof st.TradeMeta
         * @static
         * @param {st.ITradeMeta} message TradeMeta message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeMeta.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeMeta message from the specified reader or buffer.
         * @function decode
         * @memberof st.TradeMeta
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {st.TradeMeta} TradeMeta
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeMeta.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.st.TradeMeta();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ticker = reader.string();
                    break;
                case 2:
                    message.summaryId = reader.string();
                    break;
                case 3:
                    message.symbolInfo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TradeMeta message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof st.TradeMeta
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {st.TradeMeta} TradeMeta
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeMeta.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeMeta message.
         * @function verify
         * @memberof st.TradeMeta
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeMeta.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                if (!$util.isString(message.ticker))
                    return "ticker: string expected";
            if (message.summaryId != null && message.hasOwnProperty("summaryId"))
                if (!$util.isString(message.summaryId))
                    return "summaryId: string expected";
            if (message.symbolInfo != null && message.hasOwnProperty("symbolInfo"))
                if (!$util.isString(message.symbolInfo))
                    return "symbolInfo: string expected";
            return null;
        };

        /**
         * Creates a TradeMeta message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof st.TradeMeta
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {st.TradeMeta} TradeMeta
         */
        TradeMeta.fromObject = function fromObject(object) {
            if (object instanceof $root.st.TradeMeta)
                return object;
            let message = new $root.st.TradeMeta();
            if (object.ticker != null)
                message.ticker = String(object.ticker);
            if (object.summaryId != null)
                message.summaryId = String(object.summaryId);
            if (object.symbolInfo != null)
                message.symbolInfo = String(object.symbolInfo);
            return message;
        };

        /**
         * Creates a plain object from a TradeMeta message. Also converts values to other types if specified.
         * @function toObject
         * @memberof st.TradeMeta
         * @static
         * @param {st.TradeMeta} message TradeMeta
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeMeta.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.ticker = "";
                object.summaryId = "";
                object.symbolInfo = "";
            }
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                object.ticker = message.ticker;
            if (message.summaryId != null && message.hasOwnProperty("summaryId"))
                object.summaryId = message.summaryId;
            if (message.symbolInfo != null && message.hasOwnProperty("symbolInfo"))
                object.symbolInfo = message.symbolInfo;
            return object;
        };

        /**
         * Converts this TradeMeta to JSON.
         * @function toJSON
         * @memberof st.TradeMeta
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeMeta.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeMeta;
    })();

    return st;
})();

export const strategyparameter = $root.strategyparameter = (() => {

    /**
     * Namespace strategyparameter.
     * @exports strategyparameter
     * @namespace
     */
    const strategyparameter = {};

    strategyparameter.RapidTradeTriggerParameter = (function() {

        /**
         * Properties of a RapidTradeTriggerParameter.
         * @memberof strategyparameter
         * @interface IRapidTradeTriggerParameter
         * @property {st.ICoinFuture|null} [future] RapidTradeTriggerParameter future
         * @property {string|null} [preKlineDownBdTh] RapidTradeTriggerParameter preKlineDownBdTh
         * @property {string|null} [curKlineUpBdTh] RapidTradeTriggerParameter curKlineUpBdTh
         * @property {string|null} [preKlineUpBuTh] RapidTradeTriggerParameter preKlineUpBuTh
         * @property {string|null} [curKlineDownBuTh] RapidTradeTriggerParameter curKlineDownBuTh
         * @property {number|null} [baseCont] RapidTradeTriggerParameter baseCont
         * @property {string|null} [targetProfitRatio] RapidTradeTriggerParameter targetProfitRatio
         * @property {string|null} [rsiExceedBidTh] RapidTradeTriggerParameter rsiExceedBidTh
         * @property {string|null} [rsiExceedAskTh] RapidTradeTriggerParameter rsiExceedAskTh
         * @property {string|null} [beginCloseProfitRatio] RapidTradeTriggerParameter beginCloseProfitRatio
         * @property {string|null} [canAddLossProfitRatio] RapidTradeTriggerParameter canAddLossProfitRatio
         * @property {number|null} [maxOpenCont] RapidTradeTriggerParameter maxOpenCont
         * @property {number|null} [decWaitInterval] RapidTradeTriggerParameter decWaitInterval
         * @property {number|null} [addWaitInterval] RapidTradeTriggerParameter addWaitInterval
         * @property {number|null} [beginDecInterval] RapidTradeTriggerParameter beginDecInterval
         * @property {string|null} [canDecLossProfitRatio] RapidTradeTriggerParameter canDecLossProfitRatio
         * @property {string|null} [shouldQuickCloseRatio] RapidTradeTriggerParameter shouldQuickCloseRatio
         */

        /**
         * Constructs a new RapidTradeTriggerParameter.
         * @memberof strategyparameter
         * @classdesc Represents a RapidTradeTriggerParameter.
         * @implements IRapidTradeTriggerParameter
         * @constructor
         * @param {strategyparameter.IRapidTradeTriggerParameter=} [properties] Properties to set
         */
        function RapidTradeTriggerParameter(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RapidTradeTriggerParameter future.
         * @member {st.ICoinFuture|null|undefined} future
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.future = null;

        /**
         * RapidTradeTriggerParameter preKlineDownBdTh.
         * @member {string} preKlineDownBdTh
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.preKlineDownBdTh = "";

        /**
         * RapidTradeTriggerParameter curKlineUpBdTh.
         * @member {string} curKlineUpBdTh
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.curKlineUpBdTh = "";

        /**
         * RapidTradeTriggerParameter preKlineUpBuTh.
         * @member {string} preKlineUpBuTh
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.preKlineUpBuTh = "";

        /**
         * RapidTradeTriggerParameter curKlineDownBuTh.
         * @member {string} curKlineDownBuTh
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.curKlineDownBuTh = "";

        /**
         * RapidTradeTriggerParameter baseCont.
         * @member {number} baseCont
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.baseCont = 0;

        /**
         * RapidTradeTriggerParameter targetProfitRatio.
         * @member {string} targetProfitRatio
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.targetProfitRatio = "";

        /**
         * RapidTradeTriggerParameter rsiExceedBidTh.
         * @member {string} rsiExceedBidTh
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.rsiExceedBidTh = "";

        /**
         * RapidTradeTriggerParameter rsiExceedAskTh.
         * @member {string} rsiExceedAskTh
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.rsiExceedAskTh = "";

        /**
         * RapidTradeTriggerParameter beginCloseProfitRatio.
         * @member {string} beginCloseProfitRatio
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.beginCloseProfitRatio = "";

        /**
         * RapidTradeTriggerParameter canAddLossProfitRatio.
         * @member {string} canAddLossProfitRatio
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.canAddLossProfitRatio = "";

        /**
         * RapidTradeTriggerParameter maxOpenCont.
         * @member {number} maxOpenCont
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.maxOpenCont = 0;

        /**
         * RapidTradeTriggerParameter decWaitInterval.
         * @member {number} decWaitInterval
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.decWaitInterval = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RapidTradeTriggerParameter addWaitInterval.
         * @member {number} addWaitInterval
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.addWaitInterval = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RapidTradeTriggerParameter beginDecInterval.
         * @member {number} beginDecInterval
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.beginDecInterval = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RapidTradeTriggerParameter canDecLossProfitRatio.
         * @member {string} canDecLossProfitRatio
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.canDecLossProfitRatio = "";

        /**
         * RapidTradeTriggerParameter shouldQuickCloseRatio.
         * @member {string} shouldQuickCloseRatio
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         */
        RapidTradeTriggerParameter.prototype.shouldQuickCloseRatio = "";

        /**
         * Creates a new RapidTradeTriggerParameter instance using the specified properties.
         * @function create
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @static
         * @param {strategyparameter.IRapidTradeTriggerParameter=} [properties] Properties to set
         * @returns {strategyparameter.RapidTradeTriggerParameter} RapidTradeTriggerParameter instance
         */
        RapidTradeTriggerParameter.create = function create(properties) {
            return new RapidTradeTriggerParameter(properties);
        };

        /**
         * Encodes the specified RapidTradeTriggerParameter message. Does not implicitly {@link strategyparameter.RapidTradeTriggerParameter.verify|verify} messages.
         * @function encode
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @static
         * @param {strategyparameter.IRapidTradeTriggerParameter} message RapidTradeTriggerParameter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RapidTradeTriggerParameter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.future != null && Object.hasOwnProperty.call(message, "future"))
                $root.st.CoinFuture.encode(message.future, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.preKlineDownBdTh != null && Object.hasOwnProperty.call(message, "preKlineDownBdTh"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.preKlineDownBdTh);
            if (message.curKlineUpBdTh != null && Object.hasOwnProperty.call(message, "curKlineUpBdTh"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.curKlineUpBdTh);
            if (message.preKlineUpBuTh != null && Object.hasOwnProperty.call(message, "preKlineUpBuTh"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.preKlineUpBuTh);
            if (message.curKlineDownBuTh != null && Object.hasOwnProperty.call(message, "curKlineDownBuTh"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.curKlineDownBuTh);
            if (message.baseCont != null && Object.hasOwnProperty.call(message, "baseCont"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.baseCont);
            if (message.targetProfitRatio != null && Object.hasOwnProperty.call(message, "targetProfitRatio"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.targetProfitRatio);
            if (message.rsiExceedBidTh != null && Object.hasOwnProperty.call(message, "rsiExceedBidTh"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.rsiExceedBidTh);
            if (message.rsiExceedAskTh != null && Object.hasOwnProperty.call(message, "rsiExceedAskTh"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.rsiExceedAskTh);
            if (message.beginCloseProfitRatio != null && Object.hasOwnProperty.call(message, "beginCloseProfitRatio"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.beginCloseProfitRatio);
            if (message.canAddLossProfitRatio != null && Object.hasOwnProperty.call(message, "canAddLossProfitRatio"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.canAddLossProfitRatio);
            if (message.maxOpenCont != null && Object.hasOwnProperty.call(message, "maxOpenCont"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.maxOpenCont);
            if (message.decWaitInterval != null && Object.hasOwnProperty.call(message, "decWaitInterval"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.decWaitInterval);
            if (message.addWaitInterval != null && Object.hasOwnProperty.call(message, "addWaitInterval"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.addWaitInterval);
            if (message.beginDecInterval != null && Object.hasOwnProperty.call(message, "beginDecInterval"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.beginDecInterval);
            if (message.canDecLossProfitRatio != null && Object.hasOwnProperty.call(message, "canDecLossProfitRatio"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.canDecLossProfitRatio);
            if (message.shouldQuickCloseRatio != null && Object.hasOwnProperty.call(message, "shouldQuickCloseRatio"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.shouldQuickCloseRatio);
            return writer;
        };

        /**
         * Encodes the specified RapidTradeTriggerParameter message, length delimited. Does not implicitly {@link strategyparameter.RapidTradeTriggerParameter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @static
         * @param {strategyparameter.IRapidTradeTriggerParameter} message RapidTradeTriggerParameter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RapidTradeTriggerParameter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RapidTradeTriggerParameter message from the specified reader or buffer.
         * @function decode
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {strategyparameter.RapidTradeTriggerParameter} RapidTradeTriggerParameter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RapidTradeTriggerParameter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.strategyparameter.RapidTradeTriggerParameter();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.future = $root.st.CoinFuture.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.preKlineDownBdTh = reader.string();
                    break;
                case 3:
                    message.curKlineUpBdTh = reader.string();
                    break;
                case 4:
                    message.preKlineUpBuTh = reader.string();
                    break;
                case 5:
                    message.curKlineDownBuTh = reader.string();
                    break;
                case 6:
                    message.baseCont = reader.uint32();
                    break;
                case 7:
                    message.targetProfitRatio = reader.string();
                    break;
                case 8:
                    message.rsiExceedBidTh = reader.string();
                    break;
                case 9:
                    message.rsiExceedAskTh = reader.string();
                    break;
                case 10:
                    message.beginCloseProfitRatio = reader.string();
                    break;
                case 11:
                    message.canAddLossProfitRatio = reader.string();
                    break;
                case 12:
                    message.maxOpenCont = reader.uint32();
                    break;
                case 13:
                    message.decWaitInterval = reader.uint64();
                    break;
                case 14:
                    message.addWaitInterval = reader.uint64();
                    break;
                case 15:
                    message.beginDecInterval = reader.uint64();
                    break;
                case 16:
                    message.canDecLossProfitRatio = reader.string();
                    break;
                case 17:
                    message.shouldQuickCloseRatio = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RapidTradeTriggerParameter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {strategyparameter.RapidTradeTriggerParameter} RapidTradeTriggerParameter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RapidTradeTriggerParameter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RapidTradeTriggerParameter message.
         * @function verify
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RapidTradeTriggerParameter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.future != null && message.hasOwnProperty("future")) {
                let error = $root.st.CoinFuture.verify(message.future);
                if (error)
                    return "future." + error;
            }
            if (message.preKlineDownBdTh != null && message.hasOwnProperty("preKlineDownBdTh"))
                if (!$util.isString(message.preKlineDownBdTh))
                    return "preKlineDownBdTh: string expected";
            if (message.curKlineUpBdTh != null && message.hasOwnProperty("curKlineUpBdTh"))
                if (!$util.isString(message.curKlineUpBdTh))
                    return "curKlineUpBdTh: string expected";
            if (message.preKlineUpBuTh != null && message.hasOwnProperty("preKlineUpBuTh"))
                if (!$util.isString(message.preKlineUpBuTh))
                    return "preKlineUpBuTh: string expected";
            if (message.curKlineDownBuTh != null && message.hasOwnProperty("curKlineDownBuTh"))
                if (!$util.isString(message.curKlineDownBuTh))
                    return "curKlineDownBuTh: string expected";
            if (message.baseCont != null && message.hasOwnProperty("baseCont"))
                if (!$util.isInteger(message.baseCont))
                    return "baseCont: integer expected";
            if (message.targetProfitRatio != null && message.hasOwnProperty("targetProfitRatio"))
                if (!$util.isString(message.targetProfitRatio))
                    return "targetProfitRatio: string expected";
            if (message.rsiExceedBidTh != null && message.hasOwnProperty("rsiExceedBidTh"))
                if (!$util.isString(message.rsiExceedBidTh))
                    return "rsiExceedBidTh: string expected";
            if (message.rsiExceedAskTh != null && message.hasOwnProperty("rsiExceedAskTh"))
                if (!$util.isString(message.rsiExceedAskTh))
                    return "rsiExceedAskTh: string expected";
            if (message.beginCloseProfitRatio != null && message.hasOwnProperty("beginCloseProfitRatio"))
                if (!$util.isString(message.beginCloseProfitRatio))
                    return "beginCloseProfitRatio: string expected";
            if (message.canAddLossProfitRatio != null && message.hasOwnProperty("canAddLossProfitRatio"))
                if (!$util.isString(message.canAddLossProfitRatio))
                    return "canAddLossProfitRatio: string expected";
            if (message.maxOpenCont != null && message.hasOwnProperty("maxOpenCont"))
                if (!$util.isInteger(message.maxOpenCont))
                    return "maxOpenCont: integer expected";
            if (message.decWaitInterval != null && message.hasOwnProperty("decWaitInterval"))
                if (!$util.isInteger(message.decWaitInterval) && !(message.decWaitInterval && $util.isInteger(message.decWaitInterval.low) && $util.isInteger(message.decWaitInterval.high)))
                    return "decWaitInterval: integer|Long expected";
            if (message.addWaitInterval != null && message.hasOwnProperty("addWaitInterval"))
                if (!$util.isInteger(message.addWaitInterval) && !(message.addWaitInterval && $util.isInteger(message.addWaitInterval.low) && $util.isInteger(message.addWaitInterval.high)))
                    return "addWaitInterval: integer|Long expected";
            if (message.beginDecInterval != null && message.hasOwnProperty("beginDecInterval"))
                if (!$util.isInteger(message.beginDecInterval) && !(message.beginDecInterval && $util.isInteger(message.beginDecInterval.low) && $util.isInteger(message.beginDecInterval.high)))
                    return "beginDecInterval: integer|Long expected";
            if (message.canDecLossProfitRatio != null && message.hasOwnProperty("canDecLossProfitRatio"))
                if (!$util.isString(message.canDecLossProfitRatio))
                    return "canDecLossProfitRatio: string expected";
            if (message.shouldQuickCloseRatio != null && message.hasOwnProperty("shouldQuickCloseRatio"))
                if (!$util.isString(message.shouldQuickCloseRatio))
                    return "shouldQuickCloseRatio: string expected";
            return null;
        };

        /**
         * Creates a RapidTradeTriggerParameter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {strategyparameter.RapidTradeTriggerParameter} RapidTradeTriggerParameter
         */
        RapidTradeTriggerParameter.fromObject = function fromObject(object) {
            if (object instanceof $root.strategyparameter.RapidTradeTriggerParameter)
                return object;
            let message = new $root.strategyparameter.RapidTradeTriggerParameter();
            if (object.future != null) {
                if (typeof object.future !== "object")
                    throw TypeError(".strategyparameter.RapidTradeTriggerParameter.future: object expected");
                message.future = $root.st.CoinFuture.fromObject(object.future);
            }
            if (object.preKlineDownBdTh != null)
                message.preKlineDownBdTh = String(object.preKlineDownBdTh);
            if (object.curKlineUpBdTh != null)
                message.curKlineUpBdTh = String(object.curKlineUpBdTh);
            if (object.preKlineUpBuTh != null)
                message.preKlineUpBuTh = String(object.preKlineUpBuTh);
            if (object.curKlineDownBuTh != null)
                message.curKlineDownBuTh = String(object.curKlineDownBuTh);
            if (object.baseCont != null)
                message.baseCont = object.baseCont >>> 0;
            if (object.targetProfitRatio != null)
                message.targetProfitRatio = String(object.targetProfitRatio);
            if (object.rsiExceedBidTh != null)
                message.rsiExceedBidTh = String(object.rsiExceedBidTh);
            if (object.rsiExceedAskTh != null)
                message.rsiExceedAskTh = String(object.rsiExceedAskTh);
            if (object.beginCloseProfitRatio != null)
                message.beginCloseProfitRatio = String(object.beginCloseProfitRatio);
            if (object.canAddLossProfitRatio != null)
                message.canAddLossProfitRatio = String(object.canAddLossProfitRatio);
            if (object.maxOpenCont != null)
                message.maxOpenCont = object.maxOpenCont >>> 0;
            if (object.decWaitInterval != null)
                if ($util.Long)
                    (message.decWaitInterval = $util.Long.fromValue(object.decWaitInterval)).unsigned = true;
                else if (typeof object.decWaitInterval === "string")
                    message.decWaitInterval = parseInt(object.decWaitInterval, 10);
                else if (typeof object.decWaitInterval === "number")
                    message.decWaitInterval = object.decWaitInterval;
                else if (typeof object.decWaitInterval === "object")
                    message.decWaitInterval = new $util.LongBits(object.decWaitInterval.low >>> 0, object.decWaitInterval.high >>> 0).toNumber(true);
            if (object.addWaitInterval != null)
                if ($util.Long)
                    (message.addWaitInterval = $util.Long.fromValue(object.addWaitInterval)).unsigned = true;
                else if (typeof object.addWaitInterval === "string")
                    message.addWaitInterval = parseInt(object.addWaitInterval, 10);
                else if (typeof object.addWaitInterval === "number")
                    message.addWaitInterval = object.addWaitInterval;
                else if (typeof object.addWaitInterval === "object")
                    message.addWaitInterval = new $util.LongBits(object.addWaitInterval.low >>> 0, object.addWaitInterval.high >>> 0).toNumber(true);
            if (object.beginDecInterval != null)
                if ($util.Long)
                    (message.beginDecInterval = $util.Long.fromValue(object.beginDecInterval)).unsigned = true;
                else if (typeof object.beginDecInterval === "string")
                    message.beginDecInterval = parseInt(object.beginDecInterval, 10);
                else if (typeof object.beginDecInterval === "number")
                    message.beginDecInterval = object.beginDecInterval;
                else if (typeof object.beginDecInterval === "object")
                    message.beginDecInterval = new $util.LongBits(object.beginDecInterval.low >>> 0, object.beginDecInterval.high >>> 0).toNumber(true);
            if (object.canDecLossProfitRatio != null)
                message.canDecLossProfitRatio = String(object.canDecLossProfitRatio);
            if (object.shouldQuickCloseRatio != null)
                message.shouldQuickCloseRatio = String(object.shouldQuickCloseRatio);
            return message;
        };

        /**
         * Creates a plain object from a RapidTradeTriggerParameter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @static
         * @param {strategyparameter.RapidTradeTriggerParameter} message RapidTradeTriggerParameter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RapidTradeTriggerParameter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.future = null;
                object.preKlineDownBdTh = "";
                object.curKlineUpBdTh = "";
                object.preKlineUpBuTh = "";
                object.curKlineDownBuTh = "";
                object.baseCont = 0;
                object.targetProfitRatio = "";
                object.rsiExceedBidTh = "";
                object.rsiExceedAskTh = "";
                object.beginCloseProfitRatio = "";
                object.canAddLossProfitRatio = "";
                object.maxOpenCont = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.decWaitInterval = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.decWaitInterval = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.addWaitInterval = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.addWaitInterval = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.beginDecInterval = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.beginDecInterval = options.longs === String ? "0" : 0;
                object.canDecLossProfitRatio = "";
                object.shouldQuickCloseRatio = "";
            }
            if (message.future != null && message.hasOwnProperty("future"))
                object.future = $root.st.CoinFuture.toObject(message.future, options);
            if (message.preKlineDownBdTh != null && message.hasOwnProperty("preKlineDownBdTh"))
                object.preKlineDownBdTh = message.preKlineDownBdTh;
            if (message.curKlineUpBdTh != null && message.hasOwnProperty("curKlineUpBdTh"))
                object.curKlineUpBdTh = message.curKlineUpBdTh;
            if (message.preKlineUpBuTh != null && message.hasOwnProperty("preKlineUpBuTh"))
                object.preKlineUpBuTh = message.preKlineUpBuTh;
            if (message.curKlineDownBuTh != null && message.hasOwnProperty("curKlineDownBuTh"))
                object.curKlineDownBuTh = message.curKlineDownBuTh;
            if (message.baseCont != null && message.hasOwnProperty("baseCont"))
                object.baseCont = message.baseCont;
            if (message.targetProfitRatio != null && message.hasOwnProperty("targetProfitRatio"))
                object.targetProfitRatio = message.targetProfitRatio;
            if (message.rsiExceedBidTh != null && message.hasOwnProperty("rsiExceedBidTh"))
                object.rsiExceedBidTh = message.rsiExceedBidTh;
            if (message.rsiExceedAskTh != null && message.hasOwnProperty("rsiExceedAskTh"))
                object.rsiExceedAskTh = message.rsiExceedAskTh;
            if (message.beginCloseProfitRatio != null && message.hasOwnProperty("beginCloseProfitRatio"))
                object.beginCloseProfitRatio = message.beginCloseProfitRatio;
            if (message.canAddLossProfitRatio != null && message.hasOwnProperty("canAddLossProfitRatio"))
                object.canAddLossProfitRatio = message.canAddLossProfitRatio;
            if (message.maxOpenCont != null && message.hasOwnProperty("maxOpenCont"))
                object.maxOpenCont = message.maxOpenCont;
            if (message.decWaitInterval != null && message.hasOwnProperty("decWaitInterval"))
                if (typeof message.decWaitInterval === "number")
                    object.decWaitInterval = options.longs === String ? String(message.decWaitInterval) : message.decWaitInterval;
                else
                    object.decWaitInterval = options.longs === String ? $util.Long.prototype.toString.call(message.decWaitInterval) : options.longs === Number ? new $util.LongBits(message.decWaitInterval.low >>> 0, message.decWaitInterval.high >>> 0).toNumber(true) : message.decWaitInterval;
            if (message.addWaitInterval != null && message.hasOwnProperty("addWaitInterval"))
                if (typeof message.addWaitInterval === "number")
                    object.addWaitInterval = options.longs === String ? String(message.addWaitInterval) : message.addWaitInterval;
                else
                    object.addWaitInterval = options.longs === String ? $util.Long.prototype.toString.call(message.addWaitInterval) : options.longs === Number ? new $util.LongBits(message.addWaitInterval.low >>> 0, message.addWaitInterval.high >>> 0).toNumber(true) : message.addWaitInterval;
            if (message.beginDecInterval != null && message.hasOwnProperty("beginDecInterval"))
                if (typeof message.beginDecInterval === "number")
                    object.beginDecInterval = options.longs === String ? String(message.beginDecInterval) : message.beginDecInterval;
                else
                    object.beginDecInterval = options.longs === String ? $util.Long.prototype.toString.call(message.beginDecInterval) : options.longs === Number ? new $util.LongBits(message.beginDecInterval.low >>> 0, message.beginDecInterval.high >>> 0).toNumber(true) : message.beginDecInterval;
            if (message.canDecLossProfitRatio != null && message.hasOwnProperty("canDecLossProfitRatio"))
                object.canDecLossProfitRatio = message.canDecLossProfitRatio;
            if (message.shouldQuickCloseRatio != null && message.hasOwnProperty("shouldQuickCloseRatio"))
                object.shouldQuickCloseRatio = message.shouldQuickCloseRatio;
            return object;
        };

        /**
         * Converts this RapidTradeTriggerParameter to JSON.
         * @function toJSON
         * @memberof strategyparameter.RapidTradeTriggerParameter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RapidTradeTriggerParameter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RapidTradeTriggerParameter;
    })();

    return strategyparameter;
})();

export const marketdata = $root.marketdata = (() => {

    /**
     * Namespace marketdata.
     * @exports marketdata
     * @namespace
     */
    const marketdata = {};

    /**
     * TakerType enum.
     * @name marketdata.TakerType
     * @enum {number}
     * @property {number} DEFAULT_TAKER_TYPE=0 DEFAULT_TAKER_TYPE value
     * @property {number} TAKER_BID=1 TAKER_BID value
     * @property {number} TAKER_ASK=2 TAKER_ASK value
     */
    marketdata.TakerType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_TAKER_TYPE"] = 0;
        values[valuesById[1] = "TAKER_BID"] = 1;
        values[valuesById[2] = "TAKER_ASK"] = 2;
        return values;
    })();

    marketdata.TradeResult = (function() {

        /**
         * Properties of a TradeResult.
         * @memberof marketdata
         * @interface ITradeResult
         * @property {marketdata.TakerType|null} [takerType] TradeResult takerType
         * @property {st.ICoinFuture|null} [coinFuture] TradeResult coinFuture
         * @property {number|null} [dealCont] TradeResult dealCont
         * @property {string|null} [dealPrice] TradeResult dealPrice
         * @property {number|null} [eventTs] TradeResult eventTs
         */

        /**
         * Constructs a new TradeResult.
         * @memberof marketdata
         * @classdesc Represents a TradeResult.
         * @implements ITradeResult
         * @constructor
         * @param {marketdata.ITradeResult=} [properties] Properties to set
         */
        function TradeResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeResult takerType.
         * @member {marketdata.TakerType} takerType
         * @memberof marketdata.TradeResult
         * @instance
         */
        TradeResult.prototype.takerType = 0;

        /**
         * TradeResult coinFuture.
         * @member {st.ICoinFuture|null|undefined} coinFuture
         * @memberof marketdata.TradeResult
         * @instance
         */
        TradeResult.prototype.coinFuture = null;

        /**
         * TradeResult dealCont.
         * @member {number} dealCont
         * @memberof marketdata.TradeResult
         * @instance
         */
        TradeResult.prototype.dealCont = 0;

        /**
         * TradeResult dealPrice.
         * @member {string} dealPrice
         * @memberof marketdata.TradeResult
         * @instance
         */
        TradeResult.prototype.dealPrice = "";

        /**
         * TradeResult eventTs.
         * @member {number} eventTs
         * @memberof marketdata.TradeResult
         * @instance
         */
        TradeResult.prototype.eventTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new TradeResult instance using the specified properties.
         * @function create
         * @memberof marketdata.TradeResult
         * @static
         * @param {marketdata.ITradeResult=} [properties] Properties to set
         * @returns {marketdata.TradeResult} TradeResult instance
         */
        TradeResult.create = function create(properties) {
            return new TradeResult(properties);
        };

        /**
         * Encodes the specified TradeResult message. Does not implicitly {@link marketdata.TradeResult.verify|verify} messages.
         * @function encode
         * @memberof marketdata.TradeResult
         * @static
         * @param {marketdata.ITradeResult} message TradeResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.takerType != null && Object.hasOwnProperty.call(message, "takerType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.takerType);
            if (message.coinFuture != null && Object.hasOwnProperty.call(message, "coinFuture"))
                $root.st.CoinFuture.encode(message.coinFuture, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.dealCont != null && Object.hasOwnProperty.call(message, "dealCont"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.dealCont);
            if (message.dealPrice != null && Object.hasOwnProperty.call(message, "dealPrice"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.dealPrice);
            if (message.eventTs != null && Object.hasOwnProperty.call(message, "eventTs"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.eventTs);
            return writer;
        };

        /**
         * Encodes the specified TradeResult message, length delimited. Does not implicitly {@link marketdata.TradeResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof marketdata.TradeResult
         * @static
         * @param {marketdata.ITradeResult} message TradeResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeResult message from the specified reader or buffer.
         * @function decode
         * @memberof marketdata.TradeResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {marketdata.TradeResult} TradeResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.marketdata.TradeResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.takerType = reader.int32();
                    break;
                case 2:
                    message.coinFuture = $root.st.CoinFuture.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.dealCont = reader.uint32();
                    break;
                case 4:
                    message.dealPrice = reader.string();
                    break;
                case 5:
                    message.eventTs = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TradeResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof marketdata.TradeResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {marketdata.TradeResult} TradeResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeResult message.
         * @function verify
         * @memberof marketdata.TradeResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.takerType != null && message.hasOwnProperty("takerType"))
                switch (message.takerType) {
                default:
                    return "takerType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.coinFuture != null && message.hasOwnProperty("coinFuture")) {
                let error = $root.st.CoinFuture.verify(message.coinFuture);
                if (error)
                    return "coinFuture." + error;
            }
            if (message.dealCont != null && message.hasOwnProperty("dealCont"))
                if (!$util.isInteger(message.dealCont))
                    return "dealCont: integer expected";
            if (message.dealPrice != null && message.hasOwnProperty("dealPrice"))
                if (!$util.isString(message.dealPrice))
                    return "dealPrice: string expected";
            if (message.eventTs != null && message.hasOwnProperty("eventTs"))
                if (!$util.isInteger(message.eventTs) && !(message.eventTs && $util.isInteger(message.eventTs.low) && $util.isInteger(message.eventTs.high)))
                    return "eventTs: integer|Long expected";
            return null;
        };

        /**
         * Creates a TradeResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof marketdata.TradeResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {marketdata.TradeResult} TradeResult
         */
        TradeResult.fromObject = function fromObject(object) {
            if (object instanceof $root.marketdata.TradeResult)
                return object;
            let message = new $root.marketdata.TradeResult();
            switch (object.takerType) {
            case "DEFAULT_TAKER_TYPE":
            case 0:
                message.takerType = 0;
                break;
            case "TAKER_BID":
            case 1:
                message.takerType = 1;
                break;
            case "TAKER_ASK":
            case 2:
                message.takerType = 2;
                break;
            }
            if (object.coinFuture != null) {
                if (typeof object.coinFuture !== "object")
                    throw TypeError(".marketdata.TradeResult.coinFuture: object expected");
                message.coinFuture = $root.st.CoinFuture.fromObject(object.coinFuture);
            }
            if (object.dealCont != null)
                message.dealCont = object.dealCont >>> 0;
            if (object.dealPrice != null)
                message.dealPrice = String(object.dealPrice);
            if (object.eventTs != null)
                if ($util.Long)
                    (message.eventTs = $util.Long.fromValue(object.eventTs)).unsigned = true;
                else if (typeof object.eventTs === "string")
                    message.eventTs = parseInt(object.eventTs, 10);
                else if (typeof object.eventTs === "number")
                    message.eventTs = object.eventTs;
                else if (typeof object.eventTs === "object")
                    message.eventTs = new $util.LongBits(object.eventTs.low >>> 0, object.eventTs.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a TradeResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof marketdata.TradeResult
         * @static
         * @param {marketdata.TradeResult} message TradeResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.takerType = options.enums === String ? "DEFAULT_TAKER_TYPE" : 0;
                object.coinFuture = null;
                object.dealCont = 0;
                object.dealPrice = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.eventTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.eventTs = options.longs === String ? "0" : 0;
            }
            if (message.takerType != null && message.hasOwnProperty("takerType"))
                object.takerType = options.enums === String ? $root.marketdata.TakerType[message.takerType] : message.takerType;
            if (message.coinFuture != null && message.hasOwnProperty("coinFuture"))
                object.coinFuture = $root.st.CoinFuture.toObject(message.coinFuture, options);
            if (message.dealCont != null && message.hasOwnProperty("dealCont"))
                object.dealCont = message.dealCont;
            if (message.dealPrice != null && message.hasOwnProperty("dealPrice"))
                object.dealPrice = message.dealPrice;
            if (message.eventTs != null && message.hasOwnProperty("eventTs"))
                if (typeof message.eventTs === "number")
                    object.eventTs = options.longs === String ? String(message.eventTs) : message.eventTs;
                else
                    object.eventTs = options.longs === String ? $util.Long.prototype.toString.call(message.eventTs) : options.longs === Number ? new $util.LongBits(message.eventTs.low >>> 0, message.eventTs.high >>> 0).toNumber(true) : message.eventTs;
            return object;
        };

        /**
         * Converts this TradeResult to JSON.
         * @function toJSON
         * @memberof marketdata.TradeResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeResult;
    })();

    /**
     * KlineType enum.
     * @name marketdata.KlineType
     * @enum {number}
     * @property {number} DEFAULT_KLINE_TYPE=0 DEFAULT_KLINE_TYPE value
     * @property {number} KLINE_MIN=1 KLINE_MIN value
     * @property {number} KLINE_15MIN=2 KLINE_15MIN value
     * @property {number} KLINE_HOUR=3 KLINE_HOUR value
     * @property {number} KLINE_DAY=4 KLINE_DAY value
     * @property {number} KLINE_WEEK=5 KLINE_WEEK value
     * @property {number} KLINE_MONTH=6 KLINE_MONTH value
     */
    marketdata.KlineType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_KLINE_TYPE"] = 0;
        values[valuesById[1] = "KLINE_MIN"] = 1;
        values[valuesById[2] = "KLINE_15MIN"] = 2;
        values[valuesById[3] = "KLINE_HOUR"] = 3;
        values[valuesById[4] = "KLINE_DAY"] = 4;
        values[valuesById[5] = "KLINE_WEEK"] = 5;
        values[valuesById[6] = "KLINE_MONTH"] = 6;
        return values;
    })();

    marketdata.Kline = (function() {

        /**
         * Properties of a Kline.
         * @memberof marketdata
         * @interface IKline
         * @property {st.ICoinFuture|null} [future] Kline future
         * @property {marketdata.KlineType|null} [type] Kline type
         * @property {number|null} [startTs] Kline startTs
         * @property {number|null} [endTs] Kline endTs
         * @property {string|null} [open] Kline open
         * @property {string|null} [close] Kline close
         * @property {string|null} [high] Kline high
         * @property {string|null} [low] Kline low
         * @property {number|null} [volume] Kline volume
         * @property {string|null} [turnover] Kline turnover
         * @property {number|null} [ts] Kline ts
         * @property {boolean|null} [confirm] Kline confirm
         */

        /**
         * Constructs a new Kline.
         * @memberof marketdata
         * @classdesc Represents a Kline.
         * @implements IKline
         * @constructor
         * @param {marketdata.IKline=} [properties] Properties to set
         */
        function Kline(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Kline future.
         * @member {st.ICoinFuture|null|undefined} future
         * @memberof marketdata.Kline
         * @instance
         */
        Kline.prototype.future = null;

        /**
         * Kline type.
         * @member {marketdata.KlineType} type
         * @memberof marketdata.Kline
         * @instance
         */
        Kline.prototype.type = 0;

        /**
         * Kline startTs.
         * @member {number} startTs
         * @memberof marketdata.Kline
         * @instance
         */
        Kline.prototype.startTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Kline endTs.
         * @member {number} endTs
         * @memberof marketdata.Kline
         * @instance
         */
        Kline.prototype.endTs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Kline open.
         * @member {string} open
         * @memberof marketdata.Kline
         * @instance
         */
        Kline.prototype.open = "";

        /**
         * Kline close.
         * @member {string} close
         * @memberof marketdata.Kline
         * @instance
         */
        Kline.prototype.close = "";

        /**
         * Kline high.
         * @member {string} high
         * @memberof marketdata.Kline
         * @instance
         */
        Kline.prototype.high = "";

        /**
         * Kline low.
         * @member {string} low
         * @memberof marketdata.Kline
         * @instance
         */
        Kline.prototype.low = "";

        /**
         * Kline volume.
         * @member {number} volume
         * @memberof marketdata.Kline
         * @instance
         */
        Kline.prototype.volume = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Kline turnover.
         * @member {string} turnover
         * @memberof marketdata.Kline
         * @instance
         */
        Kline.prototype.turnover = "";

        /**
         * Kline ts.
         * @member {number} ts
         * @memberof marketdata.Kline
         * @instance
         */
        Kline.prototype.ts = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Kline confirm.
         * @member {boolean} confirm
         * @memberof marketdata.Kline
         * @instance
         */
        Kline.prototype.confirm = false;

        /**
         * Creates a new Kline instance using the specified properties.
         * @function create
         * @memberof marketdata.Kline
         * @static
         * @param {marketdata.IKline=} [properties] Properties to set
         * @returns {marketdata.Kline} Kline instance
         */
        Kline.create = function create(properties) {
            return new Kline(properties);
        };

        /**
         * Encodes the specified Kline message. Does not implicitly {@link marketdata.Kline.verify|verify} messages.
         * @function encode
         * @memberof marketdata.Kline
         * @static
         * @param {marketdata.IKline} message Kline message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Kline.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.future != null && Object.hasOwnProperty.call(message, "future"))
                $root.st.CoinFuture.encode(message.future, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.startTs != null && Object.hasOwnProperty.call(message, "startTs"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.startTs);
            if (message.endTs != null && Object.hasOwnProperty.call(message, "endTs"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.endTs);
            if (message.open != null && Object.hasOwnProperty.call(message, "open"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.open);
            if (message.close != null && Object.hasOwnProperty.call(message, "close"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.close);
            if (message.high != null && Object.hasOwnProperty.call(message, "high"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.high);
            if (message.low != null && Object.hasOwnProperty.call(message, "low"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.low);
            if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.volume);
            if (message.turnover != null && Object.hasOwnProperty.call(message, "turnover"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.turnover);
            if (message.ts != null && Object.hasOwnProperty.call(message, "ts"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.ts);
            if (message.confirm != null && Object.hasOwnProperty.call(message, "confirm"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.confirm);
            return writer;
        };

        /**
         * Encodes the specified Kline message, length delimited. Does not implicitly {@link marketdata.Kline.verify|verify} messages.
         * @function encodeDelimited
         * @memberof marketdata.Kline
         * @static
         * @param {marketdata.IKline} message Kline message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Kline.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Kline message from the specified reader or buffer.
         * @function decode
         * @memberof marketdata.Kline
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {marketdata.Kline} Kline
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Kline.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.marketdata.Kline();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.future = $root.st.CoinFuture.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.startTs = reader.uint64();
                    break;
                case 4:
                    message.endTs = reader.uint64();
                    break;
                case 5:
                    message.open = reader.string();
                    break;
                case 6:
                    message.close = reader.string();
                    break;
                case 7:
                    message.high = reader.string();
                    break;
                case 8:
                    message.low = reader.string();
                    break;
                case 9:
                    message.volume = reader.uint64();
                    break;
                case 10:
                    message.turnover = reader.string();
                    break;
                case 11:
                    message.ts = reader.uint64();
                    break;
                case 12:
                    message.confirm = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Kline message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof marketdata.Kline
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {marketdata.Kline} Kline
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Kline.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Kline message.
         * @function verify
         * @memberof marketdata.Kline
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Kline.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.future != null && message.hasOwnProperty("future")) {
                let error = $root.st.CoinFuture.verify(message.future);
                if (error)
                    return "future." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.startTs != null && message.hasOwnProperty("startTs"))
                if (!$util.isInteger(message.startTs) && !(message.startTs && $util.isInteger(message.startTs.low) && $util.isInteger(message.startTs.high)))
                    return "startTs: integer|Long expected";
            if (message.endTs != null && message.hasOwnProperty("endTs"))
                if (!$util.isInteger(message.endTs) && !(message.endTs && $util.isInteger(message.endTs.low) && $util.isInteger(message.endTs.high)))
                    return "endTs: integer|Long expected";
            if (message.open != null && message.hasOwnProperty("open"))
                if (!$util.isString(message.open))
                    return "open: string expected";
            if (message.close != null && message.hasOwnProperty("close"))
                if (!$util.isString(message.close))
                    return "close: string expected";
            if (message.high != null && message.hasOwnProperty("high"))
                if (!$util.isString(message.high))
                    return "high: string expected";
            if (message.low != null && message.hasOwnProperty("low"))
                if (!$util.isString(message.low))
                    return "low: string expected";
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (!$util.isInteger(message.volume) && !(message.volume && $util.isInteger(message.volume.low) && $util.isInteger(message.volume.high)))
                    return "volume: integer|Long expected";
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                if (!$util.isString(message.turnover))
                    return "turnover: string expected";
            if (message.ts != null && message.hasOwnProperty("ts"))
                if (!$util.isInteger(message.ts) && !(message.ts && $util.isInteger(message.ts.low) && $util.isInteger(message.ts.high)))
                    return "ts: integer|Long expected";
            if (message.confirm != null && message.hasOwnProperty("confirm"))
                if (typeof message.confirm !== "boolean")
                    return "confirm: boolean expected";
            return null;
        };

        /**
         * Creates a Kline message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof marketdata.Kline
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {marketdata.Kline} Kline
         */
        Kline.fromObject = function fromObject(object) {
            if (object instanceof $root.marketdata.Kline)
                return object;
            let message = new $root.marketdata.Kline();
            if (object.future != null) {
                if (typeof object.future !== "object")
                    throw TypeError(".marketdata.Kline.future: object expected");
                message.future = $root.st.CoinFuture.fromObject(object.future);
            }
            switch (object.type) {
            case "DEFAULT_KLINE_TYPE":
            case 0:
                message.type = 0;
                break;
            case "KLINE_MIN":
            case 1:
                message.type = 1;
                break;
            case "KLINE_15MIN":
            case 2:
                message.type = 2;
                break;
            case "KLINE_HOUR":
            case 3:
                message.type = 3;
                break;
            case "KLINE_DAY":
            case 4:
                message.type = 4;
                break;
            case "KLINE_WEEK":
            case 5:
                message.type = 5;
                break;
            case "KLINE_MONTH":
            case 6:
                message.type = 6;
                break;
            }
            if (object.startTs != null)
                if ($util.Long)
                    (message.startTs = $util.Long.fromValue(object.startTs)).unsigned = true;
                else if (typeof object.startTs === "string")
                    message.startTs = parseInt(object.startTs, 10);
                else if (typeof object.startTs === "number")
                    message.startTs = object.startTs;
                else if (typeof object.startTs === "object")
                    message.startTs = new $util.LongBits(object.startTs.low >>> 0, object.startTs.high >>> 0).toNumber(true);
            if (object.endTs != null)
                if ($util.Long)
                    (message.endTs = $util.Long.fromValue(object.endTs)).unsigned = true;
                else if (typeof object.endTs === "string")
                    message.endTs = parseInt(object.endTs, 10);
                else if (typeof object.endTs === "number")
                    message.endTs = object.endTs;
                else if (typeof object.endTs === "object")
                    message.endTs = new $util.LongBits(object.endTs.low >>> 0, object.endTs.high >>> 0).toNumber(true);
            if (object.open != null)
                message.open = String(object.open);
            if (object.close != null)
                message.close = String(object.close);
            if (object.high != null)
                message.high = String(object.high);
            if (object.low != null)
                message.low = String(object.low);
            if (object.volume != null)
                if ($util.Long)
                    (message.volume = $util.Long.fromValue(object.volume)).unsigned = true;
                else if (typeof object.volume === "string")
                    message.volume = parseInt(object.volume, 10);
                else if (typeof object.volume === "number")
                    message.volume = object.volume;
                else if (typeof object.volume === "object")
                    message.volume = new $util.LongBits(object.volume.low >>> 0, object.volume.high >>> 0).toNumber(true);
            if (object.turnover != null)
                message.turnover = String(object.turnover);
            if (object.ts != null)
                if ($util.Long)
                    (message.ts = $util.Long.fromValue(object.ts)).unsigned = true;
                else if (typeof object.ts === "string")
                    message.ts = parseInt(object.ts, 10);
                else if (typeof object.ts === "number")
                    message.ts = object.ts;
                else if (typeof object.ts === "object")
                    message.ts = new $util.LongBits(object.ts.low >>> 0, object.ts.high >>> 0).toNumber(true);
            if (object.confirm != null)
                message.confirm = Boolean(object.confirm);
            return message;
        };

        /**
         * Creates a plain object from a Kline message. Also converts values to other types if specified.
         * @function toObject
         * @memberof marketdata.Kline
         * @static
         * @param {marketdata.Kline} message Kline
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Kline.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.future = null;
                object.type = options.enums === String ? "DEFAULT_KLINE_TYPE" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.startTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.endTs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endTs = options.longs === String ? "0" : 0;
                object.open = "";
                object.close = "";
                object.high = "";
                object.low = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.volume = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.volume = options.longs === String ? "0" : 0;
                object.turnover = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ts = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ts = options.longs === String ? "0" : 0;
                object.confirm = false;
            }
            if (message.future != null && message.hasOwnProperty("future"))
                object.future = $root.st.CoinFuture.toObject(message.future, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.marketdata.KlineType[message.type] : message.type;
            if (message.startTs != null && message.hasOwnProperty("startTs"))
                if (typeof message.startTs === "number")
                    object.startTs = options.longs === String ? String(message.startTs) : message.startTs;
                else
                    object.startTs = options.longs === String ? $util.Long.prototype.toString.call(message.startTs) : options.longs === Number ? new $util.LongBits(message.startTs.low >>> 0, message.startTs.high >>> 0).toNumber(true) : message.startTs;
            if (message.endTs != null && message.hasOwnProperty("endTs"))
                if (typeof message.endTs === "number")
                    object.endTs = options.longs === String ? String(message.endTs) : message.endTs;
                else
                    object.endTs = options.longs === String ? $util.Long.prototype.toString.call(message.endTs) : options.longs === Number ? new $util.LongBits(message.endTs.low >>> 0, message.endTs.high >>> 0).toNumber(true) : message.endTs;
            if (message.open != null && message.hasOwnProperty("open"))
                object.open = message.open;
            if (message.close != null && message.hasOwnProperty("close"))
                object.close = message.close;
            if (message.high != null && message.hasOwnProperty("high"))
                object.high = message.high;
            if (message.low != null && message.hasOwnProperty("low"))
                object.low = message.low;
            if (message.volume != null && message.hasOwnProperty("volume"))
                if (typeof message.volume === "number")
                    object.volume = options.longs === String ? String(message.volume) : message.volume;
                else
                    object.volume = options.longs === String ? $util.Long.prototype.toString.call(message.volume) : options.longs === Number ? new $util.LongBits(message.volume.low >>> 0, message.volume.high >>> 0).toNumber(true) : message.volume;
            if (message.turnover != null && message.hasOwnProperty("turnover"))
                object.turnover = message.turnover;
            if (message.ts != null && message.hasOwnProperty("ts"))
                if (typeof message.ts === "number")
                    object.ts = options.longs === String ? String(message.ts) : message.ts;
                else
                    object.ts = options.longs === String ? $util.Long.prototype.toString.call(message.ts) : options.longs === Number ? new $util.LongBits(message.ts.low >>> 0, message.ts.high >>> 0).toNumber(true) : message.ts;
            if (message.confirm != null && message.hasOwnProperty("confirm"))
                object.confirm = message.confirm;
            return object;
        };

        /**
         * Converts this Kline to JSON.
         * @function toJSON
         * @memberof marketdata.Kline
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Kline.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Kline;
    })();

    marketdata.HistoryMarketDataIndex = (function() {

        /**
         * Properties of a HistoryMarketDataIndex.
         * @memberof marketdata
         * @interface IHistoryMarketDataIndex
         * @property {string|null} [symbolId] HistoryMarketDataIndex symbolId
         * @property {string|null} [savePath] HistoryMarketDataIndex savePath
         * @property {string|null} [desc] HistoryMarketDataIndex desc
         */

        /**
         * Constructs a new HistoryMarketDataIndex.
         * @memberof marketdata
         * @classdesc Represents a HistoryMarketDataIndex.
         * @implements IHistoryMarketDataIndex
         * @constructor
         * @param {marketdata.IHistoryMarketDataIndex=} [properties] Properties to set
         */
        function HistoryMarketDataIndex(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HistoryMarketDataIndex symbolId.
         * @member {string} symbolId
         * @memberof marketdata.HistoryMarketDataIndex
         * @instance
         */
        HistoryMarketDataIndex.prototype.symbolId = "";

        /**
         * HistoryMarketDataIndex savePath.
         * @member {string} savePath
         * @memberof marketdata.HistoryMarketDataIndex
         * @instance
         */
        HistoryMarketDataIndex.prototype.savePath = "";

        /**
         * HistoryMarketDataIndex desc.
         * @member {string} desc
         * @memberof marketdata.HistoryMarketDataIndex
         * @instance
         */
        HistoryMarketDataIndex.prototype.desc = "";

        /**
         * Creates a new HistoryMarketDataIndex instance using the specified properties.
         * @function create
         * @memberof marketdata.HistoryMarketDataIndex
         * @static
         * @param {marketdata.IHistoryMarketDataIndex=} [properties] Properties to set
         * @returns {marketdata.HistoryMarketDataIndex} HistoryMarketDataIndex instance
         */
        HistoryMarketDataIndex.create = function create(properties) {
            return new HistoryMarketDataIndex(properties);
        };

        /**
         * Encodes the specified HistoryMarketDataIndex message. Does not implicitly {@link marketdata.HistoryMarketDataIndex.verify|verify} messages.
         * @function encode
         * @memberof marketdata.HistoryMarketDataIndex
         * @static
         * @param {marketdata.IHistoryMarketDataIndex} message HistoryMarketDataIndex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistoryMarketDataIndex.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.symbolId != null && Object.hasOwnProperty.call(message, "symbolId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.symbolId);
            if (message.savePath != null && Object.hasOwnProperty.call(message, "savePath"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.savePath);
            if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.desc);
            return writer;
        };

        /**
         * Encodes the specified HistoryMarketDataIndex message, length delimited. Does not implicitly {@link marketdata.HistoryMarketDataIndex.verify|verify} messages.
         * @function encodeDelimited
         * @memberof marketdata.HistoryMarketDataIndex
         * @static
         * @param {marketdata.IHistoryMarketDataIndex} message HistoryMarketDataIndex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistoryMarketDataIndex.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HistoryMarketDataIndex message from the specified reader or buffer.
         * @function decode
         * @memberof marketdata.HistoryMarketDataIndex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {marketdata.HistoryMarketDataIndex} HistoryMarketDataIndex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistoryMarketDataIndex.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.marketdata.HistoryMarketDataIndex();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.symbolId = reader.string();
                    break;
                case 2:
                    message.savePath = reader.string();
                    break;
                case 3:
                    message.desc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HistoryMarketDataIndex message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof marketdata.HistoryMarketDataIndex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {marketdata.HistoryMarketDataIndex} HistoryMarketDataIndex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistoryMarketDataIndex.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HistoryMarketDataIndex message.
         * @function verify
         * @memberof marketdata.HistoryMarketDataIndex
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HistoryMarketDataIndex.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.symbolId != null && message.hasOwnProperty("symbolId"))
                if (!$util.isString(message.symbolId))
                    return "symbolId: string expected";
            if (message.savePath != null && message.hasOwnProperty("savePath"))
                if (!$util.isString(message.savePath))
                    return "savePath: string expected";
            if (message.desc != null && message.hasOwnProperty("desc"))
                if (!$util.isString(message.desc))
                    return "desc: string expected";
            return null;
        };

        /**
         * Creates a HistoryMarketDataIndex message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof marketdata.HistoryMarketDataIndex
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {marketdata.HistoryMarketDataIndex} HistoryMarketDataIndex
         */
        HistoryMarketDataIndex.fromObject = function fromObject(object) {
            if (object instanceof $root.marketdata.HistoryMarketDataIndex)
                return object;
            let message = new $root.marketdata.HistoryMarketDataIndex();
            if (object.symbolId != null)
                message.symbolId = String(object.symbolId);
            if (object.savePath != null)
                message.savePath = String(object.savePath);
            if (object.desc != null)
                message.desc = String(object.desc);
            return message;
        };

        /**
         * Creates a plain object from a HistoryMarketDataIndex message. Also converts values to other types if specified.
         * @function toObject
         * @memberof marketdata.HistoryMarketDataIndex
         * @static
         * @param {marketdata.HistoryMarketDataIndex} message HistoryMarketDataIndex
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HistoryMarketDataIndex.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.symbolId = "";
                object.savePath = "";
                object.desc = "";
            }
            if (message.symbolId != null && message.hasOwnProperty("symbolId"))
                object.symbolId = message.symbolId;
            if (message.savePath != null && message.hasOwnProperty("savePath"))
                object.savePath = message.savePath;
            if (message.desc != null && message.hasOwnProperty("desc"))
                object.desc = message.desc;
            return object;
        };

        /**
         * Converts this HistoryMarketDataIndex to JSON.
         * @function toJSON
         * @memberof marketdata.HistoryMarketDataIndex
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HistoryMarketDataIndex.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HistoryMarketDataIndex;
    })();

    return marketdata;
})();

export const innerapi = $root.innerapi = (() => {

    /**
     * Namespace innerapi.
     * @exports innerapi
     * @namespace
     */
    const innerapi = {};

    innerapi.GetBuySellVolumeReq = (function() {

        /**
         * Properties of a GetBuySellVolumeReq.
         * @memberof innerapi
         * @interface IGetBuySellVolumeReq
         * @property {string|null} [symbolId] GetBuySellVolumeReq symbolId
         * @property {number|null} [startSec] GetBuySellVolumeReq startSec
         * @property {number|null} [aggrIntervalSec] GetBuySellVolumeReq aggrIntervalSec
         * @property {string|null} [source] GetBuySellVolumeReq source
         */

        /**
         * Constructs a new GetBuySellVolumeReq.
         * @memberof innerapi
         * @classdesc Represents a GetBuySellVolumeReq.
         * @implements IGetBuySellVolumeReq
         * @constructor
         * @param {innerapi.IGetBuySellVolumeReq=} [properties] Properties to set
         */
        function GetBuySellVolumeReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetBuySellVolumeReq symbolId.
         * @member {string} symbolId
         * @memberof innerapi.GetBuySellVolumeReq
         * @instance
         */
        GetBuySellVolumeReq.prototype.symbolId = "";

        /**
         * GetBuySellVolumeReq startSec.
         * @member {number} startSec
         * @memberof innerapi.GetBuySellVolumeReq
         * @instance
         */
        GetBuySellVolumeReq.prototype.startSec = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GetBuySellVolumeReq aggrIntervalSec.
         * @member {number} aggrIntervalSec
         * @memberof innerapi.GetBuySellVolumeReq
         * @instance
         */
        GetBuySellVolumeReq.prototype.aggrIntervalSec = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GetBuySellVolumeReq source.
         * @member {string} source
         * @memberof innerapi.GetBuySellVolumeReq
         * @instance
         */
        GetBuySellVolumeReq.prototype.source = "";

        /**
         * Creates a new GetBuySellVolumeReq instance using the specified properties.
         * @function create
         * @memberof innerapi.GetBuySellVolumeReq
         * @static
         * @param {innerapi.IGetBuySellVolumeReq=} [properties] Properties to set
         * @returns {innerapi.GetBuySellVolumeReq} GetBuySellVolumeReq instance
         */
        GetBuySellVolumeReq.create = function create(properties) {
            return new GetBuySellVolumeReq(properties);
        };

        /**
         * Encodes the specified GetBuySellVolumeReq message. Does not implicitly {@link innerapi.GetBuySellVolumeReq.verify|verify} messages.
         * @function encode
         * @memberof innerapi.GetBuySellVolumeReq
         * @static
         * @param {innerapi.IGetBuySellVolumeReq} message GetBuySellVolumeReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBuySellVolumeReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.symbolId != null && Object.hasOwnProperty.call(message, "symbolId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.symbolId);
            if (message.startSec != null && Object.hasOwnProperty.call(message, "startSec"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.startSec);
            if (message.aggrIntervalSec != null && Object.hasOwnProperty.call(message, "aggrIntervalSec"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.aggrIntervalSec);
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                writer.uint32(/* id 100, wireType 2 =*/802).string(message.source);
            return writer;
        };

        /**
         * Encodes the specified GetBuySellVolumeReq message, length delimited. Does not implicitly {@link innerapi.GetBuySellVolumeReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof innerapi.GetBuySellVolumeReq
         * @static
         * @param {innerapi.IGetBuySellVolumeReq} message GetBuySellVolumeReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBuySellVolumeReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetBuySellVolumeReq message from the specified reader or buffer.
         * @function decode
         * @memberof innerapi.GetBuySellVolumeReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {innerapi.GetBuySellVolumeReq} GetBuySellVolumeReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBuySellVolumeReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.innerapi.GetBuySellVolumeReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.symbolId = reader.string();
                    break;
                case 2:
                    message.startSec = reader.uint64();
                    break;
                case 3:
                    message.aggrIntervalSec = reader.uint64();
                    break;
                case 100:
                    message.source = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetBuySellVolumeReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof innerapi.GetBuySellVolumeReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {innerapi.GetBuySellVolumeReq} GetBuySellVolumeReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBuySellVolumeReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetBuySellVolumeReq message.
         * @function verify
         * @memberof innerapi.GetBuySellVolumeReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetBuySellVolumeReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.symbolId != null && message.hasOwnProperty("symbolId"))
                if (!$util.isString(message.symbolId))
                    return "symbolId: string expected";
            if (message.startSec != null && message.hasOwnProperty("startSec"))
                if (!$util.isInteger(message.startSec) && !(message.startSec && $util.isInteger(message.startSec.low) && $util.isInteger(message.startSec.high)))
                    return "startSec: integer|Long expected";
            if (message.aggrIntervalSec != null && message.hasOwnProperty("aggrIntervalSec"))
                if (!$util.isInteger(message.aggrIntervalSec) && !(message.aggrIntervalSec && $util.isInteger(message.aggrIntervalSec.low) && $util.isInteger(message.aggrIntervalSec.high)))
                    return "aggrIntervalSec: integer|Long expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!$util.isString(message.source))
                    return "source: string expected";
            return null;
        };

        /**
         * Creates a GetBuySellVolumeReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof innerapi.GetBuySellVolumeReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {innerapi.GetBuySellVolumeReq} GetBuySellVolumeReq
         */
        GetBuySellVolumeReq.fromObject = function fromObject(object) {
            if (object instanceof $root.innerapi.GetBuySellVolumeReq)
                return object;
            let message = new $root.innerapi.GetBuySellVolumeReq();
            if (object.symbolId != null)
                message.symbolId = String(object.symbolId);
            if (object.startSec != null)
                if ($util.Long)
                    (message.startSec = $util.Long.fromValue(object.startSec)).unsigned = true;
                else if (typeof object.startSec === "string")
                    message.startSec = parseInt(object.startSec, 10);
                else if (typeof object.startSec === "number")
                    message.startSec = object.startSec;
                else if (typeof object.startSec === "object")
                    message.startSec = new $util.LongBits(object.startSec.low >>> 0, object.startSec.high >>> 0).toNumber(true);
            if (object.aggrIntervalSec != null)
                if ($util.Long)
                    (message.aggrIntervalSec = $util.Long.fromValue(object.aggrIntervalSec)).unsigned = true;
                else if (typeof object.aggrIntervalSec === "string")
                    message.aggrIntervalSec = parseInt(object.aggrIntervalSec, 10);
                else if (typeof object.aggrIntervalSec === "number")
                    message.aggrIntervalSec = object.aggrIntervalSec;
                else if (typeof object.aggrIntervalSec === "object")
                    message.aggrIntervalSec = new $util.LongBits(object.aggrIntervalSec.low >>> 0, object.aggrIntervalSec.high >>> 0).toNumber(true);
            if (object.source != null)
                message.source = String(object.source);
            return message;
        };

        /**
         * Creates a plain object from a GetBuySellVolumeReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof innerapi.GetBuySellVolumeReq
         * @static
         * @param {innerapi.GetBuySellVolumeReq} message GetBuySellVolumeReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetBuySellVolumeReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.symbolId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.startSec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startSec = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.aggrIntervalSec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.aggrIntervalSec = options.longs === String ? "0" : 0;
                object.source = "";
            }
            if (message.symbolId != null && message.hasOwnProperty("symbolId"))
                object.symbolId = message.symbolId;
            if (message.startSec != null && message.hasOwnProperty("startSec"))
                if (typeof message.startSec === "number")
                    object.startSec = options.longs === String ? String(message.startSec) : message.startSec;
                else
                    object.startSec = options.longs === String ? $util.Long.prototype.toString.call(message.startSec) : options.longs === Number ? new $util.LongBits(message.startSec.low >>> 0, message.startSec.high >>> 0).toNumber(true) : message.startSec;
            if (message.aggrIntervalSec != null && message.hasOwnProperty("aggrIntervalSec"))
                if (typeof message.aggrIntervalSec === "number")
                    object.aggrIntervalSec = options.longs === String ? String(message.aggrIntervalSec) : message.aggrIntervalSec;
                else
                    object.aggrIntervalSec = options.longs === String ? $util.Long.prototype.toString.call(message.aggrIntervalSec) : options.longs === Number ? new $util.LongBits(message.aggrIntervalSec.low >>> 0, message.aggrIntervalSec.high >>> 0).toNumber(true) : message.aggrIntervalSec;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = message.source;
            return object;
        };

        /**
         * Converts this GetBuySellVolumeReq to JSON.
         * @function toJSON
         * @memberof innerapi.GetBuySellVolumeReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetBuySellVolumeReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetBuySellVolumeReq;
    })();

    innerapi.BuySellVolume = (function() {

        /**
         * Properties of a BuySellVolume.
         * @memberof innerapi
         * @interface IBuySellVolume
         * @property {number|null} [buyVolume] BuySellVolume buyVolume
         * @property {number|null} [sellVolume] BuySellVolume sellVolume
         * @property {number|null} [buyTurnover] BuySellVolume buyTurnover
         * @property {number|null} [sellTurnover] BuySellVolume sellTurnover
         * @property {number|null} [buyCnt] BuySellVolume buyCnt
         * @property {number|null} [sellCnt] BuySellVolume sellCnt
         * @property {number|null} [startSec] BuySellVolume startSec
         */

        /**
         * Constructs a new BuySellVolume.
         * @memberof innerapi
         * @classdesc Represents a BuySellVolume.
         * @implements IBuySellVolume
         * @constructor
         * @param {innerapi.IBuySellVolume=} [properties] Properties to set
         */
        function BuySellVolume(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuySellVolume buyVolume.
         * @member {number} buyVolume
         * @memberof innerapi.BuySellVolume
         * @instance
         */
        BuySellVolume.prototype.buyVolume = 0;

        /**
         * BuySellVolume sellVolume.
         * @member {number} sellVolume
         * @memberof innerapi.BuySellVolume
         * @instance
         */
        BuySellVolume.prototype.sellVolume = 0;

        /**
         * BuySellVolume buyTurnover.
         * @member {number} buyTurnover
         * @memberof innerapi.BuySellVolume
         * @instance
         */
        BuySellVolume.prototype.buyTurnover = 0;

        /**
         * BuySellVolume sellTurnover.
         * @member {number} sellTurnover
         * @memberof innerapi.BuySellVolume
         * @instance
         */
        BuySellVolume.prototype.sellTurnover = 0;

        /**
         * BuySellVolume buyCnt.
         * @member {number} buyCnt
         * @memberof innerapi.BuySellVolume
         * @instance
         */
        BuySellVolume.prototype.buyCnt = 0;

        /**
         * BuySellVolume sellCnt.
         * @member {number} sellCnt
         * @memberof innerapi.BuySellVolume
         * @instance
         */
        BuySellVolume.prototype.sellCnt = 0;

        /**
         * BuySellVolume startSec.
         * @member {number} startSec
         * @memberof innerapi.BuySellVolume
         * @instance
         */
        BuySellVolume.prototype.startSec = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new BuySellVolume instance using the specified properties.
         * @function create
         * @memberof innerapi.BuySellVolume
         * @static
         * @param {innerapi.IBuySellVolume=} [properties] Properties to set
         * @returns {innerapi.BuySellVolume} BuySellVolume instance
         */
        BuySellVolume.create = function create(properties) {
            return new BuySellVolume(properties);
        };

        /**
         * Encodes the specified BuySellVolume message. Does not implicitly {@link innerapi.BuySellVolume.verify|verify} messages.
         * @function encode
         * @memberof innerapi.BuySellVolume
         * @static
         * @param {innerapi.IBuySellVolume} message BuySellVolume message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuySellVolume.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.buyVolume != null && Object.hasOwnProperty.call(message, "buyVolume"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.buyVolume);
            if (message.sellVolume != null && Object.hasOwnProperty.call(message, "sellVolume"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.sellVolume);
            if (message.buyTurnover != null && Object.hasOwnProperty.call(message, "buyTurnover"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.buyTurnover);
            if (message.sellTurnover != null && Object.hasOwnProperty.call(message, "sellTurnover"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.sellTurnover);
            if (message.buyCnt != null && Object.hasOwnProperty.call(message, "buyCnt"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.buyCnt);
            if (message.sellCnt != null && Object.hasOwnProperty.call(message, "sellCnt"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.sellCnt);
            if (message.startSec != null && Object.hasOwnProperty.call(message, "startSec"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.startSec);
            return writer;
        };

        /**
         * Encodes the specified BuySellVolume message, length delimited. Does not implicitly {@link innerapi.BuySellVolume.verify|verify} messages.
         * @function encodeDelimited
         * @memberof innerapi.BuySellVolume
         * @static
         * @param {innerapi.IBuySellVolume} message BuySellVolume message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuySellVolume.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuySellVolume message from the specified reader or buffer.
         * @function decode
         * @memberof innerapi.BuySellVolume
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {innerapi.BuySellVolume} BuySellVolume
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuySellVolume.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.innerapi.BuySellVolume();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.buyVolume = reader.double();
                    break;
                case 2:
                    message.sellVolume = reader.double();
                    break;
                case 3:
                    message.buyTurnover = reader.double();
                    break;
                case 4:
                    message.sellTurnover = reader.double();
                    break;
                case 5:
                    message.buyCnt = reader.int32();
                    break;
                case 6:
                    message.sellCnt = reader.int32();
                    break;
                case 7:
                    message.startSec = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuySellVolume message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof innerapi.BuySellVolume
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {innerapi.BuySellVolume} BuySellVolume
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuySellVolume.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuySellVolume message.
         * @function verify
         * @memberof innerapi.BuySellVolume
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuySellVolume.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.buyVolume != null && message.hasOwnProperty("buyVolume"))
                if (typeof message.buyVolume !== "number")
                    return "buyVolume: number expected";
            if (message.sellVolume != null && message.hasOwnProperty("sellVolume"))
                if (typeof message.sellVolume !== "number")
                    return "sellVolume: number expected";
            if (message.buyTurnover != null && message.hasOwnProperty("buyTurnover"))
                if (typeof message.buyTurnover !== "number")
                    return "buyTurnover: number expected";
            if (message.sellTurnover != null && message.hasOwnProperty("sellTurnover"))
                if (typeof message.sellTurnover !== "number")
                    return "sellTurnover: number expected";
            if (message.buyCnt != null && message.hasOwnProperty("buyCnt"))
                if (!$util.isInteger(message.buyCnt))
                    return "buyCnt: integer expected";
            if (message.sellCnt != null && message.hasOwnProperty("sellCnt"))
                if (!$util.isInteger(message.sellCnt))
                    return "sellCnt: integer expected";
            if (message.startSec != null && message.hasOwnProperty("startSec"))
                if (!$util.isInteger(message.startSec) && !(message.startSec && $util.isInteger(message.startSec.low) && $util.isInteger(message.startSec.high)))
                    return "startSec: integer|Long expected";
            return null;
        };

        /**
         * Creates a BuySellVolume message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof innerapi.BuySellVolume
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {innerapi.BuySellVolume} BuySellVolume
         */
        BuySellVolume.fromObject = function fromObject(object) {
            if (object instanceof $root.innerapi.BuySellVolume)
                return object;
            let message = new $root.innerapi.BuySellVolume();
            if (object.buyVolume != null)
                message.buyVolume = Number(object.buyVolume);
            if (object.sellVolume != null)
                message.sellVolume = Number(object.sellVolume);
            if (object.buyTurnover != null)
                message.buyTurnover = Number(object.buyTurnover);
            if (object.sellTurnover != null)
                message.sellTurnover = Number(object.sellTurnover);
            if (object.buyCnt != null)
                message.buyCnt = object.buyCnt | 0;
            if (object.sellCnt != null)
                message.sellCnt = object.sellCnt | 0;
            if (object.startSec != null)
                if ($util.Long)
                    (message.startSec = $util.Long.fromValue(object.startSec)).unsigned = true;
                else if (typeof object.startSec === "string")
                    message.startSec = parseInt(object.startSec, 10);
                else if (typeof object.startSec === "number")
                    message.startSec = object.startSec;
                else if (typeof object.startSec === "object")
                    message.startSec = new $util.LongBits(object.startSec.low >>> 0, object.startSec.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a BuySellVolume message. Also converts values to other types if specified.
         * @function toObject
         * @memberof innerapi.BuySellVolume
         * @static
         * @param {innerapi.BuySellVolume} message BuySellVolume
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuySellVolume.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.buyVolume = 0;
                object.sellVolume = 0;
                object.buyTurnover = 0;
                object.sellTurnover = 0;
                object.buyCnt = 0;
                object.sellCnt = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.startSec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startSec = options.longs === String ? "0" : 0;
            }
            if (message.buyVolume != null && message.hasOwnProperty("buyVolume"))
                object.buyVolume = options.json && !isFinite(message.buyVolume) ? String(message.buyVolume) : message.buyVolume;
            if (message.sellVolume != null && message.hasOwnProperty("sellVolume"))
                object.sellVolume = options.json && !isFinite(message.sellVolume) ? String(message.sellVolume) : message.sellVolume;
            if (message.buyTurnover != null && message.hasOwnProperty("buyTurnover"))
                object.buyTurnover = options.json && !isFinite(message.buyTurnover) ? String(message.buyTurnover) : message.buyTurnover;
            if (message.sellTurnover != null && message.hasOwnProperty("sellTurnover"))
                object.sellTurnover = options.json && !isFinite(message.sellTurnover) ? String(message.sellTurnover) : message.sellTurnover;
            if (message.buyCnt != null && message.hasOwnProperty("buyCnt"))
                object.buyCnt = message.buyCnt;
            if (message.sellCnt != null && message.hasOwnProperty("sellCnt"))
                object.sellCnt = message.sellCnt;
            if (message.startSec != null && message.hasOwnProperty("startSec"))
                if (typeof message.startSec === "number")
                    object.startSec = options.longs === String ? String(message.startSec) : message.startSec;
                else
                    object.startSec = options.longs === String ? $util.Long.prototype.toString.call(message.startSec) : options.longs === Number ? new $util.LongBits(message.startSec.low >>> 0, message.startSec.high >>> 0).toNumber(true) : message.startSec;
            return object;
        };

        /**
         * Converts this BuySellVolume to JSON.
         * @function toJSON
         * @memberof innerapi.BuySellVolume
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuySellVolume.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuySellVolume;
    })();

    innerapi.GetBuySellVolumeResp = (function() {

        /**
         * Properties of a GetBuySellVolumeResp.
         * @memberof innerapi
         * @interface IGetBuySellVolumeResp
         * @property {Array.<innerapi.IBuySellVolume>|null} [statistics] GetBuySellVolumeResp statistics
         * @property {string|null} [base64encodedData] GetBuySellVolumeResp base64encodedData
         */

        /**
         * Constructs a new GetBuySellVolumeResp.
         * @memberof innerapi
         * @classdesc Represents a GetBuySellVolumeResp.
         * @implements IGetBuySellVolumeResp
         * @constructor
         * @param {innerapi.IGetBuySellVolumeResp=} [properties] Properties to set
         */
        function GetBuySellVolumeResp(properties) {
            this.statistics = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetBuySellVolumeResp statistics.
         * @member {Array.<innerapi.IBuySellVolume>} statistics
         * @memberof innerapi.GetBuySellVolumeResp
         * @instance
         */
        GetBuySellVolumeResp.prototype.statistics = $util.emptyArray;

        /**
         * GetBuySellVolumeResp base64encodedData.
         * @member {string} base64encodedData
         * @memberof innerapi.GetBuySellVolumeResp
         * @instance
         */
        GetBuySellVolumeResp.prototype.base64encodedData = "";

        /**
         * Creates a new GetBuySellVolumeResp instance using the specified properties.
         * @function create
         * @memberof innerapi.GetBuySellVolumeResp
         * @static
         * @param {innerapi.IGetBuySellVolumeResp=} [properties] Properties to set
         * @returns {innerapi.GetBuySellVolumeResp} GetBuySellVolumeResp instance
         */
        GetBuySellVolumeResp.create = function create(properties) {
            return new GetBuySellVolumeResp(properties);
        };

        /**
         * Encodes the specified GetBuySellVolumeResp message. Does not implicitly {@link innerapi.GetBuySellVolumeResp.verify|verify} messages.
         * @function encode
         * @memberof innerapi.GetBuySellVolumeResp
         * @static
         * @param {innerapi.IGetBuySellVolumeResp} message GetBuySellVolumeResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBuySellVolumeResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.statistics != null && message.statistics.length)
                for (let i = 0; i < message.statistics.length; ++i)
                    $root.innerapi.BuySellVolume.encode(message.statistics[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.base64encodedData != null && Object.hasOwnProperty.call(message, "base64encodedData"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.base64encodedData);
            return writer;
        };

        /**
         * Encodes the specified GetBuySellVolumeResp message, length delimited. Does not implicitly {@link innerapi.GetBuySellVolumeResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof innerapi.GetBuySellVolumeResp
         * @static
         * @param {innerapi.IGetBuySellVolumeResp} message GetBuySellVolumeResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBuySellVolumeResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetBuySellVolumeResp message from the specified reader or buffer.
         * @function decode
         * @memberof innerapi.GetBuySellVolumeResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {innerapi.GetBuySellVolumeResp} GetBuySellVolumeResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBuySellVolumeResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.innerapi.GetBuySellVolumeResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.statistics && message.statistics.length))
                        message.statistics = [];
                    message.statistics.push($root.innerapi.BuySellVolume.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.base64encodedData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetBuySellVolumeResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof innerapi.GetBuySellVolumeResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {innerapi.GetBuySellVolumeResp} GetBuySellVolumeResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBuySellVolumeResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetBuySellVolumeResp message.
         * @function verify
         * @memberof innerapi.GetBuySellVolumeResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetBuySellVolumeResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.statistics != null && message.hasOwnProperty("statistics")) {
                if (!Array.isArray(message.statistics))
                    return "statistics: array expected";
                for (let i = 0; i < message.statistics.length; ++i) {
                    let error = $root.innerapi.BuySellVolume.verify(message.statistics[i]);
                    if (error)
                        return "statistics." + error;
                }
            }
            if (message.base64encodedData != null && message.hasOwnProperty("base64encodedData"))
                if (!$util.isString(message.base64encodedData))
                    return "base64encodedData: string expected";
            return null;
        };

        /**
         * Creates a GetBuySellVolumeResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof innerapi.GetBuySellVolumeResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {innerapi.GetBuySellVolumeResp} GetBuySellVolumeResp
         */
        GetBuySellVolumeResp.fromObject = function fromObject(object) {
            if (object instanceof $root.innerapi.GetBuySellVolumeResp)
                return object;
            let message = new $root.innerapi.GetBuySellVolumeResp();
            if (object.statistics) {
                if (!Array.isArray(object.statistics))
                    throw TypeError(".innerapi.GetBuySellVolumeResp.statistics: array expected");
                message.statistics = [];
                for (let i = 0; i < object.statistics.length; ++i) {
                    if (typeof object.statistics[i] !== "object")
                        throw TypeError(".innerapi.GetBuySellVolumeResp.statistics: object expected");
                    message.statistics[i] = $root.innerapi.BuySellVolume.fromObject(object.statistics[i]);
                }
            }
            if (object.base64encodedData != null)
                message.base64encodedData = String(object.base64encodedData);
            return message;
        };

        /**
         * Creates a plain object from a GetBuySellVolumeResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof innerapi.GetBuySellVolumeResp
         * @static
         * @param {innerapi.GetBuySellVolumeResp} message GetBuySellVolumeResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetBuySellVolumeResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.statistics = [];
            if (options.defaults)
                object.base64encodedData = "";
            if (message.statistics && message.statistics.length) {
                object.statistics = [];
                for (let j = 0; j < message.statistics.length; ++j)
                    object.statistics[j] = $root.innerapi.BuySellVolume.toObject(message.statistics[j], options);
            }
            if (message.base64encodedData != null && message.hasOwnProperty("base64encodedData"))
                object.base64encodedData = message.base64encodedData;
            return object;
        };

        /**
         * Converts this GetBuySellVolumeResp to JSON.
         * @function toJSON
         * @memberof innerapi.GetBuySellVolumeResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetBuySellVolumeResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetBuySellVolumeResp;
    })();

    return innerapi;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            FileDescriptorSet.create = function create(properties) {
                return new FileDescriptorSet(properties);
            };

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (let i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.file && message.file.length))
                            message.file = [];
                        message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorSet message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (let i = 0; i < message.file.length; ++i) {
                        let error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (let i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (let j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            FileDescriptorProto.create = function create(properties) {
                return new FileDescriptorProto(properties);
            };

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (let i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.messageType != null && message.messageType.length)
                    for (let i = 0; i < message.messageType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (let i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, "sourceCodeInfo"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.publicDependency != null && message.publicDependency.length)
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                if (message.weakDependency != null && message.weakDependency.length)
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message["package"] = reader.string();
                        break;
                    case 3:
                        if (!(message.dependency && message.dependency.length))
                            message.dependency = [];
                        message.dependency.push(reader.string());
                        break;
                    case 10:
                        if (!(message.publicDependency && message.publicDependency.length))
                            message.publicDependency = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.publicDependency.push(reader.int32());
                        } else
                            message.publicDependency.push(reader.int32());
                        break;
                    case 11:
                        if (!(message.weakDependency && message.weakDependency.length))
                            message.weakDependency = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weakDependency.push(reader.int32());
                        } else
                            message.weakDependency.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.messageType && message.messageType.length))
                            message.messageType = [];
                        message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.syntax = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (let i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (let i = 0; i < message.messageType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (let i = 0; i < message.service.length; ++i) {
                        let error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    let error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (let i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.publicDependency) {
                    if (!Array.isArray(object.publicDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                    message.publicDependency = [];
                    for (let i = 0; i < object.publicDependency.length; ++i)
                        message.publicDependency[i] = object.publicDependency[i] | 0;
                }
                if (object.weakDependency) {
                    if (!Array.isArray(object.weakDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                    message.weakDependency = [];
                    for (let i = 0; i < object.weakDependency.length; ++i)
                        message.weakDependency[i] = object.weakDependency[i] | 0;
                }
                if (object.messageType) {
                    if (!Array.isArray(object.messageType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                    message.messageType = [];
                    for (let i = 0; i < object.messageType.length; ++i) {
                        if (typeof object.messageType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                        message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (let i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.sourceCodeInfo != null) {
                    if (typeof object.sourceCodeInfo !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                    message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.messageType = [];
                    object.enumType = [];
                    object.service = [];
                    object.extension = [];
                    object.publicDependency = [];
                    object.weakDependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.sourceCodeInfo = null;
                    object.syntax = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (let j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.messageType && message.messageType.length) {
                    object.messageType = [];
                    for (let j = 0; j < message.messageType.length; ++j)
                        object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (let j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                if (message.publicDependency && message.publicDependency.length) {
                    object.publicDependency = [];
                    for (let j = 0; j < message.publicDependency.length; ++j)
                        object.publicDependency[j] = message.publicDependency[j];
                }
                if (message.weakDependency && message.weakDependency.length) {
                    object.weakDependency = [];
                    for (let j = 0; j < message.weakDependency.length; ++j)
                        object.weakDependency[j] = message.weakDependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                return object;
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            DescriptorProto.create = function create(properties) {
                return new DescriptorProto(properties);
            };

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (let i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nestedType != null && message.nestedType.length)
                    for (let i = 0; i < message.nestedType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extensionRange != null && message.extensionRange.length)
                    for (let i = 0; i < message.extensionRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneofDecl != null && message.oneofDecl.length)
                    for (let i = 0; i < message.oneofDecl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (let i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (let i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                return writer;
            };

            /**
             * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.field && message.field.length))
                            message.field = [];
                        message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.nestedType && message.nestedType.length))
                            message.nestedType = [];
                        message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.extensionRange && message.extensionRange.length))
                            message.extensionRange = [];
                        message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.oneofDecl && message.oneofDecl.length))
                            message.oneofDecl = [];
                        message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.reservedRange && message.reservedRange.length))
                            message.reservedRange = [];
                        message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.reservedName && message.reservedName.length))
                            message.reservedName = [];
                        message.reservedName.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescriptorProto message.
             * @function verify
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (let i = 0; i < message.field.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (let i = 0; i < message.nestedType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (let i = 0; i < message.extensionRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (let i = 0; i < message.oneofDecl.length; ++i) {
                        let error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (let i = 0; i < message.reservedRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (let i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                let message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (let i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nestedType) {
                    if (!Array.isArray(object.nestedType))
                        throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                    message.nestedType = [];
                    for (let i = 0; i < object.nestedType.length; ++i) {
                        if (typeof object.nestedType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                        message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.extensionRange) {
                    if (!Array.isArray(object.extensionRange))
                        throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                    message.extensionRange = [];
                    for (let i = 0; i < object.extensionRange.length; ++i) {
                        if (typeof object.extensionRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                        message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                    }
                }
                if (object.oneofDecl) {
                    if (!Array.isArray(object.oneofDecl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                    message.oneofDecl = [];
                    for (let i = 0; i < object.oneofDecl.length; ++i) {
                        if (typeof object.oneofDecl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                        message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (let i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (let i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nestedType = [];
                    object.enumType = [];
                    object.extensionRange = [];
                    object.extension = [];
                    object.oneofDecl = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (let j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nestedType && message.nestedType.length) {
                    object.nestedType = [];
                    for (let j = 0; j < message.nestedType.length; ++j)
                        object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.extensionRange && message.extensionRange.length) {
                    object.extensionRange = [];
                    for (let j = 0; j < message.extensionRange.length; ++j)
                        object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneofDecl && message.oneofDecl.length) {
                    object.oneofDecl = [];
                    for (let j = 0; j < message.oneofDecl.length; ++j)
                        object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                }
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (let j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (let j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.DescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                ExtensionRange.create = function create(properties) {
                    return new ExtensionRange(properties);
                };

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExtensionRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                ReservedRange.create = function create(properties) {
                    return new ReservedRange(properties);
                };

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            FieldDescriptorProto.create = function create(properties) {
                return new FieldDescriptorProto(properties);
            };

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneofIndex != null && Object.hasOwnProperty.call(message, "oneofIndex"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                if (message.jsonName != null && Object.hasOwnProperty.call(message, "jsonName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                return writer;
            };

            /**
             * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.number = reader.int32();
                        break;
                    case 4:
                        message.label = reader.int32();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        message.typeName = reader.string();
                        break;
                    case 2:
                        message.extendee = reader.string();
                        break;
                    case 7:
                        message.defaultValue = reader.string();
                        break;
                    case 9:
                        message.oneofIndex = reader.int32();
                        break;
                    case 10:
                        message.jsonName = reader.string();
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                }
                switch (object.type) {
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.typeName != null)
                    message.typeName = String(object.typeName);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.defaultValue != null)
                    message.defaultValue = String(object.defaultValue);
                if (object.oneofIndex != null)
                    message.oneofIndex = object.oneofIndex | 0;
                if (object.jsonName != null)
                    message.jsonName = String(object.jsonName);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.typeName = "";
                    object.defaultValue = "";
                    object.options = null;
                    object.oneofIndex = 0;
                    object.jsonName = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    object.typeName = message.typeName;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = message.defaultValue;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    object.oneofIndex = message.oneofIndex;
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    object.jsonName = message.jsonName;
                return object;
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {number}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {number}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            OneofDescriptorProto.create = function create(properties) {
                return new OneofDescriptorProto(properties);
            };

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            EnumDescriptorProto.create = function create(properties) {
                return new EnumDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (let i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (let i = 0; i < message.value.length; ++i) {
                        let error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (let i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (let j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            EnumValueDescriptorProto.create = function create(properties) {
                return new EnumValueDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.number = reader.int32();
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            ServiceDescriptorProto.create = function create(properties) {
                return new ServiceDescriptorProto(properties);
            };

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (let i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.method && message.method.length))
                            message.method = [];
                        message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (let i = 0; i < message.method.length; ++i) {
                        let error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (let i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (let j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            MethodDescriptorProto.create = function create(properties) {
                return new MethodDescriptorProto(properties);
            };

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.inputType != null && Object.hasOwnProperty.call(message, "inputType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clientStreaming != null && Object.hasOwnProperty.call(message, "clientStreaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                if (message.serverStreaming != null && Object.hasOwnProperty.call(message, "serverStreaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                return writer;
            };

            /**
             * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.inputType = reader.string();
                        break;
                    case 3:
                        message.outputType = reader.string();
                        break;
                    case 4:
                        message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.clientStreaming = reader.bool();
                        break;
                    case 6:
                        message.serverStreaming = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.inputType != null)
                    message.inputType = String(object.inputType);
                if (object.outputType != null)
                    message.outputType = String(object.outputType);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.clientStreaming != null)
                    message.clientStreaming = Boolean(object.clientStreaming);
                if (object.serverStreaming != null)
                    message.serverStreaming = Boolean(object.serverStreaming);
                return message;
            };

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.inputType = "";
                    object.outputType = "";
                    object.options = null;
                    object.clientStreaming = false;
                    object.serverStreaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    object.inputType = message.inputType;
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = message.outputType;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    object.clientStreaming = message.clientStreaming;
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    object.serverStreaming = message.serverStreaming;
                return object;
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = false;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            FileOptions.create = function create(properties) {
                return new FileOptions(properties);
            };

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.javaPackage != null && Object.hasOwnProperty.call(message, "javaPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, "javaOuterClassname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                if (message.optimizeFor != null && Object.hasOwnProperty.call(message, "optimizeFor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, "javaMultipleFiles"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                if (message.goPackage != null && Object.hasOwnProperty.call(message, "goPackage"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, "ccGenericServices"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, "javaGenericServices"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, "pyGenericServices"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, "javaGenerateEqualsAndHash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, "javaStringCheckUtf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, "ccEnableArenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, "objcClassPrefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, "csharpNamespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.javaPackage = reader.string();
                        break;
                    case 8:
                        message.javaOuterClassname = reader.string();
                        break;
                    case 10:
                        message.javaMultipleFiles = reader.bool();
                        break;
                    case 20:
                        message.javaGenerateEqualsAndHash = reader.bool();
                        break;
                    case 27:
                        message.javaStringCheckUtf8 = reader.bool();
                        break;
                    case 9:
                        message.optimizeFor = reader.int32();
                        break;
                    case 11:
                        message.goPackage = reader.string();
                        break;
                    case 16:
                        message.ccGenericServices = reader.bool();
                        break;
                    case 17:
                        message.javaGenericServices = reader.bool();
                        break;
                    case 18:
                        message.pyGenericServices = reader.bool();
                        break;
                    case 23:
                        message.deprecated = reader.bool();
                        break;
                    case 31:
                        message.ccEnableArenas = reader.bool();
                        break;
                    case 36:
                        message.objcClassPrefix = reader.string();
                        break;
                    case 37:
                        message.csharpNamespace = reader.string();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileOptions message.
             * @function verify
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                let message = new $root.google.protobuf.FileOptions();
                if (object.javaPackage != null)
                    message.javaPackage = String(object.javaPackage);
                if (object.javaOuterClassname != null)
                    message.javaOuterClassname = String(object.javaOuterClassname);
                if (object.javaMultipleFiles != null)
                    message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                if (object.javaGenerateEqualsAndHash != null)
                    message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                if (object.javaStringCheckUtf8 != null)
                    message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                switch (object.optimizeFor) {
                case "SPEED":
                case 1:
                    message.optimizeFor = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimizeFor = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimizeFor = 3;
                    break;
                }
                if (object.goPackage != null)
                    message.goPackage = String(object.goPackage);
                if (object.ccGenericServices != null)
                    message.ccGenericServices = Boolean(object.ccGenericServices);
                if (object.javaGenericServices != null)
                    message.javaGenericServices = Boolean(object.javaGenericServices);
                if (object.pyGenericServices != null)
                    message.pyGenericServices = Boolean(object.pyGenericServices);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.ccEnableArenas != null)
                    message.ccEnableArenas = Boolean(object.ccEnableArenas);
                if (object.objcClassPrefix != null)
                    message.objcClassPrefix = String(object.objcClassPrefix);
                if (object.csharpNamespace != null)
                    message.csharpNamespace = String(object.csharpNamespace);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.javaPackage = "";
                    object.javaOuterClassname = "";
                    object.optimizeFor = options.enums === String ? "SPEED" : 1;
                    object.javaMultipleFiles = false;
                    object.goPackage = "";
                    object.ccGenericServices = false;
                    object.javaGenericServices = false;
                    object.pyGenericServices = false;
                    object.javaGenerateEqualsAndHash = false;
                    object.deprecated = false;
                    object.javaStringCheckUtf8 = false;
                    object.ccEnableArenas = false;
                    object.objcClassPrefix = "";
                    object.csharpNamespace = "";
                }
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    object.javaPackage = message.javaPackage;
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    object.javaOuterClassname = message.javaOuterClassname;
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    object.javaMultipleFiles = message.javaMultipleFiles;
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    object.goPackage = message.goPackage;
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    object.ccGenericServices = message.ccGenericServices;
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    object.javaGenericServices = message.javaGenericServices;
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    object.pyGenericServices = message.pyGenericServices;
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    object.ccEnableArenas = message.ccEnableArenas;
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    object.objcClassPrefix = message.objcClassPrefix;
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    object.csharpNamespace = message.csharpNamespace;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FileOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {number}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             * @property {string|null} [".st.redisTableName"] MessageOptions .st.redisTableName
             * @property {string|null} [".st.primaryKeyField"] MessageOptions .st.primaryKeyField
             * @property {string|null} [".st.redisUnfinishedSetName"] MessageOptions .st.redisUnfinishedSetName
             * @property {string|null} [".st.redisFinishedSetName"] MessageOptions .st.redisFinishedSetName
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * MessageOptions .st.redisTableName.
             * @member {string} .st.redisTableName
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".st.redisTableName"] = "";

            /**
             * MessageOptions .st.primaryKeyField.
             * @member {string} .st.primaryKeyField
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".st.primaryKeyField"] = "";

            /**
             * MessageOptions .st.redisUnfinishedSetName.
             * @member {string} .st.redisUnfinishedSetName
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".st.redisUnfinishedSetName"] = "";

            /**
             * MessageOptions .st.redisFinishedSetName.
             * @member {string} .st.redisFinishedSetName
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".st.redisFinishedSetName"] = "";

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            MessageOptions.create = function create(properties) {
                return new MessageOptions(properties);
            };

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, "messageSetWireFormat"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, "noStandardDescriptorAccessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.mapEntry != null && Object.hasOwnProperty.call(message, "mapEntry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".st.redisTableName"] != null && Object.hasOwnProperty.call(message, ".st.redisTableName"))
                    writer.uint32(/* id 51234, wireType 2 =*/409874).string(message[".st.redisTableName"]);
                if (message[".st.primaryKeyField"] != null && Object.hasOwnProperty.call(message, ".st.primaryKeyField"))
                    writer.uint32(/* id 51235, wireType 2 =*/409882).string(message[".st.primaryKeyField"]);
                if (message[".st.redisUnfinishedSetName"] != null && Object.hasOwnProperty.call(message, ".st.redisUnfinishedSetName"))
                    writer.uint32(/* id 51236, wireType 2 =*/409890).string(message[".st.redisUnfinishedSetName"]);
                if (message[".st.redisFinishedSetName"] != null && Object.hasOwnProperty.call(message, ".st.redisFinishedSetName"))
                    writer.uint32(/* id 51237, wireType 2 =*/409898).string(message[".st.redisFinishedSetName"]);
                return writer;
            };

            /**
             * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageSetWireFormat = reader.bool();
                        break;
                    case 2:
                        message.noStandardDescriptorAccessor = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 7:
                        message.mapEntry = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 51234:
                        message[".st.redisTableName"] = reader.string();
                        break;
                    case 51235:
                        message[".st.primaryKeyField"] = reader.string();
                        break;
                    case 51236:
                        message[".st.redisUnfinishedSetName"] = reader.string();
                        break;
                    case 51237:
                        message[".st.redisFinishedSetName"] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageOptions message.
             * @function verify
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".st.redisTableName"] != null && message.hasOwnProperty(".st.redisTableName"))
                    if (!$util.isString(message[".st.redisTableName"]))
                        return ".st.redisTableName: string expected";
                if (message[".st.primaryKeyField"] != null && message.hasOwnProperty(".st.primaryKeyField"))
                    if (!$util.isString(message[".st.primaryKeyField"]))
                        return ".st.primaryKeyField: string expected";
                if (message[".st.redisUnfinishedSetName"] != null && message.hasOwnProperty(".st.redisUnfinishedSetName"))
                    if (!$util.isString(message[".st.redisUnfinishedSetName"]))
                        return ".st.redisUnfinishedSetName: string expected";
                if (message[".st.redisFinishedSetName"] != null && message.hasOwnProperty(".st.redisFinishedSetName"))
                    if (!$util.isString(message[".st.redisFinishedSetName"]))
                        return ".st.redisFinishedSetName: string expected";
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                let message = new $root.google.protobuf.MessageOptions();
                if (object.messageSetWireFormat != null)
                    message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                if (object.noStandardDescriptorAccessor != null)
                    message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.mapEntry != null)
                    message.mapEntry = Boolean(object.mapEntry);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".st.redisTableName"] != null)
                    message[".st.redisTableName"] = String(object[".st.redisTableName"]);
                if (object[".st.primaryKeyField"] != null)
                    message[".st.primaryKeyField"] = String(object[".st.primaryKeyField"]);
                if (object[".st.redisUnfinishedSetName"] != null)
                    message[".st.redisUnfinishedSetName"] = String(object[".st.redisUnfinishedSetName"]);
                if (object[".st.redisFinishedSetName"] != null)
                    message[".st.redisFinishedSetName"] = String(object[".st.redisFinishedSetName"]);
                return message;
            };

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.messageSetWireFormat = false;
                    object.noStandardDescriptorAccessor = false;
                    object.deprecated = false;
                    object.mapEntry = false;
                    object[".st.redisTableName"] = "";
                    object[".st.primaryKeyField"] = "";
                    object[".st.redisUnfinishedSetName"] = "";
                    object[".st.redisFinishedSetName"] = "";
                }
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    object.messageSetWireFormat = message.messageSetWireFormat;
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    object.mapEntry = message.mapEntry;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".st.redisTableName"] != null && message.hasOwnProperty(".st.redisTableName"))
                    object[".st.redisTableName"] = message[".st.redisTableName"];
                if (message[".st.primaryKeyField"] != null && message.hasOwnProperty(".st.primaryKeyField"))
                    object[".st.primaryKeyField"] = message[".st.primaryKeyField"];
                if (message[".st.redisUnfinishedSetName"] != null && message.hasOwnProperty(".st.redisUnfinishedSetName"))
                    object[".st.redisUnfinishedSetName"] = message[".st.redisUnfinishedSetName"];
                if (message[".st.redisFinishedSetName"] != null && message.hasOwnProperty(".st.redisFinishedSetName"))
                    object[".st.redisFinishedSetName"] = message[".st.redisFinishedSetName"];
                return object;
            };

            /**
             * Converts this MessageOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MessageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             * @property {boolean|null} [".st.mustNotEmpty"] FieldOptions .st.mustNotEmpty
             * @property {number|null} [".st.lengthMin"] FieldOptions .st.lengthMin
             * @property {number|null} [".st.lengthMax"] FieldOptions .st.lengthMax
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * FieldOptions .st.mustNotEmpty.
             * @member {boolean} .st.mustNotEmpty
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".st.mustNotEmpty"] = false;

            /**
             * FieldOptions .st.lengthMin.
             * @member {number} .st.lengthMin
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".st.lengthMin"] = 0;

            /**
             * FieldOptions .st.lengthMax.
             * @member {number} .st.lengthMax
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".st.lengthMax"] = 0;

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            FieldOptions.create = function create(properties) {
                return new FieldOptions(properties);
            };

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".st.mustNotEmpty"] != null && Object.hasOwnProperty.call(message, ".st.mustNotEmpty"))
                    writer.uint32(/* id 50000, wireType 0 =*/400000).bool(message[".st.mustNotEmpty"]);
                if (message[".st.lengthMin"] != null && Object.hasOwnProperty.call(message, ".st.lengthMin"))
                    writer.uint32(/* id 50001, wireType 0 =*/400008).uint32(message[".st.lengthMin"]);
                if (message[".st.lengthMax"] != null && Object.hasOwnProperty.call(message, ".st.lengthMax"))
                    writer.uint32(/* id 50002, wireType 0 =*/400016).uint32(message[".st.lengthMax"]);
                return writer;
            };

            /**
             * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ctype = reader.int32();
                        break;
                    case 2:
                        message.packed = reader.bool();
                        break;
                    case 6:
                        message.jstype = reader.int32();
                        break;
                    case 5:
                        message.lazy = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 10:
                        message.weak = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 50000:
                        message[".st.mustNotEmpty"] = reader.bool();
                        break;
                    case 50001:
                        message[".st.lengthMin"] = reader.uint32();
                        break;
                    case 50002:
                        message[".st.lengthMax"] = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldOptions message.
             * @function verify
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".st.mustNotEmpty"] != null && message.hasOwnProperty(".st.mustNotEmpty"))
                    if (typeof message[".st.mustNotEmpty"] !== "boolean")
                        return ".st.mustNotEmpty: boolean expected";
                if (message[".st.lengthMin"] != null && message.hasOwnProperty(".st.lengthMin"))
                    if (!$util.isInteger(message[".st.lengthMin"]))
                        return ".st.lengthMin: integer expected";
                if (message[".st.lengthMax"] != null && message.hasOwnProperty(".st.lengthMax"))
                    if (!$util.isInteger(message[".st.lengthMax"]))
                        return ".st.lengthMax: integer expected";
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                let message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".st.mustNotEmpty"] != null)
                    message[".st.mustNotEmpty"] = Boolean(object[".st.mustNotEmpty"]);
                if (object[".st.lengthMin"] != null)
                    message[".st.lengthMin"] = object[".st.lengthMin"] >>> 0;
                if (object[".st.lengthMax"] != null)
                    message[".st.lengthMax"] = object[".st.lengthMax"] >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                    object[".st.mustNotEmpty"] = false;
                    object[".st.lengthMin"] = 0;
                    object[".st.lengthMax"] = 0;
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".st.mustNotEmpty"] != null && message.hasOwnProperty(".st.mustNotEmpty"))
                    object[".st.mustNotEmpty"] = message[".st.mustNotEmpty"];
                if (message[".st.lengthMin"] != null && message.hasOwnProperty(".st.lengthMin"))
                    object[".st.lengthMin"] = message[".st.lengthMin"];
                if (message[".st.lengthMax"] != null && message.hasOwnProperty(".st.lengthMax"))
                    object[".st.lengthMax"] = message[".st.lengthMax"];
                return object;
            };

            /**
             * Converts this FieldOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {number}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {number}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            OneofOptions.create = function create(properties) {
                return new OneofOptions(properties);
            };

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofOptions message.
             * @function verify
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                let message = new $root.google.protobuf.OneofOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this OneofOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            EnumOptions.create = function create(properties) {
                return new EnumOptions(properties);
            };

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowAlias != null && Object.hasOwnProperty.call(message, "allowAlias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.allowAlias = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumOptions message.
             * @function verify
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                let message = new $root.google.protobuf.EnumOptions();
                if (object.allowAlias != null)
                    message.allowAlias = Boolean(object.allowAlias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.allowAlias = false;
                    object.deprecated = false;
                }
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    object.allowAlias = message.allowAlias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            EnumValueOptions.create = function create(properties) {
                return new EnumValueOptions(properties);
            };

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueOptions message.
             * @function verify
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                let message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            ServiceOptions.create = function create(properties) {
                return new ServiceOptions(properties);
            };

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceOptions message.
             * @function verify
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                let message = new $root.google.protobuf.ServiceOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            MethodOptions.create = function create(properties) {
                return new MethodOptions(properties);
            };

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodOptions message.
             * @function verify
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                let message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this MethodOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {number} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {number} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            UninterpretedOption.create = function create(properties) {
                return new UninterpretedOption(properties);
            };

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (let i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifierValue != null && Object.hasOwnProperty.call(message, "identifierValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, "positiveIntValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, "negativeIntValue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                if (message.aggregateValue != null && Object.hasOwnProperty.call(message, "aggregateValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                return writer;
            };

            /**
             * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.name && message.name.length))
                            message.name = [];
                        message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.identifierValue = reader.string();
                        break;
                    case 4:
                        message.positiveIntValue = reader.uint64();
                        break;
                    case 5:
                        message.negativeIntValue = reader.int64();
                        break;
                    case 6:
                        message.doubleValue = reader.double();
                        break;
                    case 7:
                        message.stringValue = reader.bytes();
                        break;
                    case 8:
                        message.aggregateValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UninterpretedOption message.
             * @function verify
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (let i = 0; i < message.name.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                let message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (let i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifierValue != null)
                    message.identifierValue = String(object.identifierValue);
                if (object.positiveIntValue != null)
                    if ($util.Long)
                        (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                    else if (typeof object.positiveIntValue === "string")
                        message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                    else if (typeof object.positiveIntValue === "number")
                        message.positiveIntValue = object.positiveIntValue;
                    else if (typeof object.positiveIntValue === "object")
                        message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                if (object.negativeIntValue != null)
                    if ($util.Long)
                        (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                    else if (typeof object.negativeIntValue === "string")
                        message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                    else if (typeof object.negativeIntValue === "number")
                        message.negativeIntValue = object.negativeIntValue;
                    else if (typeof object.negativeIntValue === "object")
                        message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.stringValue != null)
                    if (typeof object.stringValue === "string")
                        $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                    else if (object.stringValue.length)
                        message.stringValue = object.stringValue;
                if (object.aggregateValue != null)
                    message.aggregateValue = String(object.aggregateValue);
                return message;
            };

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifierValue = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positiveIntValue = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negativeIntValue = options.longs === String ? "0" : 0;
                    object.doubleValue = 0;
                    if (options.bytes === String)
                        object.stringValue = "";
                    else {
                        object.stringValue = [];
                        if (options.bytes !== Array)
                            object.stringValue = $util.newBuffer(object.stringValue);
                    }
                    object.aggregateValue = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (let j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    object.identifierValue = message.identifierValue;
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (typeof message.positiveIntValue === "number")
                        object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                    else
                        object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (typeof message.negativeIntValue === "number")
                        object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                    else
                        object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    object.aggregateValue = message.aggregateValue;
                return object;
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @function toJSON
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                NamePart.create = function create(properties) {
                    return new NamePart(properties);
                };

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                    return writer;
                };

                /**
                 * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.namePart = reader.string();
                            break;
                        case 2:
                            message.isExtension = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NamePart message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    let message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.namePart != null)
                        message.namePart = String(object.namePart);
                    if (object.isExtension != null)
                        message.isExtension = Boolean(object.isExtension);
                    return message;
                };

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.namePart = "";
                        object.isExtension = false;
                    }
                    if (message.namePart != null && message.hasOwnProperty("namePart"))
                        object.namePart = message.namePart;
                    if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                        object.isExtension = message.isExtension;
                    return object;
                };

                /**
                 * Converts this NamePart to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            SourceCodeInfo.create = function create(properties) {
                return new SourceCodeInfo(properties);
            };

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (let i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceCodeInfo message.
             * @function verify
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (let i = 0; i < message.location.length; ++i) {
                        let error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                let message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (let i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (let j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (let i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leadingComments != null && Object.hasOwnProperty.call(message, "leadingComments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                    if (message.trailingComments != null && Object.hasOwnProperty.call(message, "trailingComments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                    if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            if (!(message.span && message.span.length))
                                message.span = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.span.push(reader.int32());
                            } else
                                message.span.push(reader.int32());
                            break;
                        case 3:
                            message.leadingComments = reader.string();
                            break;
                        case 4:
                            message.trailingComments = reader.string();
                            break;
                        case 6:
                            if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                message.leadingDetachedComments = [];
                            message.leadingDetachedComments.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (let i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    let message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (let i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leadingComments != null)
                        message.leadingComments = String(object.leadingComments);
                    if (object.trailingComments != null)
                        message.trailingComments = String(object.trailingComments);
                    if (object.leadingDetachedComments) {
                        if (!Array.isArray(object.leadingDetachedComments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                        message.leadingDetachedComments = [];
                        for (let i = 0; i < object.leadingDetachedComments.length; ++i)
                            message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leadingDetachedComments = [];
                    }
                    if (options.defaults) {
                        object.leadingComments = "";
                        object.trailingComments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (let j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        object.leadingComments = message.leadingComments;
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        object.trailingComments = message.trailingComments;
                    if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                        object.leadingDetachedComments = [];
                        for (let j = 0; j < message.leadingDetachedComments.length; ++j)
                            object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                    }
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            GeneratedCodeInfo.create = function create(properties) {
                return new GeneratedCodeInfo(properties);
            };

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (let i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.annotation && message.annotation.length))
                            message.annotation = [];
                        message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeneratedCodeInfo message.
             * @function verify
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (let i = 0; i < message.annotation.length; ++i) {
                        let error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                let message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (let i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (let j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                Annotation.create = function create(properties) {
                    return new Annotation(properties);
                };

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.sourceFile != null && Object.hasOwnProperty.call(message, "sourceFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                    if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            message.sourceFile = reader.string();
                            break;
                        case 3:
                            message.begin = reader.int32();
                            break;
                        case 4:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Annotation message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    let message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.sourceFile != null)
                        message.sourceFile = String(object.sourceFile);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.sourceFile = "";
                        object.begin = 0;
                        object.end = 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        object.sourceFile = message.sourceFile;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this Annotation to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                let message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        return protobuf;
    })();

    return google;
})();

export const strategystatis = $root.strategystatis = (() => {

    /**
     * Namespace strategystatis.
     * @exports strategystatis
     * @namespace
     */
    const strategystatis = {};

    strategystatis.TradeTrendStatis = (function() {

        /**
         * Properties of a TradeTrendStatis.
         * @memberof strategystatis
         * @interface ITradeTrendStatis
         * @property {number|null} [tradeCnt] TradeTrendStatis tradeCnt
         * @property {number|null} [takerBidCnt] TradeTrendStatis takerBidCnt
         * @property {number|null} [takerAskCnt] TradeTrendStatis takerAskCnt
         * @property {number|null} [bidAskVaryCnt] TradeTrendStatis bidAskVaryCnt
         * @property {string|null} [priceVaryRatio] TradeTrendStatis priceVaryRatio
         */

        /**
         * Constructs a new TradeTrendStatis.
         * @memberof strategystatis
         * @classdesc Represents a TradeTrendStatis.
         * @implements ITradeTrendStatis
         * @constructor
         * @param {strategystatis.ITradeTrendStatis=} [properties] Properties to set
         */
        function TradeTrendStatis(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeTrendStatis tradeCnt.
         * @member {number} tradeCnt
         * @memberof strategystatis.TradeTrendStatis
         * @instance
         */
        TradeTrendStatis.prototype.tradeCnt = 0;

        /**
         * TradeTrendStatis takerBidCnt.
         * @member {number} takerBidCnt
         * @memberof strategystatis.TradeTrendStatis
         * @instance
         */
        TradeTrendStatis.prototype.takerBidCnt = 0;

        /**
         * TradeTrendStatis takerAskCnt.
         * @member {number} takerAskCnt
         * @memberof strategystatis.TradeTrendStatis
         * @instance
         */
        TradeTrendStatis.prototype.takerAskCnt = 0;

        /**
         * TradeTrendStatis bidAskVaryCnt.
         * @member {number} bidAskVaryCnt
         * @memberof strategystatis.TradeTrendStatis
         * @instance
         */
        TradeTrendStatis.prototype.bidAskVaryCnt = 0;

        /**
         * TradeTrendStatis priceVaryRatio.
         * @member {string} priceVaryRatio
         * @memberof strategystatis.TradeTrendStatis
         * @instance
         */
        TradeTrendStatis.prototype.priceVaryRatio = "";

        /**
         * Creates a new TradeTrendStatis instance using the specified properties.
         * @function create
         * @memberof strategystatis.TradeTrendStatis
         * @static
         * @param {strategystatis.ITradeTrendStatis=} [properties] Properties to set
         * @returns {strategystatis.TradeTrendStatis} TradeTrendStatis instance
         */
        TradeTrendStatis.create = function create(properties) {
            return new TradeTrendStatis(properties);
        };

        /**
         * Encodes the specified TradeTrendStatis message. Does not implicitly {@link strategystatis.TradeTrendStatis.verify|verify} messages.
         * @function encode
         * @memberof strategystatis.TradeTrendStatis
         * @static
         * @param {strategystatis.ITradeTrendStatis} message TradeTrendStatis message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeTrendStatis.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tradeCnt != null && Object.hasOwnProperty.call(message, "tradeCnt"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.tradeCnt);
            if (message.takerBidCnt != null && Object.hasOwnProperty.call(message, "takerBidCnt"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.takerBidCnt);
            if (message.takerAskCnt != null && Object.hasOwnProperty.call(message, "takerAskCnt"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.takerAskCnt);
            if (message.bidAskVaryCnt != null && Object.hasOwnProperty.call(message, "bidAskVaryCnt"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.bidAskVaryCnt);
            if (message.priceVaryRatio != null && Object.hasOwnProperty.call(message, "priceVaryRatio"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.priceVaryRatio);
            return writer;
        };

        /**
         * Encodes the specified TradeTrendStatis message, length delimited. Does not implicitly {@link strategystatis.TradeTrendStatis.verify|verify} messages.
         * @function encodeDelimited
         * @memberof strategystatis.TradeTrendStatis
         * @static
         * @param {strategystatis.ITradeTrendStatis} message TradeTrendStatis message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeTrendStatis.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeTrendStatis message from the specified reader or buffer.
         * @function decode
         * @memberof strategystatis.TradeTrendStatis
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {strategystatis.TradeTrendStatis} TradeTrendStatis
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeTrendStatis.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.strategystatis.TradeTrendStatis();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tradeCnt = reader.uint32();
                    break;
                case 2:
                    message.takerBidCnt = reader.uint32();
                    break;
                case 3:
                    message.takerAskCnt = reader.uint32();
                    break;
                case 4:
                    message.bidAskVaryCnt = reader.uint32();
                    break;
                case 5:
                    message.priceVaryRatio = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TradeTrendStatis message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof strategystatis.TradeTrendStatis
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {strategystatis.TradeTrendStatis} TradeTrendStatis
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeTrendStatis.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeTrendStatis message.
         * @function verify
         * @memberof strategystatis.TradeTrendStatis
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeTrendStatis.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tradeCnt != null && message.hasOwnProperty("tradeCnt"))
                if (!$util.isInteger(message.tradeCnt))
                    return "tradeCnt: integer expected";
            if (message.takerBidCnt != null && message.hasOwnProperty("takerBidCnt"))
                if (!$util.isInteger(message.takerBidCnt))
                    return "takerBidCnt: integer expected";
            if (message.takerAskCnt != null && message.hasOwnProperty("takerAskCnt"))
                if (!$util.isInteger(message.takerAskCnt))
                    return "takerAskCnt: integer expected";
            if (message.bidAskVaryCnt != null && message.hasOwnProperty("bidAskVaryCnt"))
                if (!$util.isInteger(message.bidAskVaryCnt))
                    return "bidAskVaryCnt: integer expected";
            if (message.priceVaryRatio != null && message.hasOwnProperty("priceVaryRatio"))
                if (!$util.isString(message.priceVaryRatio))
                    return "priceVaryRatio: string expected";
            return null;
        };

        /**
         * Creates a TradeTrendStatis message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof strategystatis.TradeTrendStatis
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {strategystatis.TradeTrendStatis} TradeTrendStatis
         */
        TradeTrendStatis.fromObject = function fromObject(object) {
            if (object instanceof $root.strategystatis.TradeTrendStatis)
                return object;
            let message = new $root.strategystatis.TradeTrendStatis();
            if (object.tradeCnt != null)
                message.tradeCnt = object.tradeCnt >>> 0;
            if (object.takerBidCnt != null)
                message.takerBidCnt = object.takerBidCnt >>> 0;
            if (object.takerAskCnt != null)
                message.takerAskCnt = object.takerAskCnt >>> 0;
            if (object.bidAskVaryCnt != null)
                message.bidAskVaryCnt = object.bidAskVaryCnt >>> 0;
            if (object.priceVaryRatio != null)
                message.priceVaryRatio = String(object.priceVaryRatio);
            return message;
        };

        /**
         * Creates a plain object from a TradeTrendStatis message. Also converts values to other types if specified.
         * @function toObject
         * @memberof strategystatis.TradeTrendStatis
         * @static
         * @param {strategystatis.TradeTrendStatis} message TradeTrendStatis
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeTrendStatis.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.tradeCnt = 0;
                object.takerBidCnt = 0;
                object.takerAskCnt = 0;
                object.bidAskVaryCnt = 0;
                object.priceVaryRatio = "";
            }
            if (message.tradeCnt != null && message.hasOwnProperty("tradeCnt"))
                object.tradeCnt = message.tradeCnt;
            if (message.takerBidCnt != null && message.hasOwnProperty("takerBidCnt"))
                object.takerBidCnt = message.takerBidCnt;
            if (message.takerAskCnt != null && message.hasOwnProperty("takerAskCnt"))
                object.takerAskCnt = message.takerAskCnt;
            if (message.bidAskVaryCnt != null && message.hasOwnProperty("bidAskVaryCnt"))
                object.bidAskVaryCnt = message.bidAskVaryCnt;
            if (message.priceVaryRatio != null && message.hasOwnProperty("priceVaryRatio"))
                object.priceVaryRatio = message.priceVaryRatio;
            return object;
        };

        /**
         * Converts this TradeTrendStatis to JSON.
         * @function toJSON
         * @memberof strategystatis.TradeTrendStatis
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeTrendStatis.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeTrendStatis;
    })();

    strategystatis.TradeTrendWindowStatis = (function() {

        /**
         * Properties of a TradeTrendWindowStatis.
         * @memberof strategystatis
         * @interface ITradeTrendWindowStatis
         * @property {number|null} [varyWindowCnt] TradeTrendWindowStatis varyWindowCnt
         * @property {number|null} [priceVaryRatio] TradeTrendWindowStatis priceVaryRatio
         */

        /**
         * Constructs a new TradeTrendWindowStatis.
         * @memberof strategystatis
         * @classdesc Represents a TradeTrendWindowStatis.
         * @implements ITradeTrendWindowStatis
         * @constructor
         * @param {strategystatis.ITradeTrendWindowStatis=} [properties] Properties to set
         */
        function TradeTrendWindowStatis(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeTrendWindowStatis varyWindowCnt.
         * @member {number} varyWindowCnt
         * @memberof strategystatis.TradeTrendWindowStatis
         * @instance
         */
        TradeTrendWindowStatis.prototype.varyWindowCnt = 0;

        /**
         * TradeTrendWindowStatis priceVaryRatio.
         * @member {number} priceVaryRatio
         * @memberof strategystatis.TradeTrendWindowStatis
         * @instance
         */
        TradeTrendWindowStatis.prototype.priceVaryRatio = 0;

        /**
         * Creates a new TradeTrendWindowStatis instance using the specified properties.
         * @function create
         * @memberof strategystatis.TradeTrendWindowStatis
         * @static
         * @param {strategystatis.ITradeTrendWindowStatis=} [properties] Properties to set
         * @returns {strategystatis.TradeTrendWindowStatis} TradeTrendWindowStatis instance
         */
        TradeTrendWindowStatis.create = function create(properties) {
            return new TradeTrendWindowStatis(properties);
        };

        /**
         * Encodes the specified TradeTrendWindowStatis message. Does not implicitly {@link strategystatis.TradeTrendWindowStatis.verify|verify} messages.
         * @function encode
         * @memberof strategystatis.TradeTrendWindowStatis
         * @static
         * @param {strategystatis.ITradeTrendWindowStatis} message TradeTrendWindowStatis message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeTrendWindowStatis.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.varyWindowCnt != null && Object.hasOwnProperty.call(message, "varyWindowCnt"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.varyWindowCnt);
            if (message.priceVaryRatio != null && Object.hasOwnProperty.call(message, "priceVaryRatio"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.priceVaryRatio);
            return writer;
        };

        /**
         * Encodes the specified TradeTrendWindowStatis message, length delimited. Does not implicitly {@link strategystatis.TradeTrendWindowStatis.verify|verify} messages.
         * @function encodeDelimited
         * @memberof strategystatis.TradeTrendWindowStatis
         * @static
         * @param {strategystatis.ITradeTrendWindowStatis} message TradeTrendWindowStatis message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeTrendWindowStatis.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeTrendWindowStatis message from the specified reader or buffer.
         * @function decode
         * @memberof strategystatis.TradeTrendWindowStatis
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {strategystatis.TradeTrendWindowStatis} TradeTrendWindowStatis
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeTrendWindowStatis.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.strategystatis.TradeTrendWindowStatis();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.varyWindowCnt = reader.uint32();
                    break;
                case 2:
                    message.priceVaryRatio = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TradeTrendWindowStatis message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof strategystatis.TradeTrendWindowStatis
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {strategystatis.TradeTrendWindowStatis} TradeTrendWindowStatis
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeTrendWindowStatis.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeTrendWindowStatis message.
         * @function verify
         * @memberof strategystatis.TradeTrendWindowStatis
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeTrendWindowStatis.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.varyWindowCnt != null && message.hasOwnProperty("varyWindowCnt"))
                if (!$util.isInteger(message.varyWindowCnt))
                    return "varyWindowCnt: integer expected";
            if (message.priceVaryRatio != null && message.hasOwnProperty("priceVaryRatio"))
                if (!$util.isInteger(message.priceVaryRatio))
                    return "priceVaryRatio: integer expected";
            return null;
        };

        /**
         * Creates a TradeTrendWindowStatis message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof strategystatis.TradeTrendWindowStatis
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {strategystatis.TradeTrendWindowStatis} TradeTrendWindowStatis
         */
        TradeTrendWindowStatis.fromObject = function fromObject(object) {
            if (object instanceof $root.strategystatis.TradeTrendWindowStatis)
                return object;
            let message = new $root.strategystatis.TradeTrendWindowStatis();
            if (object.varyWindowCnt != null)
                message.varyWindowCnt = object.varyWindowCnt >>> 0;
            if (object.priceVaryRatio != null)
                message.priceVaryRatio = object.priceVaryRatio >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a TradeTrendWindowStatis message. Also converts values to other types if specified.
         * @function toObject
         * @memberof strategystatis.TradeTrendWindowStatis
         * @static
         * @param {strategystatis.TradeTrendWindowStatis} message TradeTrendWindowStatis
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeTrendWindowStatis.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.varyWindowCnt = 0;
                object.priceVaryRatio = 0;
            }
            if (message.varyWindowCnt != null && message.hasOwnProperty("varyWindowCnt"))
                object.varyWindowCnt = message.varyWindowCnt;
            if (message.priceVaryRatio != null && message.hasOwnProperty("priceVaryRatio"))
                object.priceVaryRatio = message.priceVaryRatio;
            return object;
        };

        /**
         * Converts this TradeTrendWindowStatis to JSON.
         * @function toJSON
         * @memberof strategystatis.TradeTrendWindowStatis
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeTrendWindowStatis.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeTrendWindowStatis;
    })();

    return strategystatis;
})();

export const datatype = $root.datatype = (() => {

    /**
     * Namespace datatype.
     * @exports datatype
     * @namespace
     */
    const datatype = {};

    datatype.Exchange = (function() {

        /**
         * Properties of an Exchange.
         * @memberof datatype
         * @interface IExchange
         * @property {string|null} [value] Exchange value
         * @property {string|null} [name] Exchange name
         * @property {string|null} [desc] Exchange desc
         */

        /**
         * Constructs a new Exchange.
         * @memberof datatype
         * @classdesc Represents an Exchange.
         * @implements IExchange
         * @constructor
         * @param {datatype.IExchange=} [properties] Properties to set
         */
        function Exchange(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Exchange value.
         * @member {string} value
         * @memberof datatype.Exchange
         * @instance
         */
        Exchange.prototype.value = "";

        /**
         * Exchange name.
         * @member {string} name
         * @memberof datatype.Exchange
         * @instance
         */
        Exchange.prototype.name = "";

        /**
         * Exchange desc.
         * @member {string} desc
         * @memberof datatype.Exchange
         * @instance
         */
        Exchange.prototype.desc = "";

        /**
         * Creates a new Exchange instance using the specified properties.
         * @function create
         * @memberof datatype.Exchange
         * @static
         * @param {datatype.IExchange=} [properties] Properties to set
         * @returns {datatype.Exchange} Exchange instance
         */
        Exchange.create = function create(properties) {
            return new Exchange(properties);
        };

        /**
         * Encodes the specified Exchange message. Does not implicitly {@link datatype.Exchange.verify|verify} messages.
         * @function encode
         * @memberof datatype.Exchange
         * @static
         * @param {datatype.IExchange} message Exchange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Exchange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.desc != null && Object.hasOwnProperty.call(message, "desc"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.desc);
            return writer;
        };

        /**
         * Encodes the specified Exchange message, length delimited. Does not implicitly {@link datatype.Exchange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.Exchange
         * @static
         * @param {datatype.IExchange} message Exchange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Exchange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Exchange message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.Exchange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.Exchange} Exchange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Exchange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.Exchange();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.desc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Exchange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.Exchange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.Exchange} Exchange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Exchange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Exchange message.
         * @function verify
         * @memberof datatype.Exchange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Exchange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.desc != null && message.hasOwnProperty("desc"))
                if (!$util.isString(message.desc))
                    return "desc: string expected";
            return null;
        };

        /**
         * Creates an Exchange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.Exchange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.Exchange} Exchange
         */
        Exchange.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.Exchange)
                return object;
            let message = new $root.datatype.Exchange();
            if (object.value != null)
                message.value = String(object.value);
            if (object.name != null)
                message.name = String(object.name);
            if (object.desc != null)
                message.desc = String(object.desc);
            return message;
        };

        /**
         * Creates a plain object from an Exchange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.Exchange
         * @static
         * @param {datatype.Exchange} message Exchange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Exchange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.value = "";
                object.name = "";
                object.desc = "";
            }
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.desc != null && message.hasOwnProperty("desc"))
                object.desc = message.desc;
            return object;
        };

        /**
         * Converts this Exchange to JSON.
         * @function toJSON
         * @memberof datatype.Exchange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Exchange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Exchange;
    })();

    datatype.ConfigReq = (function() {

        /**
         * Properties of a ConfigReq.
         * @memberof datatype
         * @interface IConfigReq
         * @property {string|null} [source] ConfigReq source
         */

        /**
         * Constructs a new ConfigReq.
         * @memberof datatype
         * @classdesc Represents a ConfigReq.
         * @implements IConfigReq
         * @constructor
         * @param {datatype.IConfigReq=} [properties] Properties to set
         */
        function ConfigReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConfigReq source.
         * @member {string} source
         * @memberof datatype.ConfigReq
         * @instance
         */
        ConfigReq.prototype.source = "";

        /**
         * Creates a new ConfigReq instance using the specified properties.
         * @function create
         * @memberof datatype.ConfigReq
         * @static
         * @param {datatype.IConfigReq=} [properties] Properties to set
         * @returns {datatype.ConfigReq} ConfigReq instance
         */
        ConfigReq.create = function create(properties) {
            return new ConfigReq(properties);
        };

        /**
         * Encodes the specified ConfigReq message. Does not implicitly {@link datatype.ConfigReq.verify|verify} messages.
         * @function encode
         * @memberof datatype.ConfigReq
         * @static
         * @param {datatype.IConfigReq} message ConfigReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfigReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                writer.uint32(/* id 100, wireType 2 =*/802).string(message.source);
            return writer;
        };

        /**
         * Encodes the specified ConfigReq message, length delimited. Does not implicitly {@link datatype.ConfigReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.ConfigReq
         * @static
         * @param {datatype.IConfigReq} message ConfigReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfigReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConfigReq message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.ConfigReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.ConfigReq} ConfigReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfigReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.ConfigReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 100:
                    message.source = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConfigReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.ConfigReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.ConfigReq} ConfigReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfigReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConfigReq message.
         * @function verify
         * @memberof datatype.ConfigReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConfigReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!$util.isString(message.source))
                    return "source: string expected";
            return null;
        };

        /**
         * Creates a ConfigReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.ConfigReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.ConfigReq} ConfigReq
         */
        ConfigReq.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.ConfigReq)
                return object;
            let message = new $root.datatype.ConfigReq();
            if (object.source != null)
                message.source = String(object.source);
            return message;
        };

        /**
         * Creates a plain object from a ConfigReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.ConfigReq
         * @static
         * @param {datatype.ConfigReq} message ConfigReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConfigReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.source = "";
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = message.source;
            return object;
        };

        /**
         * Converts this ConfigReq to JSON.
         * @function toJSON
         * @memberof datatype.ConfigReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConfigReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConfigReq;
    })();

    datatype.ConfigResp = (function() {

        /**
         * Properties of a ConfigResp.
         * @memberof datatype
         * @interface IConfigResp
         * @property {boolean|null} [supportsSearch] ConfigResp supportsSearch
         * @property {boolean|null} [supportsGroupRequest] ConfigResp supportsGroupRequest
         * @property {Array.<string>|null} [supportedResolutions] ConfigResp supportedResolutions
         * @property {boolean|null} [supportsMarks] ConfigResp supportsMarks
         * @property {boolean|null} [supportsTime] ConfigResp supportsTime
         * @property {Array.<datatype.IExchange>|null} [exchanges] ConfigResp exchanges
         * @property {Array.<string>|null} [symbolsTypes] ConfigResp symbolsTypes
         * @property {Array.<string>|null} [currencyCodes] ConfigResp currencyCodes
         * @property {boolean|null} [supportsTimescaleMark] ConfigResp supportsTimescaleMark
         * @property {string|null} [futuresRegex] ConfigResp futuresRegex
         */

        /**
         * Constructs a new ConfigResp.
         * @memberof datatype
         * @classdesc Represents a ConfigResp.
         * @implements IConfigResp
         * @constructor
         * @param {datatype.IConfigResp=} [properties] Properties to set
         */
        function ConfigResp(properties) {
            this.supportedResolutions = [];
            this.exchanges = [];
            this.symbolsTypes = [];
            this.currencyCodes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConfigResp supportsSearch.
         * @member {boolean} supportsSearch
         * @memberof datatype.ConfigResp
         * @instance
         */
        ConfigResp.prototype.supportsSearch = false;

        /**
         * ConfigResp supportsGroupRequest.
         * @member {boolean} supportsGroupRequest
         * @memberof datatype.ConfigResp
         * @instance
         */
        ConfigResp.prototype.supportsGroupRequest = false;

        /**
         * ConfigResp supportedResolutions.
         * @member {Array.<string>} supportedResolutions
         * @memberof datatype.ConfigResp
         * @instance
         */
        ConfigResp.prototype.supportedResolutions = $util.emptyArray;

        /**
         * ConfigResp supportsMarks.
         * @member {boolean} supportsMarks
         * @memberof datatype.ConfigResp
         * @instance
         */
        ConfigResp.prototype.supportsMarks = false;

        /**
         * ConfigResp supportsTime.
         * @member {boolean} supportsTime
         * @memberof datatype.ConfigResp
         * @instance
         */
        ConfigResp.prototype.supportsTime = false;

        /**
         * ConfigResp exchanges.
         * @member {Array.<datatype.IExchange>} exchanges
         * @memberof datatype.ConfigResp
         * @instance
         */
        ConfigResp.prototype.exchanges = $util.emptyArray;

        /**
         * ConfigResp symbolsTypes.
         * @member {Array.<string>} symbolsTypes
         * @memberof datatype.ConfigResp
         * @instance
         */
        ConfigResp.prototype.symbolsTypes = $util.emptyArray;

        /**
         * ConfigResp currencyCodes.
         * @member {Array.<string>} currencyCodes
         * @memberof datatype.ConfigResp
         * @instance
         */
        ConfigResp.prototype.currencyCodes = $util.emptyArray;

        /**
         * ConfigResp supportsTimescaleMark.
         * @member {boolean} supportsTimescaleMark
         * @memberof datatype.ConfigResp
         * @instance
         */
        ConfigResp.prototype.supportsTimescaleMark = false;

        /**
         * ConfigResp futuresRegex.
         * @member {string} futuresRegex
         * @memberof datatype.ConfigResp
         * @instance
         */
        ConfigResp.prototype.futuresRegex = "";

        /**
         * Creates a new ConfigResp instance using the specified properties.
         * @function create
         * @memberof datatype.ConfigResp
         * @static
         * @param {datatype.IConfigResp=} [properties] Properties to set
         * @returns {datatype.ConfigResp} ConfigResp instance
         */
        ConfigResp.create = function create(properties) {
            return new ConfigResp(properties);
        };

        /**
         * Encodes the specified ConfigResp message. Does not implicitly {@link datatype.ConfigResp.verify|verify} messages.
         * @function encode
         * @memberof datatype.ConfigResp
         * @static
         * @param {datatype.IConfigResp} message ConfigResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfigResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.supportsSearch != null && Object.hasOwnProperty.call(message, "supportsSearch"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.supportsSearch);
            if (message.supportsGroupRequest != null && Object.hasOwnProperty.call(message, "supportsGroupRequest"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.supportsGroupRequest);
            if (message.supportedResolutions != null && message.supportedResolutions.length)
                for (let i = 0; i < message.supportedResolutions.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.supportedResolutions[i]);
            if (message.supportsMarks != null && Object.hasOwnProperty.call(message, "supportsMarks"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.supportsMarks);
            if (message.supportsTime != null && Object.hasOwnProperty.call(message, "supportsTime"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.supportsTime);
            if (message.exchanges != null && message.exchanges.length)
                for (let i = 0; i < message.exchanges.length; ++i)
                    $root.datatype.Exchange.encode(message.exchanges[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.symbolsTypes != null && message.symbolsTypes.length)
                for (let i = 0; i < message.symbolsTypes.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.symbolsTypes[i]);
            if (message.currencyCodes != null && message.currencyCodes.length)
                for (let i = 0; i < message.currencyCodes.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.currencyCodes[i]);
            if (message.supportsTimescaleMark != null && Object.hasOwnProperty.call(message, "supportsTimescaleMark"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.supportsTimescaleMark);
            if (message.futuresRegex != null && Object.hasOwnProperty.call(message, "futuresRegex"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.futuresRegex);
            return writer;
        };

        /**
         * Encodes the specified ConfigResp message, length delimited. Does not implicitly {@link datatype.ConfigResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.ConfigResp
         * @static
         * @param {datatype.IConfigResp} message ConfigResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfigResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConfigResp message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.ConfigResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.ConfigResp} ConfigResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfigResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.ConfigResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.supportsSearch = reader.bool();
                    break;
                case 2:
                    message.supportsGroupRequest = reader.bool();
                    break;
                case 3:
                    if (!(message.supportedResolutions && message.supportedResolutions.length))
                        message.supportedResolutions = [];
                    message.supportedResolutions.push(reader.string());
                    break;
                case 4:
                    message.supportsMarks = reader.bool();
                    break;
                case 5:
                    message.supportsTime = reader.bool();
                    break;
                case 6:
                    if (!(message.exchanges && message.exchanges.length))
                        message.exchanges = [];
                    message.exchanges.push($root.datatype.Exchange.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.symbolsTypes && message.symbolsTypes.length))
                        message.symbolsTypes = [];
                    message.symbolsTypes.push(reader.string());
                    break;
                case 8:
                    if (!(message.currencyCodes && message.currencyCodes.length))
                        message.currencyCodes = [];
                    message.currencyCodes.push(reader.string());
                    break;
                case 9:
                    message.supportsTimescaleMark = reader.bool();
                    break;
                case 10:
                    message.futuresRegex = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConfigResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.ConfigResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.ConfigResp} ConfigResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfigResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConfigResp message.
         * @function verify
         * @memberof datatype.ConfigResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConfigResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.supportsSearch != null && message.hasOwnProperty("supportsSearch"))
                if (typeof message.supportsSearch !== "boolean")
                    return "supportsSearch: boolean expected";
            if (message.supportsGroupRequest != null && message.hasOwnProperty("supportsGroupRequest"))
                if (typeof message.supportsGroupRequest !== "boolean")
                    return "supportsGroupRequest: boolean expected";
            if (message.supportedResolutions != null && message.hasOwnProperty("supportedResolutions")) {
                if (!Array.isArray(message.supportedResolutions))
                    return "supportedResolutions: array expected";
                for (let i = 0; i < message.supportedResolutions.length; ++i)
                    if (!$util.isString(message.supportedResolutions[i]))
                        return "supportedResolutions: string[] expected";
            }
            if (message.supportsMarks != null && message.hasOwnProperty("supportsMarks"))
                if (typeof message.supportsMarks !== "boolean")
                    return "supportsMarks: boolean expected";
            if (message.supportsTime != null && message.hasOwnProperty("supportsTime"))
                if (typeof message.supportsTime !== "boolean")
                    return "supportsTime: boolean expected";
            if (message.exchanges != null && message.hasOwnProperty("exchanges")) {
                if (!Array.isArray(message.exchanges))
                    return "exchanges: array expected";
                for (let i = 0; i < message.exchanges.length; ++i) {
                    let error = $root.datatype.Exchange.verify(message.exchanges[i]);
                    if (error)
                        return "exchanges." + error;
                }
            }
            if (message.symbolsTypes != null && message.hasOwnProperty("symbolsTypes")) {
                if (!Array.isArray(message.symbolsTypes))
                    return "symbolsTypes: array expected";
                for (let i = 0; i < message.symbolsTypes.length; ++i)
                    if (!$util.isString(message.symbolsTypes[i]))
                        return "symbolsTypes: string[] expected";
            }
            if (message.currencyCodes != null && message.hasOwnProperty("currencyCodes")) {
                if (!Array.isArray(message.currencyCodes))
                    return "currencyCodes: array expected";
                for (let i = 0; i < message.currencyCodes.length; ++i)
                    if (!$util.isString(message.currencyCodes[i]))
                        return "currencyCodes: string[] expected";
            }
            if (message.supportsTimescaleMark != null && message.hasOwnProperty("supportsTimescaleMark"))
                if (typeof message.supportsTimescaleMark !== "boolean")
                    return "supportsTimescaleMark: boolean expected";
            if (message.futuresRegex != null && message.hasOwnProperty("futuresRegex"))
                if (!$util.isString(message.futuresRegex))
                    return "futuresRegex: string expected";
            return null;
        };

        /**
         * Creates a ConfigResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.ConfigResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.ConfigResp} ConfigResp
         */
        ConfigResp.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.ConfigResp)
                return object;
            let message = new $root.datatype.ConfigResp();
            if (object.supportsSearch != null)
                message.supportsSearch = Boolean(object.supportsSearch);
            if (object.supportsGroupRequest != null)
                message.supportsGroupRequest = Boolean(object.supportsGroupRequest);
            if (object.supportedResolutions) {
                if (!Array.isArray(object.supportedResolutions))
                    throw TypeError(".datatype.ConfigResp.supportedResolutions: array expected");
                message.supportedResolutions = [];
                for (let i = 0; i < object.supportedResolutions.length; ++i)
                    message.supportedResolutions[i] = String(object.supportedResolutions[i]);
            }
            if (object.supportsMarks != null)
                message.supportsMarks = Boolean(object.supportsMarks);
            if (object.supportsTime != null)
                message.supportsTime = Boolean(object.supportsTime);
            if (object.exchanges) {
                if (!Array.isArray(object.exchanges))
                    throw TypeError(".datatype.ConfigResp.exchanges: array expected");
                message.exchanges = [];
                for (let i = 0; i < object.exchanges.length; ++i) {
                    if (typeof object.exchanges[i] !== "object")
                        throw TypeError(".datatype.ConfigResp.exchanges: object expected");
                    message.exchanges[i] = $root.datatype.Exchange.fromObject(object.exchanges[i]);
                }
            }
            if (object.symbolsTypes) {
                if (!Array.isArray(object.symbolsTypes))
                    throw TypeError(".datatype.ConfigResp.symbolsTypes: array expected");
                message.symbolsTypes = [];
                for (let i = 0; i < object.symbolsTypes.length; ++i)
                    message.symbolsTypes[i] = String(object.symbolsTypes[i]);
            }
            if (object.currencyCodes) {
                if (!Array.isArray(object.currencyCodes))
                    throw TypeError(".datatype.ConfigResp.currencyCodes: array expected");
                message.currencyCodes = [];
                for (let i = 0; i < object.currencyCodes.length; ++i)
                    message.currencyCodes[i] = String(object.currencyCodes[i]);
            }
            if (object.supportsTimescaleMark != null)
                message.supportsTimescaleMark = Boolean(object.supportsTimescaleMark);
            if (object.futuresRegex != null)
                message.futuresRegex = String(object.futuresRegex);
            return message;
        };

        /**
         * Creates a plain object from a ConfigResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.ConfigResp
         * @static
         * @param {datatype.ConfigResp} message ConfigResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConfigResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.supportedResolutions = [];
                object.exchanges = [];
                object.symbolsTypes = [];
                object.currencyCodes = [];
            }
            if (options.defaults) {
                object.supportsSearch = false;
                object.supportsGroupRequest = false;
                object.supportsMarks = false;
                object.supportsTime = false;
                object.supportsTimescaleMark = false;
                object.futuresRegex = "";
            }
            if (message.supportsSearch != null && message.hasOwnProperty("supportsSearch"))
                object.supportsSearch = message.supportsSearch;
            if (message.supportsGroupRequest != null && message.hasOwnProperty("supportsGroupRequest"))
                object.supportsGroupRequest = message.supportsGroupRequest;
            if (message.supportedResolutions && message.supportedResolutions.length) {
                object.supportedResolutions = [];
                for (let j = 0; j < message.supportedResolutions.length; ++j)
                    object.supportedResolutions[j] = message.supportedResolutions[j];
            }
            if (message.supportsMarks != null && message.hasOwnProperty("supportsMarks"))
                object.supportsMarks = message.supportsMarks;
            if (message.supportsTime != null && message.hasOwnProperty("supportsTime"))
                object.supportsTime = message.supportsTime;
            if (message.exchanges && message.exchanges.length) {
                object.exchanges = [];
                for (let j = 0; j < message.exchanges.length; ++j)
                    object.exchanges[j] = $root.datatype.Exchange.toObject(message.exchanges[j], options);
            }
            if (message.symbolsTypes && message.symbolsTypes.length) {
                object.symbolsTypes = [];
                for (let j = 0; j < message.symbolsTypes.length; ++j)
                    object.symbolsTypes[j] = message.symbolsTypes[j];
            }
            if (message.currencyCodes && message.currencyCodes.length) {
                object.currencyCodes = [];
                for (let j = 0; j < message.currencyCodes.length; ++j)
                    object.currencyCodes[j] = message.currencyCodes[j];
            }
            if (message.supportsTimescaleMark != null && message.hasOwnProperty("supportsTimescaleMark"))
                object.supportsTimescaleMark = message.supportsTimescaleMark;
            if (message.futuresRegex != null && message.hasOwnProperty("futuresRegex"))
                object.futuresRegex = message.futuresRegex;
            return object;
        };

        /**
         * Converts this ConfigResp to JSON.
         * @function toJSON
         * @memberof datatype.ConfigResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConfigResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConfigResp;
    })();

    datatype.SymbolGroupInfoReq = (function() {

        /**
         * Properties of a SymbolGroupInfoReq.
         * @memberof datatype
         * @interface ISymbolGroupInfoReq
         * @property {string|null} [group] SymbolGroupInfoReq group
         * @property {string|null} [source] SymbolGroupInfoReq source
         */

        /**
         * Constructs a new SymbolGroupInfoReq.
         * @memberof datatype
         * @classdesc Represents a SymbolGroupInfoReq.
         * @implements ISymbolGroupInfoReq
         * @constructor
         * @param {datatype.ISymbolGroupInfoReq=} [properties] Properties to set
         */
        function SymbolGroupInfoReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SymbolGroupInfoReq group.
         * @member {string} group
         * @memberof datatype.SymbolGroupInfoReq
         * @instance
         */
        SymbolGroupInfoReq.prototype.group = "";

        /**
         * SymbolGroupInfoReq source.
         * @member {string} source
         * @memberof datatype.SymbolGroupInfoReq
         * @instance
         */
        SymbolGroupInfoReq.prototype.source = "";

        /**
         * Creates a new SymbolGroupInfoReq instance using the specified properties.
         * @function create
         * @memberof datatype.SymbolGroupInfoReq
         * @static
         * @param {datatype.ISymbolGroupInfoReq=} [properties] Properties to set
         * @returns {datatype.SymbolGroupInfoReq} SymbolGroupInfoReq instance
         */
        SymbolGroupInfoReq.create = function create(properties) {
            return new SymbolGroupInfoReq(properties);
        };

        /**
         * Encodes the specified SymbolGroupInfoReq message. Does not implicitly {@link datatype.SymbolGroupInfoReq.verify|verify} messages.
         * @function encode
         * @memberof datatype.SymbolGroupInfoReq
         * @static
         * @param {datatype.ISymbolGroupInfoReq} message SymbolGroupInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolGroupInfoReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.group != null && Object.hasOwnProperty.call(message, "group"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.group);
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                writer.uint32(/* id 100, wireType 2 =*/802).string(message.source);
            return writer;
        };

        /**
         * Encodes the specified SymbolGroupInfoReq message, length delimited. Does not implicitly {@link datatype.SymbolGroupInfoReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.SymbolGroupInfoReq
         * @static
         * @param {datatype.ISymbolGroupInfoReq} message SymbolGroupInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolGroupInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SymbolGroupInfoReq message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.SymbolGroupInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.SymbolGroupInfoReq} SymbolGroupInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolGroupInfoReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.SymbolGroupInfoReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.group = reader.string();
                    break;
                case 100:
                    message.source = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SymbolGroupInfoReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.SymbolGroupInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.SymbolGroupInfoReq} SymbolGroupInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolGroupInfoReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SymbolGroupInfoReq message.
         * @function verify
         * @memberof datatype.SymbolGroupInfoReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SymbolGroupInfoReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.group != null && message.hasOwnProperty("group"))
                if (!$util.isString(message.group))
                    return "group: string expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!$util.isString(message.source))
                    return "source: string expected";
            return null;
        };

        /**
         * Creates a SymbolGroupInfoReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.SymbolGroupInfoReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.SymbolGroupInfoReq} SymbolGroupInfoReq
         */
        SymbolGroupInfoReq.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.SymbolGroupInfoReq)
                return object;
            let message = new $root.datatype.SymbolGroupInfoReq();
            if (object.group != null)
                message.group = String(object.group);
            if (object.source != null)
                message.source = String(object.source);
            return message;
        };

        /**
         * Creates a plain object from a SymbolGroupInfoReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.SymbolGroupInfoReq
         * @static
         * @param {datatype.SymbolGroupInfoReq} message SymbolGroupInfoReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SymbolGroupInfoReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.group = "";
                object.source = "";
            }
            if (message.group != null && message.hasOwnProperty("group"))
                object.group = message.group;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = message.source;
            return object;
        };

        /**
         * Converts this SymbolGroupInfoReq to JSON.
         * @function toJSON
         * @memberof datatype.SymbolGroupInfoReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SymbolGroupInfoReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SymbolGroupInfoReq;
    })();

    datatype.SymbolGroupInfoResp = (function() {

        /**
         * Properties of a SymbolGroupInfoResp.
         * @memberof datatype
         * @interface ISymbolGroupInfoResp
         * @property {Array.<string>|null} [symbol] SymbolGroupInfoResp symbol
         * @property {Array.<string>|null} [desceiption] SymbolGroupInfoResp desceiption
         * @property {string|null} [exchangeListed] SymbolGroupInfoResp exchangeListed
         * @property {number|null} [minmov] SymbolGroupInfoResp minmov
         * @property {number|null} [minmov2] SymbolGroupInfoResp minmov2
         * @property {Array.<number>|null} [pricescale] SymbolGroupInfoResp pricescale
         * @property {boolean|null} [hasDwm] SymbolGroupInfoResp hasDwm
         * @property {boolean|null} [hasIntraday] SymbolGroupInfoResp hasIntraday
         * @property {Array.<boolean>|null} [hasNoVolume] SymbolGroupInfoResp hasNoVolume
         * @property {Array.<string>|null} [type] SymbolGroupInfoResp type
         * @property {Array.<string>|null} [ticker] SymbolGroupInfoResp ticker
         * @property {string|null} [timezone] SymbolGroupInfoResp timezone
         * @property {string|null} [sessionRegular] SymbolGroupInfoResp sessionRegular
         */

        /**
         * Constructs a new SymbolGroupInfoResp.
         * @memberof datatype
         * @classdesc Represents a SymbolGroupInfoResp.
         * @implements ISymbolGroupInfoResp
         * @constructor
         * @param {datatype.ISymbolGroupInfoResp=} [properties] Properties to set
         */
        function SymbolGroupInfoResp(properties) {
            this.symbol = [];
            this.desceiption = [];
            this.pricescale = [];
            this.hasNoVolume = [];
            this.type = [];
            this.ticker = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SymbolGroupInfoResp symbol.
         * @member {Array.<string>} symbol
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         */
        SymbolGroupInfoResp.prototype.symbol = $util.emptyArray;

        /**
         * SymbolGroupInfoResp desceiption.
         * @member {Array.<string>} desceiption
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         */
        SymbolGroupInfoResp.prototype.desceiption = $util.emptyArray;

        /**
         * SymbolGroupInfoResp exchangeListed.
         * @member {string} exchangeListed
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         */
        SymbolGroupInfoResp.prototype.exchangeListed = "";

        /**
         * SymbolGroupInfoResp minmov.
         * @member {number} minmov
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         */
        SymbolGroupInfoResp.prototype.minmov = 0;

        /**
         * SymbolGroupInfoResp minmov2.
         * @member {number} minmov2
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         */
        SymbolGroupInfoResp.prototype.minmov2 = 0;

        /**
         * SymbolGroupInfoResp pricescale.
         * @member {Array.<number>} pricescale
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         */
        SymbolGroupInfoResp.prototype.pricescale = $util.emptyArray;

        /**
         * SymbolGroupInfoResp hasDwm.
         * @member {boolean} hasDwm
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         */
        SymbolGroupInfoResp.prototype.hasDwm = false;

        /**
         * SymbolGroupInfoResp hasIntraday.
         * @member {boolean} hasIntraday
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         */
        SymbolGroupInfoResp.prototype.hasIntraday = false;

        /**
         * SymbolGroupInfoResp hasNoVolume.
         * @member {Array.<boolean>} hasNoVolume
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         */
        SymbolGroupInfoResp.prototype.hasNoVolume = $util.emptyArray;

        /**
         * SymbolGroupInfoResp type.
         * @member {Array.<string>} type
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         */
        SymbolGroupInfoResp.prototype.type = $util.emptyArray;

        /**
         * SymbolGroupInfoResp ticker.
         * @member {Array.<string>} ticker
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         */
        SymbolGroupInfoResp.prototype.ticker = $util.emptyArray;

        /**
         * SymbolGroupInfoResp timezone.
         * @member {string} timezone
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         */
        SymbolGroupInfoResp.prototype.timezone = "";

        /**
         * SymbolGroupInfoResp sessionRegular.
         * @member {string} sessionRegular
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         */
        SymbolGroupInfoResp.prototype.sessionRegular = "";

        /**
         * Creates a new SymbolGroupInfoResp instance using the specified properties.
         * @function create
         * @memberof datatype.SymbolGroupInfoResp
         * @static
         * @param {datatype.ISymbolGroupInfoResp=} [properties] Properties to set
         * @returns {datatype.SymbolGroupInfoResp} SymbolGroupInfoResp instance
         */
        SymbolGroupInfoResp.create = function create(properties) {
            return new SymbolGroupInfoResp(properties);
        };

        /**
         * Encodes the specified SymbolGroupInfoResp message. Does not implicitly {@link datatype.SymbolGroupInfoResp.verify|verify} messages.
         * @function encode
         * @memberof datatype.SymbolGroupInfoResp
         * @static
         * @param {datatype.ISymbolGroupInfoResp} message SymbolGroupInfoResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolGroupInfoResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.symbol != null && message.symbol.length)
                for (let i = 0; i < message.symbol.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.symbol[i]);
            if (message.desceiption != null && message.desceiption.length)
                for (let i = 0; i < message.desceiption.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.desceiption[i]);
            if (message.exchangeListed != null && Object.hasOwnProperty.call(message, "exchangeListed"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.exchangeListed);
            if (message.minmov != null && Object.hasOwnProperty.call(message, "minmov"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minmov);
            if (message.minmov2 != null && Object.hasOwnProperty.call(message, "minmov2"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.minmov2);
            if (message.pricescale != null && message.pricescale.length) {
                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                for (let i = 0; i < message.pricescale.length; ++i)
                    writer.int32(message.pricescale[i]);
                writer.ldelim();
            }
            if (message.hasDwm != null && Object.hasOwnProperty.call(message, "hasDwm"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.hasDwm);
            if (message.hasIntraday != null && Object.hasOwnProperty.call(message, "hasIntraday"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasIntraday);
            if (message.hasNoVolume != null && message.hasNoVolume.length) {
                writer.uint32(/* id 9, wireType 2 =*/74).fork();
                for (let i = 0; i < message.hasNoVolume.length; ++i)
                    writer.bool(message.hasNoVolume[i]);
                writer.ldelim();
            }
            if (message.type != null && message.type.length)
                for (let i = 0; i < message.type.length; ++i)
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.type[i]);
            if (message.ticker != null && message.ticker.length)
                for (let i = 0; i < message.ticker.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.ticker[i]);
            if (message.timezone != null && Object.hasOwnProperty.call(message, "timezone"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.timezone);
            if (message.sessionRegular != null && Object.hasOwnProperty.call(message, "sessionRegular"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.sessionRegular);
            return writer;
        };

        /**
         * Encodes the specified SymbolGroupInfoResp message, length delimited. Does not implicitly {@link datatype.SymbolGroupInfoResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.SymbolGroupInfoResp
         * @static
         * @param {datatype.ISymbolGroupInfoResp} message SymbolGroupInfoResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolGroupInfoResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SymbolGroupInfoResp message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.SymbolGroupInfoResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.SymbolGroupInfoResp} SymbolGroupInfoResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolGroupInfoResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.SymbolGroupInfoResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.symbol && message.symbol.length))
                        message.symbol = [];
                    message.symbol.push(reader.string());
                    break;
                case 2:
                    if (!(message.desceiption && message.desceiption.length))
                        message.desceiption = [];
                    message.desceiption.push(reader.string());
                    break;
                case 3:
                    message.exchangeListed = reader.string();
                    break;
                case 4:
                    message.minmov = reader.int32();
                    break;
                case 5:
                    message.minmov2 = reader.int32();
                    break;
                case 6:
                    if (!(message.pricescale && message.pricescale.length))
                        message.pricescale = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.pricescale.push(reader.int32());
                    } else
                        message.pricescale.push(reader.int32());
                    break;
                case 7:
                    message.hasDwm = reader.bool();
                    break;
                case 8:
                    message.hasIntraday = reader.bool();
                    break;
                case 9:
                    if (!(message.hasNoVolume && message.hasNoVolume.length))
                        message.hasNoVolume = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.hasNoVolume.push(reader.bool());
                    } else
                        message.hasNoVolume.push(reader.bool());
                    break;
                case 10:
                    if (!(message.type && message.type.length))
                        message.type = [];
                    message.type.push(reader.string());
                    break;
                case 11:
                    if (!(message.ticker && message.ticker.length))
                        message.ticker = [];
                    message.ticker.push(reader.string());
                    break;
                case 12:
                    message.timezone = reader.string();
                    break;
                case 13:
                    message.sessionRegular = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SymbolGroupInfoResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.SymbolGroupInfoResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.SymbolGroupInfoResp} SymbolGroupInfoResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolGroupInfoResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SymbolGroupInfoResp message.
         * @function verify
         * @memberof datatype.SymbolGroupInfoResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SymbolGroupInfoResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.symbol != null && message.hasOwnProperty("symbol")) {
                if (!Array.isArray(message.symbol))
                    return "symbol: array expected";
                for (let i = 0; i < message.symbol.length; ++i)
                    if (!$util.isString(message.symbol[i]))
                        return "symbol: string[] expected";
            }
            if (message.desceiption != null && message.hasOwnProperty("desceiption")) {
                if (!Array.isArray(message.desceiption))
                    return "desceiption: array expected";
                for (let i = 0; i < message.desceiption.length; ++i)
                    if (!$util.isString(message.desceiption[i]))
                        return "desceiption: string[] expected";
            }
            if (message.exchangeListed != null && message.hasOwnProperty("exchangeListed"))
                if (!$util.isString(message.exchangeListed))
                    return "exchangeListed: string expected";
            if (message.minmov != null && message.hasOwnProperty("minmov"))
                if (!$util.isInteger(message.minmov))
                    return "minmov: integer expected";
            if (message.minmov2 != null && message.hasOwnProperty("minmov2"))
                if (!$util.isInteger(message.minmov2))
                    return "minmov2: integer expected";
            if (message.pricescale != null && message.hasOwnProperty("pricescale")) {
                if (!Array.isArray(message.pricescale))
                    return "pricescale: array expected";
                for (let i = 0; i < message.pricescale.length; ++i)
                    if (!$util.isInteger(message.pricescale[i]))
                        return "pricescale: integer[] expected";
            }
            if (message.hasDwm != null && message.hasOwnProperty("hasDwm"))
                if (typeof message.hasDwm !== "boolean")
                    return "hasDwm: boolean expected";
            if (message.hasIntraday != null && message.hasOwnProperty("hasIntraday"))
                if (typeof message.hasIntraday !== "boolean")
                    return "hasIntraday: boolean expected";
            if (message.hasNoVolume != null && message.hasOwnProperty("hasNoVolume")) {
                if (!Array.isArray(message.hasNoVolume))
                    return "hasNoVolume: array expected";
                for (let i = 0; i < message.hasNoVolume.length; ++i)
                    if (typeof message.hasNoVolume[i] !== "boolean")
                        return "hasNoVolume: boolean[] expected";
            }
            if (message.type != null && message.hasOwnProperty("type")) {
                if (!Array.isArray(message.type))
                    return "type: array expected";
                for (let i = 0; i < message.type.length; ++i)
                    if (!$util.isString(message.type[i]))
                        return "type: string[] expected";
            }
            if (message.ticker != null && message.hasOwnProperty("ticker")) {
                if (!Array.isArray(message.ticker))
                    return "ticker: array expected";
                for (let i = 0; i < message.ticker.length; ++i)
                    if (!$util.isString(message.ticker[i]))
                        return "ticker: string[] expected";
            }
            if (message.timezone != null && message.hasOwnProperty("timezone"))
                if (!$util.isString(message.timezone))
                    return "timezone: string expected";
            if (message.sessionRegular != null && message.hasOwnProperty("sessionRegular"))
                if (!$util.isString(message.sessionRegular))
                    return "sessionRegular: string expected";
            return null;
        };

        /**
         * Creates a SymbolGroupInfoResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.SymbolGroupInfoResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.SymbolGroupInfoResp} SymbolGroupInfoResp
         */
        SymbolGroupInfoResp.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.SymbolGroupInfoResp)
                return object;
            let message = new $root.datatype.SymbolGroupInfoResp();
            if (object.symbol) {
                if (!Array.isArray(object.symbol))
                    throw TypeError(".datatype.SymbolGroupInfoResp.symbol: array expected");
                message.symbol = [];
                for (let i = 0; i < object.symbol.length; ++i)
                    message.symbol[i] = String(object.symbol[i]);
            }
            if (object.desceiption) {
                if (!Array.isArray(object.desceiption))
                    throw TypeError(".datatype.SymbolGroupInfoResp.desceiption: array expected");
                message.desceiption = [];
                for (let i = 0; i < object.desceiption.length; ++i)
                    message.desceiption[i] = String(object.desceiption[i]);
            }
            if (object.exchangeListed != null)
                message.exchangeListed = String(object.exchangeListed);
            if (object.minmov != null)
                message.minmov = object.minmov | 0;
            if (object.minmov2 != null)
                message.minmov2 = object.minmov2 | 0;
            if (object.pricescale) {
                if (!Array.isArray(object.pricescale))
                    throw TypeError(".datatype.SymbolGroupInfoResp.pricescale: array expected");
                message.pricescale = [];
                for (let i = 0; i < object.pricescale.length; ++i)
                    message.pricescale[i] = object.pricescale[i] | 0;
            }
            if (object.hasDwm != null)
                message.hasDwm = Boolean(object.hasDwm);
            if (object.hasIntraday != null)
                message.hasIntraday = Boolean(object.hasIntraday);
            if (object.hasNoVolume) {
                if (!Array.isArray(object.hasNoVolume))
                    throw TypeError(".datatype.SymbolGroupInfoResp.hasNoVolume: array expected");
                message.hasNoVolume = [];
                for (let i = 0; i < object.hasNoVolume.length; ++i)
                    message.hasNoVolume[i] = Boolean(object.hasNoVolume[i]);
            }
            if (object.type) {
                if (!Array.isArray(object.type))
                    throw TypeError(".datatype.SymbolGroupInfoResp.type: array expected");
                message.type = [];
                for (let i = 0; i < object.type.length; ++i)
                    message.type[i] = String(object.type[i]);
            }
            if (object.ticker) {
                if (!Array.isArray(object.ticker))
                    throw TypeError(".datatype.SymbolGroupInfoResp.ticker: array expected");
                message.ticker = [];
                for (let i = 0; i < object.ticker.length; ++i)
                    message.ticker[i] = String(object.ticker[i]);
            }
            if (object.timezone != null)
                message.timezone = String(object.timezone);
            if (object.sessionRegular != null)
                message.sessionRegular = String(object.sessionRegular);
            return message;
        };

        /**
         * Creates a plain object from a SymbolGroupInfoResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.SymbolGroupInfoResp
         * @static
         * @param {datatype.SymbolGroupInfoResp} message SymbolGroupInfoResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SymbolGroupInfoResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.symbol = [];
                object.desceiption = [];
                object.pricescale = [];
                object.hasNoVolume = [];
                object.type = [];
                object.ticker = [];
            }
            if (options.defaults) {
                object.exchangeListed = "";
                object.minmov = 0;
                object.minmov2 = 0;
                object.hasDwm = false;
                object.hasIntraday = false;
                object.timezone = "";
                object.sessionRegular = "";
            }
            if (message.symbol && message.symbol.length) {
                object.symbol = [];
                for (let j = 0; j < message.symbol.length; ++j)
                    object.symbol[j] = message.symbol[j];
            }
            if (message.desceiption && message.desceiption.length) {
                object.desceiption = [];
                for (let j = 0; j < message.desceiption.length; ++j)
                    object.desceiption[j] = message.desceiption[j];
            }
            if (message.exchangeListed != null && message.hasOwnProperty("exchangeListed"))
                object.exchangeListed = message.exchangeListed;
            if (message.minmov != null && message.hasOwnProperty("minmov"))
                object.minmov = message.minmov;
            if (message.minmov2 != null && message.hasOwnProperty("minmov2"))
                object.minmov2 = message.minmov2;
            if (message.pricescale && message.pricescale.length) {
                object.pricescale = [];
                for (let j = 0; j < message.pricescale.length; ++j)
                    object.pricescale[j] = message.pricescale[j];
            }
            if (message.hasDwm != null && message.hasOwnProperty("hasDwm"))
                object.hasDwm = message.hasDwm;
            if (message.hasIntraday != null && message.hasOwnProperty("hasIntraday"))
                object.hasIntraday = message.hasIntraday;
            if (message.hasNoVolume && message.hasNoVolume.length) {
                object.hasNoVolume = [];
                for (let j = 0; j < message.hasNoVolume.length; ++j)
                    object.hasNoVolume[j] = message.hasNoVolume[j];
            }
            if (message.type && message.type.length) {
                object.type = [];
                for (let j = 0; j < message.type.length; ++j)
                    object.type[j] = message.type[j];
            }
            if (message.ticker && message.ticker.length) {
                object.ticker = [];
                for (let j = 0; j < message.ticker.length; ++j)
                    object.ticker[j] = message.ticker[j];
            }
            if (message.timezone != null && message.hasOwnProperty("timezone"))
                object.timezone = message.timezone;
            if (message.sessionRegular != null && message.hasOwnProperty("sessionRegular"))
                object.sessionRegular = message.sessionRegular;
            return object;
        };

        /**
         * Converts this SymbolGroupInfoResp to JSON.
         * @function toJSON
         * @memberof datatype.SymbolGroupInfoResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SymbolGroupInfoResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SymbolGroupInfoResp;
    })();

    datatype.SymbolInfoReq = (function() {

        /**
         * Properties of a SymbolInfoReq.
         * @memberof datatype
         * @interface ISymbolInfoReq
         * @property {string|null} [symbol] SymbolInfoReq symbol
         * @property {string|null} [source] SymbolInfoReq source
         */

        /**
         * Constructs a new SymbolInfoReq.
         * @memberof datatype
         * @classdesc Represents a SymbolInfoReq.
         * @implements ISymbolInfoReq
         * @constructor
         * @param {datatype.ISymbolInfoReq=} [properties] Properties to set
         */
        function SymbolInfoReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SymbolInfoReq symbol.
         * @member {string} symbol
         * @memberof datatype.SymbolInfoReq
         * @instance
         */
        SymbolInfoReq.prototype.symbol = "";

        /**
         * SymbolInfoReq source.
         * @member {string} source
         * @memberof datatype.SymbolInfoReq
         * @instance
         */
        SymbolInfoReq.prototype.source = "";

        /**
         * Creates a new SymbolInfoReq instance using the specified properties.
         * @function create
         * @memberof datatype.SymbolInfoReq
         * @static
         * @param {datatype.ISymbolInfoReq=} [properties] Properties to set
         * @returns {datatype.SymbolInfoReq} SymbolInfoReq instance
         */
        SymbolInfoReq.create = function create(properties) {
            return new SymbolInfoReq(properties);
        };

        /**
         * Encodes the specified SymbolInfoReq message. Does not implicitly {@link datatype.SymbolInfoReq.verify|verify} messages.
         * @function encode
         * @memberof datatype.SymbolInfoReq
         * @static
         * @param {datatype.ISymbolInfoReq} message SymbolInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolInfoReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.symbol);
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                writer.uint32(/* id 100, wireType 2 =*/802).string(message.source);
            return writer;
        };

        /**
         * Encodes the specified SymbolInfoReq message, length delimited. Does not implicitly {@link datatype.SymbolInfoReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.SymbolInfoReq
         * @static
         * @param {datatype.ISymbolInfoReq} message SymbolInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SymbolInfoReq message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.SymbolInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.SymbolInfoReq} SymbolInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolInfoReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.SymbolInfoReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.symbol = reader.string();
                    break;
                case 100:
                    message.source = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SymbolInfoReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.SymbolInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.SymbolInfoReq} SymbolInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolInfoReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SymbolInfoReq message.
         * @function verify
         * @memberof datatype.SymbolInfoReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SymbolInfoReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                if (!$util.isString(message.symbol))
                    return "symbol: string expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!$util.isString(message.source))
                    return "source: string expected";
            return null;
        };

        /**
         * Creates a SymbolInfoReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.SymbolInfoReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.SymbolInfoReq} SymbolInfoReq
         */
        SymbolInfoReq.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.SymbolInfoReq)
                return object;
            let message = new $root.datatype.SymbolInfoReq();
            if (object.symbol != null)
                message.symbol = String(object.symbol);
            if (object.source != null)
                message.source = String(object.source);
            return message;
        };

        /**
         * Creates a plain object from a SymbolInfoReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.SymbolInfoReq
         * @static
         * @param {datatype.SymbolInfoReq} message SymbolInfoReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SymbolInfoReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.symbol = "";
                object.source = "";
            }
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                object.symbol = message.symbol;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = message.source;
            return object;
        };

        /**
         * Converts this SymbolInfoReq to JSON.
         * @function toJSON
         * @memberof datatype.SymbolInfoReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SymbolInfoReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SymbolInfoReq;
    })();

    datatype.SymbolInfo = (function() {

        /**
         * Properties of a SymbolInfo.
         * @memberof datatype
         * @interface ISymbolInfo
         * @property {string|null} [name] SymbolInfo name
         * @property {string|null} [ticker] SymbolInfo ticker
         * @property {string|null} [description] SymbolInfo description
         * @property {string|null} [type] SymbolInfo type
         * @property {string|null} [session] SymbolInfo session
         * @property {string|null} [holidays] SymbolInfo holidays
         * @property {string|null} [corrections] SymbolInfo corrections
         * @property {string|null} [exchange] SymbolInfo exchange
         * @property {string|null} [timezone] SymbolInfo timezone
         * @property {string|null} [format] SymbolInfo format
         * @property {number|null} [minmov] SymbolInfo minmov
         * @property {number|null} [pricescale] SymbolInfo pricescale
         * @property {number|null} [minmove2] SymbolInfo minmove2
         * @property {boolean|null} [hasDwm] SymbolInfo hasDwm
         * @property {boolean|null} [hasIntraday] SymbolInfo hasIntraday
         * @property {Array.<string>|null} [supportedResolutions] SymbolInfo supportedResolutions
         * @property {boolean|null} [hasSeconds] SymbolInfo hasSeconds
         * @property {boolean|null} [hasDaily] SymbolInfo hasDaily
         * @property {boolean|null} [hasWeeklyAndMonthly] SymbolInfo hasWeeklyAndMonthly
         * @property {boolean|null} [hasEmptyBars] SymbolInfo hasEmptyBars
         * @property {boolean|null} [forceSessionRebuild] SymbolInfo forceSessionRebuild
         * @property {boolean|null} [hasNoVolume] SymbolInfo hasNoVolume
         * @property {string|null} [symbol] SymbolInfo symbol
         * @property {string|null} [fullName] SymbolInfo fullName
         */

        /**
         * Constructs a new SymbolInfo.
         * @memberof datatype
         * @classdesc Represents a SymbolInfo.
         * @implements ISymbolInfo
         * @constructor
         * @param {datatype.ISymbolInfo=} [properties] Properties to set
         */
        function SymbolInfo(properties) {
            this.supportedResolutions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SymbolInfo name.
         * @member {string} name
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.name = "";

        /**
         * SymbolInfo ticker.
         * @member {string} ticker
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.ticker = "";

        /**
         * SymbolInfo description.
         * @member {string} description
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.description = "";

        /**
         * SymbolInfo type.
         * @member {string} type
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.type = "";

        /**
         * SymbolInfo session.
         * @member {string} session
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.session = "";

        /**
         * SymbolInfo holidays.
         * @member {string} holidays
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.holidays = "";

        /**
         * SymbolInfo corrections.
         * @member {string} corrections
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.corrections = "";

        /**
         * SymbolInfo exchange.
         * @member {string} exchange
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.exchange = "";

        /**
         * SymbolInfo timezone.
         * @member {string} timezone
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.timezone = "";

        /**
         * SymbolInfo format.
         * @member {string} format
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.format = "";

        /**
         * SymbolInfo minmov.
         * @member {number} minmov
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.minmov = 0;

        /**
         * SymbolInfo pricescale.
         * @member {number} pricescale
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.pricescale = 0;

        /**
         * SymbolInfo minmove2.
         * @member {number} minmove2
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.minmove2 = 0;

        /**
         * SymbolInfo hasDwm.
         * @member {boolean} hasDwm
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.hasDwm = false;

        /**
         * SymbolInfo hasIntraday.
         * @member {boolean} hasIntraday
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.hasIntraday = false;

        /**
         * SymbolInfo supportedResolutions.
         * @member {Array.<string>} supportedResolutions
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.supportedResolutions = $util.emptyArray;

        /**
         * SymbolInfo hasSeconds.
         * @member {boolean} hasSeconds
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.hasSeconds = false;

        /**
         * SymbolInfo hasDaily.
         * @member {boolean} hasDaily
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.hasDaily = false;

        /**
         * SymbolInfo hasWeeklyAndMonthly.
         * @member {boolean} hasWeeklyAndMonthly
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.hasWeeklyAndMonthly = false;

        /**
         * SymbolInfo hasEmptyBars.
         * @member {boolean} hasEmptyBars
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.hasEmptyBars = false;

        /**
         * SymbolInfo forceSessionRebuild.
         * @member {boolean} forceSessionRebuild
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.forceSessionRebuild = false;

        /**
         * SymbolInfo hasNoVolume.
         * @member {boolean} hasNoVolume
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.hasNoVolume = false;

        /**
         * SymbolInfo symbol.
         * @member {string} symbol
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.symbol = "";

        /**
         * SymbolInfo fullName.
         * @member {string} fullName
         * @memberof datatype.SymbolInfo
         * @instance
         */
        SymbolInfo.prototype.fullName = "";

        /**
         * Creates a new SymbolInfo instance using the specified properties.
         * @function create
         * @memberof datatype.SymbolInfo
         * @static
         * @param {datatype.ISymbolInfo=} [properties] Properties to set
         * @returns {datatype.SymbolInfo} SymbolInfo instance
         */
        SymbolInfo.create = function create(properties) {
            return new SymbolInfo(properties);
        };

        /**
         * Encodes the specified SymbolInfo message. Does not implicitly {@link datatype.SymbolInfo.verify|verify} messages.
         * @function encode
         * @memberof datatype.SymbolInfo
         * @static
         * @param {datatype.ISymbolInfo} message SymbolInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.ticker != null && Object.hasOwnProperty.call(message, "ticker"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ticker);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.type);
            if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.session);
            if (message.holidays != null && Object.hasOwnProperty.call(message, "holidays"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.holidays);
            if (message.corrections != null && Object.hasOwnProperty.call(message, "corrections"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.corrections);
            if (message.exchange != null && Object.hasOwnProperty.call(message, "exchange"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.exchange);
            if (message.timezone != null && Object.hasOwnProperty.call(message, "timezone"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.timezone);
            if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.format);
            if (message.minmov != null && Object.hasOwnProperty.call(message, "minmov"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.minmov);
            if (message.pricescale != null && Object.hasOwnProperty.call(message, "pricescale"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.pricescale);
            if (message.minmove2 != null && Object.hasOwnProperty.call(message, "minmove2"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.minmove2);
            if (message.hasDwm != null && Object.hasOwnProperty.call(message, "hasDwm"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.hasDwm);
            if (message.hasIntraday != null && Object.hasOwnProperty.call(message, "hasIntraday"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.hasIntraday);
            if (message.supportedResolutions != null && message.supportedResolutions.length)
                for (let i = 0; i < message.supportedResolutions.length; ++i)
                    writer.uint32(/* id 16, wireType 2 =*/130).string(message.supportedResolutions[i]);
            if (message.hasSeconds != null && Object.hasOwnProperty.call(message, "hasSeconds"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message.hasSeconds);
            if (message.hasDaily != null && Object.hasOwnProperty.call(message, "hasDaily"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.hasDaily);
            if (message.hasWeeklyAndMonthly != null && Object.hasOwnProperty.call(message, "hasWeeklyAndMonthly"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.hasWeeklyAndMonthly);
            if (message.hasEmptyBars != null && Object.hasOwnProperty.call(message, "hasEmptyBars"))
                writer.uint32(/* id 20, wireType 0 =*/160).bool(message.hasEmptyBars);
            if (message.forceSessionRebuild != null && Object.hasOwnProperty.call(message, "forceSessionRebuild"))
                writer.uint32(/* id 21, wireType 0 =*/168).bool(message.forceSessionRebuild);
            if (message.hasNoVolume != null && Object.hasOwnProperty.call(message, "hasNoVolume"))
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.hasNoVolume);
            if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                writer.uint32(/* id 23, wireType 2 =*/186).string(message.symbol);
            if (message.fullName != null && Object.hasOwnProperty.call(message, "fullName"))
                writer.uint32(/* id 24, wireType 2 =*/194).string(message.fullName);
            return writer;
        };

        /**
         * Encodes the specified SymbolInfo message, length delimited. Does not implicitly {@link datatype.SymbolInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.SymbolInfo
         * @static
         * @param {datatype.ISymbolInfo} message SymbolInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SymbolInfo message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.SymbolInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.SymbolInfo} SymbolInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.SymbolInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.ticker = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.type = reader.string();
                    break;
                case 5:
                    message.session = reader.string();
                    break;
                case 6:
                    message.holidays = reader.string();
                    break;
                case 7:
                    message.corrections = reader.string();
                    break;
                case 8:
                    message.exchange = reader.string();
                    break;
                case 9:
                    message.timezone = reader.string();
                    break;
                case 10:
                    message.format = reader.string();
                    break;
                case 11:
                    message.minmov = reader.uint32();
                    break;
                case 12:
                    message.pricescale = reader.uint32();
                    break;
                case 13:
                    message.minmove2 = reader.uint32();
                    break;
                case 14:
                    message.hasDwm = reader.bool();
                    break;
                case 15:
                    message.hasIntraday = reader.bool();
                    break;
                case 16:
                    if (!(message.supportedResolutions && message.supportedResolutions.length))
                        message.supportedResolutions = [];
                    message.supportedResolutions.push(reader.string());
                    break;
                case 17:
                    message.hasSeconds = reader.bool();
                    break;
                case 18:
                    message.hasDaily = reader.bool();
                    break;
                case 19:
                    message.hasWeeklyAndMonthly = reader.bool();
                    break;
                case 20:
                    message.hasEmptyBars = reader.bool();
                    break;
                case 21:
                    message.forceSessionRebuild = reader.bool();
                    break;
                case 22:
                    message.hasNoVolume = reader.bool();
                    break;
                case 23:
                    message.symbol = reader.string();
                    break;
                case 24:
                    message.fullName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SymbolInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.SymbolInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.SymbolInfo} SymbolInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SymbolInfo message.
         * @function verify
         * @memberof datatype.SymbolInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SymbolInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                if (!$util.isString(message.ticker))
                    return "ticker: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.session != null && message.hasOwnProperty("session"))
                if (!$util.isString(message.session))
                    return "session: string expected";
            if (message.holidays != null && message.hasOwnProperty("holidays"))
                if (!$util.isString(message.holidays))
                    return "holidays: string expected";
            if (message.corrections != null && message.hasOwnProperty("corrections"))
                if (!$util.isString(message.corrections))
                    return "corrections: string expected";
            if (message.exchange != null && message.hasOwnProperty("exchange"))
                if (!$util.isString(message.exchange))
                    return "exchange: string expected";
            if (message.timezone != null && message.hasOwnProperty("timezone"))
                if (!$util.isString(message.timezone))
                    return "timezone: string expected";
            if (message.format != null && message.hasOwnProperty("format"))
                if (!$util.isString(message.format))
                    return "format: string expected";
            if (message.minmov != null && message.hasOwnProperty("minmov"))
                if (!$util.isInteger(message.minmov))
                    return "minmov: integer expected";
            if (message.pricescale != null && message.hasOwnProperty("pricescale"))
                if (!$util.isInteger(message.pricescale))
                    return "pricescale: integer expected";
            if (message.minmove2 != null && message.hasOwnProperty("minmove2"))
                if (!$util.isInteger(message.minmove2))
                    return "minmove2: integer expected";
            if (message.hasDwm != null && message.hasOwnProperty("hasDwm"))
                if (typeof message.hasDwm !== "boolean")
                    return "hasDwm: boolean expected";
            if (message.hasIntraday != null && message.hasOwnProperty("hasIntraday"))
                if (typeof message.hasIntraday !== "boolean")
                    return "hasIntraday: boolean expected";
            if (message.supportedResolutions != null && message.hasOwnProperty("supportedResolutions")) {
                if (!Array.isArray(message.supportedResolutions))
                    return "supportedResolutions: array expected";
                for (let i = 0; i < message.supportedResolutions.length; ++i)
                    if (!$util.isString(message.supportedResolutions[i]))
                        return "supportedResolutions: string[] expected";
            }
            if (message.hasSeconds != null && message.hasOwnProperty("hasSeconds"))
                if (typeof message.hasSeconds !== "boolean")
                    return "hasSeconds: boolean expected";
            if (message.hasDaily != null && message.hasOwnProperty("hasDaily"))
                if (typeof message.hasDaily !== "boolean")
                    return "hasDaily: boolean expected";
            if (message.hasWeeklyAndMonthly != null && message.hasOwnProperty("hasWeeklyAndMonthly"))
                if (typeof message.hasWeeklyAndMonthly !== "boolean")
                    return "hasWeeklyAndMonthly: boolean expected";
            if (message.hasEmptyBars != null && message.hasOwnProperty("hasEmptyBars"))
                if (typeof message.hasEmptyBars !== "boolean")
                    return "hasEmptyBars: boolean expected";
            if (message.forceSessionRebuild != null && message.hasOwnProperty("forceSessionRebuild"))
                if (typeof message.forceSessionRebuild !== "boolean")
                    return "forceSessionRebuild: boolean expected";
            if (message.hasNoVolume != null && message.hasOwnProperty("hasNoVolume"))
                if (typeof message.hasNoVolume !== "boolean")
                    return "hasNoVolume: boolean expected";
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                if (!$util.isString(message.symbol))
                    return "symbol: string expected";
            if (message.fullName != null && message.hasOwnProperty("fullName"))
                if (!$util.isString(message.fullName))
                    return "fullName: string expected";
            return null;
        };

        /**
         * Creates a SymbolInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.SymbolInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.SymbolInfo} SymbolInfo
         */
        SymbolInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.SymbolInfo)
                return object;
            let message = new $root.datatype.SymbolInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.ticker != null)
                message.ticker = String(object.ticker);
            if (object.description != null)
                message.description = String(object.description);
            if (object.type != null)
                message.type = String(object.type);
            if (object.session != null)
                message.session = String(object.session);
            if (object.holidays != null)
                message.holidays = String(object.holidays);
            if (object.corrections != null)
                message.corrections = String(object.corrections);
            if (object.exchange != null)
                message.exchange = String(object.exchange);
            if (object.timezone != null)
                message.timezone = String(object.timezone);
            if (object.format != null)
                message.format = String(object.format);
            if (object.minmov != null)
                message.minmov = object.minmov >>> 0;
            if (object.pricescale != null)
                message.pricescale = object.pricescale >>> 0;
            if (object.minmove2 != null)
                message.minmove2 = object.minmove2 >>> 0;
            if (object.hasDwm != null)
                message.hasDwm = Boolean(object.hasDwm);
            if (object.hasIntraday != null)
                message.hasIntraday = Boolean(object.hasIntraday);
            if (object.supportedResolutions) {
                if (!Array.isArray(object.supportedResolutions))
                    throw TypeError(".datatype.SymbolInfo.supportedResolutions: array expected");
                message.supportedResolutions = [];
                for (let i = 0; i < object.supportedResolutions.length; ++i)
                    message.supportedResolutions[i] = String(object.supportedResolutions[i]);
            }
            if (object.hasSeconds != null)
                message.hasSeconds = Boolean(object.hasSeconds);
            if (object.hasDaily != null)
                message.hasDaily = Boolean(object.hasDaily);
            if (object.hasWeeklyAndMonthly != null)
                message.hasWeeklyAndMonthly = Boolean(object.hasWeeklyAndMonthly);
            if (object.hasEmptyBars != null)
                message.hasEmptyBars = Boolean(object.hasEmptyBars);
            if (object.forceSessionRebuild != null)
                message.forceSessionRebuild = Boolean(object.forceSessionRebuild);
            if (object.hasNoVolume != null)
                message.hasNoVolume = Boolean(object.hasNoVolume);
            if (object.symbol != null)
                message.symbol = String(object.symbol);
            if (object.fullName != null)
                message.fullName = String(object.fullName);
            return message;
        };

        /**
         * Creates a plain object from a SymbolInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.SymbolInfo
         * @static
         * @param {datatype.SymbolInfo} message SymbolInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SymbolInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.supportedResolutions = [];
            if (options.defaults) {
                object.name = "";
                object.ticker = "";
                object.description = "";
                object.type = "";
                object.session = "";
                object.holidays = "";
                object.corrections = "";
                object.exchange = "";
                object.timezone = "";
                object.format = "";
                object.minmov = 0;
                object.pricescale = 0;
                object.minmove2 = 0;
                object.hasDwm = false;
                object.hasIntraday = false;
                object.hasSeconds = false;
                object.hasDaily = false;
                object.hasWeeklyAndMonthly = false;
                object.hasEmptyBars = false;
                object.forceSessionRebuild = false;
                object.hasNoVolume = false;
                object.symbol = "";
                object.fullName = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                object.ticker = message.ticker;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.session != null && message.hasOwnProperty("session"))
                object.session = message.session;
            if (message.holidays != null && message.hasOwnProperty("holidays"))
                object.holidays = message.holidays;
            if (message.corrections != null && message.hasOwnProperty("corrections"))
                object.corrections = message.corrections;
            if (message.exchange != null && message.hasOwnProperty("exchange"))
                object.exchange = message.exchange;
            if (message.timezone != null && message.hasOwnProperty("timezone"))
                object.timezone = message.timezone;
            if (message.format != null && message.hasOwnProperty("format"))
                object.format = message.format;
            if (message.minmov != null && message.hasOwnProperty("minmov"))
                object.minmov = message.minmov;
            if (message.pricescale != null && message.hasOwnProperty("pricescale"))
                object.pricescale = message.pricescale;
            if (message.minmove2 != null && message.hasOwnProperty("minmove2"))
                object.minmove2 = message.minmove2;
            if (message.hasDwm != null && message.hasOwnProperty("hasDwm"))
                object.hasDwm = message.hasDwm;
            if (message.hasIntraday != null && message.hasOwnProperty("hasIntraday"))
                object.hasIntraday = message.hasIntraday;
            if (message.supportedResolutions && message.supportedResolutions.length) {
                object.supportedResolutions = [];
                for (let j = 0; j < message.supportedResolutions.length; ++j)
                    object.supportedResolutions[j] = message.supportedResolutions[j];
            }
            if (message.hasSeconds != null && message.hasOwnProperty("hasSeconds"))
                object.hasSeconds = message.hasSeconds;
            if (message.hasDaily != null && message.hasOwnProperty("hasDaily"))
                object.hasDaily = message.hasDaily;
            if (message.hasWeeklyAndMonthly != null && message.hasOwnProperty("hasWeeklyAndMonthly"))
                object.hasWeeklyAndMonthly = message.hasWeeklyAndMonthly;
            if (message.hasEmptyBars != null && message.hasOwnProperty("hasEmptyBars"))
                object.hasEmptyBars = message.hasEmptyBars;
            if (message.forceSessionRebuild != null && message.hasOwnProperty("forceSessionRebuild"))
                object.forceSessionRebuild = message.forceSessionRebuild;
            if (message.hasNoVolume != null && message.hasOwnProperty("hasNoVolume"))
                object.hasNoVolume = message.hasNoVolume;
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                object.symbol = message.symbol;
            if (message.fullName != null && message.hasOwnProperty("fullName"))
                object.fullName = message.fullName;
            return object;
        };

        /**
         * Converts this SymbolInfo to JSON.
         * @function toJSON
         * @memberof datatype.SymbolInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SymbolInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SymbolInfo;
    })();

    datatype.GetHistoryKlineReq = (function() {

        /**
         * Properties of a GetHistoryKlineReq.
         * @memberof datatype
         * @interface IGetHistoryKlineReq
         * @property {string|null} [symbol] GetHistoryKlineReq symbol
         * @property {number|null} [from] GetHistoryKlineReq from
         * @property {number|null} [to] GetHistoryKlineReq to
         * @property {string|null} [resolution] GetHistoryKlineReq resolution
         * @property {boolean|null} [first] GetHistoryKlineReq first
         * @property {string|null} [source] GetHistoryKlineReq source
         */

        /**
         * Constructs a new GetHistoryKlineReq.
         * @memberof datatype
         * @classdesc Represents a GetHistoryKlineReq.
         * @implements IGetHistoryKlineReq
         * @constructor
         * @param {datatype.IGetHistoryKlineReq=} [properties] Properties to set
         */
        function GetHistoryKlineReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetHistoryKlineReq symbol.
         * @member {string} symbol
         * @memberof datatype.GetHistoryKlineReq
         * @instance
         */
        GetHistoryKlineReq.prototype.symbol = "";

        /**
         * GetHistoryKlineReq from.
         * @member {number} from
         * @memberof datatype.GetHistoryKlineReq
         * @instance
         */
        GetHistoryKlineReq.prototype.from = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GetHistoryKlineReq to.
         * @member {number} to
         * @memberof datatype.GetHistoryKlineReq
         * @instance
         */
        GetHistoryKlineReq.prototype.to = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GetHistoryKlineReq resolution.
         * @member {string} resolution
         * @memberof datatype.GetHistoryKlineReq
         * @instance
         */
        GetHistoryKlineReq.prototype.resolution = "";

        /**
         * GetHistoryKlineReq first.
         * @member {boolean} first
         * @memberof datatype.GetHistoryKlineReq
         * @instance
         */
        GetHistoryKlineReq.prototype.first = false;

        /**
         * GetHistoryKlineReq source.
         * @member {string} source
         * @memberof datatype.GetHistoryKlineReq
         * @instance
         */
        GetHistoryKlineReq.prototype.source = "";

        /**
         * Creates a new GetHistoryKlineReq instance using the specified properties.
         * @function create
         * @memberof datatype.GetHistoryKlineReq
         * @static
         * @param {datatype.IGetHistoryKlineReq=} [properties] Properties to set
         * @returns {datatype.GetHistoryKlineReq} GetHistoryKlineReq instance
         */
        GetHistoryKlineReq.create = function create(properties) {
            return new GetHistoryKlineReq(properties);
        };

        /**
         * Encodes the specified GetHistoryKlineReq message. Does not implicitly {@link datatype.GetHistoryKlineReq.verify|verify} messages.
         * @function encode
         * @memberof datatype.GetHistoryKlineReq
         * @static
         * @param {datatype.IGetHistoryKlineReq} message GetHistoryKlineReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetHistoryKlineReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.symbol);
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.from);
            if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.to);
            if (message.resolution != null && Object.hasOwnProperty.call(message, "resolution"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.resolution);
            if (message.first != null && Object.hasOwnProperty.call(message, "first"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.first);
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                writer.uint32(/* id 100, wireType 2 =*/802).string(message.source);
            return writer;
        };

        /**
         * Encodes the specified GetHistoryKlineReq message, length delimited. Does not implicitly {@link datatype.GetHistoryKlineReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.GetHistoryKlineReq
         * @static
         * @param {datatype.IGetHistoryKlineReq} message GetHistoryKlineReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetHistoryKlineReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetHistoryKlineReq message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.GetHistoryKlineReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.GetHistoryKlineReq} GetHistoryKlineReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetHistoryKlineReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.GetHistoryKlineReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.symbol = reader.string();
                    break;
                case 2:
                    message.from = reader.uint64();
                    break;
                case 3:
                    message.to = reader.uint64();
                    break;
                case 4:
                    message.resolution = reader.string();
                    break;
                case 5:
                    message.first = reader.bool();
                    break;
                case 100:
                    message.source = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetHistoryKlineReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.GetHistoryKlineReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.GetHistoryKlineReq} GetHistoryKlineReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetHistoryKlineReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetHistoryKlineReq message.
         * @function verify
         * @memberof datatype.GetHistoryKlineReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetHistoryKlineReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                if (!$util.isString(message.symbol))
                    return "symbol: string expected";
            if (message.from != null && message.hasOwnProperty("from"))
                if (!$util.isInteger(message.from) && !(message.from && $util.isInteger(message.from.low) && $util.isInteger(message.from.high)))
                    return "from: integer|Long expected";
            if (message.to != null && message.hasOwnProperty("to"))
                if (!$util.isInteger(message.to) && !(message.to && $util.isInteger(message.to.low) && $util.isInteger(message.to.high)))
                    return "to: integer|Long expected";
            if (message.resolution != null && message.hasOwnProperty("resolution"))
                if (!$util.isString(message.resolution))
                    return "resolution: string expected";
            if (message.first != null && message.hasOwnProperty("first"))
                if (typeof message.first !== "boolean")
                    return "first: boolean expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!$util.isString(message.source))
                    return "source: string expected";
            return null;
        };

        /**
         * Creates a GetHistoryKlineReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.GetHistoryKlineReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.GetHistoryKlineReq} GetHistoryKlineReq
         */
        GetHistoryKlineReq.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.GetHistoryKlineReq)
                return object;
            let message = new $root.datatype.GetHistoryKlineReq();
            if (object.symbol != null)
                message.symbol = String(object.symbol);
            if (object.from != null)
                if ($util.Long)
                    (message.from = $util.Long.fromValue(object.from)).unsigned = true;
                else if (typeof object.from === "string")
                    message.from = parseInt(object.from, 10);
                else if (typeof object.from === "number")
                    message.from = object.from;
                else if (typeof object.from === "object")
                    message.from = new $util.LongBits(object.from.low >>> 0, object.from.high >>> 0).toNumber(true);
            if (object.to != null)
                if ($util.Long)
                    (message.to = $util.Long.fromValue(object.to)).unsigned = true;
                else if (typeof object.to === "string")
                    message.to = parseInt(object.to, 10);
                else if (typeof object.to === "number")
                    message.to = object.to;
                else if (typeof object.to === "object")
                    message.to = new $util.LongBits(object.to.low >>> 0, object.to.high >>> 0).toNumber(true);
            if (object.resolution != null)
                message.resolution = String(object.resolution);
            if (object.first != null)
                message.first = Boolean(object.first);
            if (object.source != null)
                message.source = String(object.source);
            return message;
        };

        /**
         * Creates a plain object from a GetHistoryKlineReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.GetHistoryKlineReq
         * @static
         * @param {datatype.GetHistoryKlineReq} message GetHistoryKlineReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetHistoryKlineReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.symbol = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.from = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.from = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.to = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.to = options.longs === String ? "0" : 0;
                object.resolution = "";
                object.first = false;
                object.source = "";
            }
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                object.symbol = message.symbol;
            if (message.from != null && message.hasOwnProperty("from"))
                if (typeof message.from === "number")
                    object.from = options.longs === String ? String(message.from) : message.from;
                else
                    object.from = options.longs === String ? $util.Long.prototype.toString.call(message.from) : options.longs === Number ? new $util.LongBits(message.from.low >>> 0, message.from.high >>> 0).toNumber(true) : message.from;
            if (message.to != null && message.hasOwnProperty("to"))
                if (typeof message.to === "number")
                    object.to = options.longs === String ? String(message.to) : message.to;
                else
                    object.to = options.longs === String ? $util.Long.prototype.toString.call(message.to) : options.longs === Number ? new $util.LongBits(message.to.low >>> 0, message.to.high >>> 0).toNumber(true) : message.to;
            if (message.resolution != null && message.hasOwnProperty("resolution"))
                object.resolution = message.resolution;
            if (message.first != null && message.hasOwnProperty("first"))
                object.first = message.first;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = message.source;
            return object;
        };

        /**
         * Converts this GetHistoryKlineReq to JSON.
         * @function toJSON
         * @memberof datatype.GetHistoryKlineReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetHistoryKlineReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetHistoryKlineReq;
    })();

    datatype.TvKline = (function() {

        /**
         * Properties of a TvKline.
         * @memberof datatype
         * @interface ITvKline
         * @property {number|null} [t] TvKline t
         * @property {number|null} [o] TvKline o
         * @property {number|null} [c] TvKline c
         * @property {number|null} [h] TvKline h
         * @property {number|null} [l] TvKline l
         */

        /**
         * Constructs a new TvKline.
         * @memberof datatype
         * @classdesc Represents a TvKline.
         * @implements ITvKline
         * @constructor
         * @param {datatype.ITvKline=} [properties] Properties to set
         */
        function TvKline(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TvKline t.
         * @member {number} t
         * @memberof datatype.TvKline
         * @instance
         */
        TvKline.prototype.t = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TvKline o.
         * @member {number} o
         * @memberof datatype.TvKline
         * @instance
         */
        TvKline.prototype.o = 0;

        /**
         * TvKline c.
         * @member {number} c
         * @memberof datatype.TvKline
         * @instance
         */
        TvKline.prototype.c = 0;

        /**
         * TvKline h.
         * @member {number} h
         * @memberof datatype.TvKline
         * @instance
         */
        TvKline.prototype.h = 0;

        /**
         * TvKline l.
         * @member {number} l
         * @memberof datatype.TvKline
         * @instance
         */
        TvKline.prototype.l = 0;

        /**
         * Creates a new TvKline instance using the specified properties.
         * @function create
         * @memberof datatype.TvKline
         * @static
         * @param {datatype.ITvKline=} [properties] Properties to set
         * @returns {datatype.TvKline} TvKline instance
         */
        TvKline.create = function create(properties) {
            return new TvKline(properties);
        };

        /**
         * Encodes the specified TvKline message. Does not implicitly {@link datatype.TvKline.verify|verify} messages.
         * @function encode
         * @memberof datatype.TvKline
         * @static
         * @param {datatype.ITvKline} message TvKline message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TvKline.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.t != null && Object.hasOwnProperty.call(message, "t"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.t);
            if (message.o != null && Object.hasOwnProperty.call(message, "o"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.o);
            if (message.c != null && Object.hasOwnProperty.call(message, "c"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.c);
            if (message.h != null && Object.hasOwnProperty.call(message, "h"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.h);
            if (message.l != null && Object.hasOwnProperty.call(message, "l"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.l);
            return writer;
        };

        /**
         * Encodes the specified TvKline message, length delimited. Does not implicitly {@link datatype.TvKline.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.TvKline
         * @static
         * @param {datatype.ITvKline} message TvKline message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TvKline.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TvKline message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.TvKline
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.TvKline} TvKline
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TvKline.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.TvKline();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.t = reader.uint64();
                    break;
                case 2:
                    message.o = reader.double();
                    break;
                case 3:
                    message.c = reader.double();
                    break;
                case 4:
                    message.h = reader.double();
                    break;
                case 5:
                    message.l = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TvKline message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.TvKline
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.TvKline} TvKline
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TvKline.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TvKline message.
         * @function verify
         * @memberof datatype.TvKline
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TvKline.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.t != null && message.hasOwnProperty("t"))
                if (!$util.isInteger(message.t) && !(message.t && $util.isInteger(message.t.low) && $util.isInteger(message.t.high)))
                    return "t: integer|Long expected";
            if (message.o != null && message.hasOwnProperty("o"))
                if (typeof message.o !== "number")
                    return "o: number expected";
            if (message.c != null && message.hasOwnProperty("c"))
                if (typeof message.c !== "number")
                    return "c: number expected";
            if (message.h != null && message.hasOwnProperty("h"))
                if (typeof message.h !== "number")
                    return "h: number expected";
            if (message.l != null && message.hasOwnProperty("l"))
                if (typeof message.l !== "number")
                    return "l: number expected";
            return null;
        };

        /**
         * Creates a TvKline message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.TvKline
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.TvKline} TvKline
         */
        TvKline.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.TvKline)
                return object;
            let message = new $root.datatype.TvKline();
            if (object.t != null)
                if ($util.Long)
                    (message.t = $util.Long.fromValue(object.t)).unsigned = true;
                else if (typeof object.t === "string")
                    message.t = parseInt(object.t, 10);
                else if (typeof object.t === "number")
                    message.t = object.t;
                else if (typeof object.t === "object")
                    message.t = new $util.LongBits(object.t.low >>> 0, object.t.high >>> 0).toNumber(true);
            if (object.o != null)
                message.o = Number(object.o);
            if (object.c != null)
                message.c = Number(object.c);
            if (object.h != null)
                message.h = Number(object.h);
            if (object.l != null)
                message.l = Number(object.l);
            return message;
        };

        /**
         * Creates a plain object from a TvKline message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.TvKline
         * @static
         * @param {datatype.TvKline} message TvKline
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TvKline.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.t = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.t = options.longs === String ? "0" : 0;
                object.o = 0;
                object.c = 0;
                object.h = 0;
                object.l = 0;
            }
            if (message.t != null && message.hasOwnProperty("t"))
                if (typeof message.t === "number")
                    object.t = options.longs === String ? String(message.t) : message.t;
                else
                    object.t = options.longs === String ? $util.Long.prototype.toString.call(message.t) : options.longs === Number ? new $util.LongBits(message.t.low >>> 0, message.t.high >>> 0).toNumber(true) : message.t;
            if (message.o != null && message.hasOwnProperty("o"))
                object.o = options.json && !isFinite(message.o) ? String(message.o) : message.o;
            if (message.c != null && message.hasOwnProperty("c"))
                object.c = options.json && !isFinite(message.c) ? String(message.c) : message.c;
            if (message.h != null && message.hasOwnProperty("h"))
                object.h = options.json && !isFinite(message.h) ? String(message.h) : message.h;
            if (message.l != null && message.hasOwnProperty("l"))
                object.l = options.json && !isFinite(message.l) ? String(message.l) : message.l;
            return object;
        };

        /**
         * Converts this TvKline to JSON.
         * @function toJSON
         * @memberof datatype.TvKline
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TvKline.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TvKline;
    })();

    datatype.GetHistoryKlineResp = (function() {

        /**
         * Properties of a GetHistoryKlineResp.
         * @memberof datatype
         * @interface IGetHistoryKlineResp
         * @property {string|null} [s] GetHistoryKlineResp s
         * @property {Array.<number>|null} [o] GetHistoryKlineResp o
         * @property {Array.<number>|null} [c] GetHistoryKlineResp c
         * @property {Array.<number>|null} [h] GetHistoryKlineResp h
         * @property {Array.<number>|null} [l] GetHistoryKlineResp l
         * @property {Array.<number>|null} [t] GetHistoryKlineResp t
         * @property {number|null} [nextTime] GetHistoryKlineResp nextTime
         */

        /**
         * Constructs a new GetHistoryKlineResp.
         * @memberof datatype
         * @classdesc Represents a GetHistoryKlineResp.
         * @implements IGetHistoryKlineResp
         * @constructor
         * @param {datatype.IGetHistoryKlineResp=} [properties] Properties to set
         */
        function GetHistoryKlineResp(properties) {
            this.o = [];
            this.c = [];
            this.h = [];
            this.l = [];
            this.t = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetHistoryKlineResp s.
         * @member {string} s
         * @memberof datatype.GetHistoryKlineResp
         * @instance
         */
        GetHistoryKlineResp.prototype.s = "";

        /**
         * GetHistoryKlineResp o.
         * @member {Array.<number>} o
         * @memberof datatype.GetHistoryKlineResp
         * @instance
         */
        GetHistoryKlineResp.prototype.o = $util.emptyArray;

        /**
         * GetHistoryKlineResp c.
         * @member {Array.<number>} c
         * @memberof datatype.GetHistoryKlineResp
         * @instance
         */
        GetHistoryKlineResp.prototype.c = $util.emptyArray;

        /**
         * GetHistoryKlineResp h.
         * @member {Array.<number>} h
         * @memberof datatype.GetHistoryKlineResp
         * @instance
         */
        GetHistoryKlineResp.prototype.h = $util.emptyArray;

        /**
         * GetHistoryKlineResp l.
         * @member {Array.<number>} l
         * @memberof datatype.GetHistoryKlineResp
         * @instance
         */
        GetHistoryKlineResp.prototype.l = $util.emptyArray;

        /**
         * GetHistoryKlineResp t.
         * @member {Array.<number>} t
         * @memberof datatype.GetHistoryKlineResp
         * @instance
         */
        GetHistoryKlineResp.prototype.t = $util.emptyArray;

        /**
         * GetHistoryKlineResp nextTime.
         * @member {number} nextTime
         * @memberof datatype.GetHistoryKlineResp
         * @instance
         */
        GetHistoryKlineResp.prototype.nextTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new GetHistoryKlineResp instance using the specified properties.
         * @function create
         * @memberof datatype.GetHistoryKlineResp
         * @static
         * @param {datatype.IGetHistoryKlineResp=} [properties] Properties to set
         * @returns {datatype.GetHistoryKlineResp} GetHistoryKlineResp instance
         */
        GetHistoryKlineResp.create = function create(properties) {
            return new GetHistoryKlineResp(properties);
        };

        /**
         * Encodes the specified GetHistoryKlineResp message. Does not implicitly {@link datatype.GetHistoryKlineResp.verify|verify} messages.
         * @function encode
         * @memberof datatype.GetHistoryKlineResp
         * @static
         * @param {datatype.IGetHistoryKlineResp} message GetHistoryKlineResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetHistoryKlineResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.s != null && Object.hasOwnProperty.call(message, "s"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.s);
            if (message.o != null && message.o.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (let i = 0; i < message.o.length; ++i)
                    writer.double(message.o[i]);
                writer.ldelim();
            }
            if (message.c != null && message.c.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (let i = 0; i < message.c.length; ++i)
                    writer.double(message.c[i]);
                writer.ldelim();
            }
            if (message.h != null && message.h.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.h.length; ++i)
                    writer.double(message.h[i]);
                writer.ldelim();
            }
            if (message.l != null && message.l.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.l.length; ++i)
                    writer.double(message.l[i]);
                writer.ldelim();
            }
            if (message.t != null && message.t.length) {
                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                for (let i = 0; i < message.t.length; ++i)
                    writer.uint64(message.t[i]);
                writer.ldelim();
            }
            if (message.nextTime != null && Object.hasOwnProperty.call(message, "nextTime"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.nextTime);
            return writer;
        };

        /**
         * Encodes the specified GetHistoryKlineResp message, length delimited. Does not implicitly {@link datatype.GetHistoryKlineResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.GetHistoryKlineResp
         * @static
         * @param {datatype.IGetHistoryKlineResp} message GetHistoryKlineResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetHistoryKlineResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetHistoryKlineResp message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.GetHistoryKlineResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.GetHistoryKlineResp} GetHistoryKlineResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetHistoryKlineResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.GetHistoryKlineResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.s = reader.string();
                    break;
                case 2:
                    if (!(message.o && message.o.length))
                        message.o = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.o.push(reader.double());
                    } else
                        message.o.push(reader.double());
                    break;
                case 3:
                    if (!(message.c && message.c.length))
                        message.c = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.c.push(reader.double());
                    } else
                        message.c.push(reader.double());
                    break;
                case 4:
                    if (!(message.h && message.h.length))
                        message.h = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.h.push(reader.double());
                    } else
                        message.h.push(reader.double());
                    break;
                case 5:
                    if (!(message.l && message.l.length))
                        message.l = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.l.push(reader.double());
                    } else
                        message.l.push(reader.double());
                    break;
                case 6:
                    if (!(message.t && message.t.length))
                        message.t = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.t.push(reader.uint64());
                    } else
                        message.t.push(reader.uint64());
                    break;
                case 7:
                    message.nextTime = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetHistoryKlineResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.GetHistoryKlineResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.GetHistoryKlineResp} GetHistoryKlineResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetHistoryKlineResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetHistoryKlineResp message.
         * @function verify
         * @memberof datatype.GetHistoryKlineResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetHistoryKlineResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.s != null && message.hasOwnProperty("s"))
                if (!$util.isString(message.s))
                    return "s: string expected";
            if (message.o != null && message.hasOwnProperty("o")) {
                if (!Array.isArray(message.o))
                    return "o: array expected";
                for (let i = 0; i < message.o.length; ++i)
                    if (typeof message.o[i] !== "number")
                        return "o: number[] expected";
            }
            if (message.c != null && message.hasOwnProperty("c")) {
                if (!Array.isArray(message.c))
                    return "c: array expected";
                for (let i = 0; i < message.c.length; ++i)
                    if (typeof message.c[i] !== "number")
                        return "c: number[] expected";
            }
            if (message.h != null && message.hasOwnProperty("h")) {
                if (!Array.isArray(message.h))
                    return "h: array expected";
                for (let i = 0; i < message.h.length; ++i)
                    if (typeof message.h[i] !== "number")
                        return "h: number[] expected";
            }
            if (message.l != null && message.hasOwnProperty("l")) {
                if (!Array.isArray(message.l))
                    return "l: array expected";
                for (let i = 0; i < message.l.length; ++i)
                    if (typeof message.l[i] !== "number")
                        return "l: number[] expected";
            }
            if (message.t != null && message.hasOwnProperty("t")) {
                if (!Array.isArray(message.t))
                    return "t: array expected";
                for (let i = 0; i < message.t.length; ++i)
                    if (!$util.isInteger(message.t[i]) && !(message.t[i] && $util.isInteger(message.t[i].low) && $util.isInteger(message.t[i].high)))
                        return "t: integer|Long[] expected";
            }
            if (message.nextTime != null && message.hasOwnProperty("nextTime"))
                if (!$util.isInteger(message.nextTime) && !(message.nextTime && $util.isInteger(message.nextTime.low) && $util.isInteger(message.nextTime.high)))
                    return "nextTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a GetHistoryKlineResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.GetHistoryKlineResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.GetHistoryKlineResp} GetHistoryKlineResp
         */
        GetHistoryKlineResp.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.GetHistoryKlineResp)
                return object;
            let message = new $root.datatype.GetHistoryKlineResp();
            if (object.s != null)
                message.s = String(object.s);
            if (object.o) {
                if (!Array.isArray(object.o))
                    throw TypeError(".datatype.GetHistoryKlineResp.o: array expected");
                message.o = [];
                for (let i = 0; i < object.o.length; ++i)
                    message.o[i] = Number(object.o[i]);
            }
            if (object.c) {
                if (!Array.isArray(object.c))
                    throw TypeError(".datatype.GetHistoryKlineResp.c: array expected");
                message.c = [];
                for (let i = 0; i < object.c.length; ++i)
                    message.c[i] = Number(object.c[i]);
            }
            if (object.h) {
                if (!Array.isArray(object.h))
                    throw TypeError(".datatype.GetHistoryKlineResp.h: array expected");
                message.h = [];
                for (let i = 0; i < object.h.length; ++i)
                    message.h[i] = Number(object.h[i]);
            }
            if (object.l) {
                if (!Array.isArray(object.l))
                    throw TypeError(".datatype.GetHistoryKlineResp.l: array expected");
                message.l = [];
                for (let i = 0; i < object.l.length; ++i)
                    message.l[i] = Number(object.l[i]);
            }
            if (object.t) {
                if (!Array.isArray(object.t))
                    throw TypeError(".datatype.GetHistoryKlineResp.t: array expected");
                message.t = [];
                for (let i = 0; i < object.t.length; ++i)
                    if ($util.Long)
                        (message.t[i] = $util.Long.fromValue(object.t[i])).unsigned = true;
                    else if (typeof object.t[i] === "string")
                        message.t[i] = parseInt(object.t[i], 10);
                    else if (typeof object.t[i] === "number")
                        message.t[i] = object.t[i];
                    else if (typeof object.t[i] === "object")
                        message.t[i] = new $util.LongBits(object.t[i].low >>> 0, object.t[i].high >>> 0).toNumber(true);
            }
            if (object.nextTime != null)
                if ($util.Long)
                    (message.nextTime = $util.Long.fromValue(object.nextTime)).unsigned = true;
                else if (typeof object.nextTime === "string")
                    message.nextTime = parseInt(object.nextTime, 10);
                else if (typeof object.nextTime === "number")
                    message.nextTime = object.nextTime;
                else if (typeof object.nextTime === "object")
                    message.nextTime = new $util.LongBits(object.nextTime.low >>> 0, object.nextTime.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a GetHistoryKlineResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.GetHistoryKlineResp
         * @static
         * @param {datatype.GetHistoryKlineResp} message GetHistoryKlineResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetHistoryKlineResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.o = [];
                object.c = [];
                object.h = [];
                object.l = [];
                object.t = [];
            }
            if (options.defaults) {
                object.s = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.nextTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nextTime = options.longs === String ? "0" : 0;
            }
            if (message.s != null && message.hasOwnProperty("s"))
                object.s = message.s;
            if (message.o && message.o.length) {
                object.o = [];
                for (let j = 0; j < message.o.length; ++j)
                    object.o[j] = options.json && !isFinite(message.o[j]) ? String(message.o[j]) : message.o[j];
            }
            if (message.c && message.c.length) {
                object.c = [];
                for (let j = 0; j < message.c.length; ++j)
                    object.c[j] = options.json && !isFinite(message.c[j]) ? String(message.c[j]) : message.c[j];
            }
            if (message.h && message.h.length) {
                object.h = [];
                for (let j = 0; j < message.h.length; ++j)
                    object.h[j] = options.json && !isFinite(message.h[j]) ? String(message.h[j]) : message.h[j];
            }
            if (message.l && message.l.length) {
                object.l = [];
                for (let j = 0; j < message.l.length; ++j)
                    object.l[j] = options.json && !isFinite(message.l[j]) ? String(message.l[j]) : message.l[j];
            }
            if (message.t && message.t.length) {
                object.t = [];
                for (let j = 0; j < message.t.length; ++j)
                    if (typeof message.t[j] === "number")
                        object.t[j] = options.longs === String ? String(message.t[j]) : message.t[j];
                    else
                        object.t[j] = options.longs === String ? $util.Long.prototype.toString.call(message.t[j]) : options.longs === Number ? new $util.LongBits(message.t[j].low >>> 0, message.t[j].high >>> 0).toNumber(true) : message.t[j];
            }
            if (message.nextTime != null && message.hasOwnProperty("nextTime"))
                if (typeof message.nextTime === "number")
                    object.nextTime = options.longs === String ? String(message.nextTime) : message.nextTime;
                else
                    object.nextTime = options.longs === String ? $util.Long.prototype.toString.call(message.nextTime) : options.longs === Number ? new $util.LongBits(message.nextTime.low >>> 0, message.nextTime.high >>> 0).toNumber(true) : message.nextTime;
            return object;
        };

        /**
         * Converts this GetHistoryKlineResp to JSON.
         * @function toJSON
         * @memberof datatype.GetHistoryKlineResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetHistoryKlineResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetHistoryKlineResp;
    })();

    datatype.GetMarkReq = (function() {

        /**
         * Properties of a GetMarkReq.
         * @memberof datatype
         * @interface IGetMarkReq
         * @property {string|null} [symbol] GetMarkReq symbol
         * @property {number|null} [from] GetMarkReq from
         * @property {number|null} [to] GetMarkReq to
         * @property {string|null} [resolution] GetMarkReq resolution
         * @property {string|null} [source] GetMarkReq source
         */

        /**
         * Constructs a new GetMarkReq.
         * @memberof datatype
         * @classdesc Represents a GetMarkReq.
         * @implements IGetMarkReq
         * @constructor
         * @param {datatype.IGetMarkReq=} [properties] Properties to set
         */
        function GetMarkReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetMarkReq symbol.
         * @member {string} symbol
         * @memberof datatype.GetMarkReq
         * @instance
         */
        GetMarkReq.prototype.symbol = "";

        /**
         * GetMarkReq from.
         * @member {number} from
         * @memberof datatype.GetMarkReq
         * @instance
         */
        GetMarkReq.prototype.from = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GetMarkReq to.
         * @member {number} to
         * @memberof datatype.GetMarkReq
         * @instance
         */
        GetMarkReq.prototype.to = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GetMarkReq resolution.
         * @member {string} resolution
         * @memberof datatype.GetMarkReq
         * @instance
         */
        GetMarkReq.prototype.resolution = "";

        /**
         * GetMarkReq source.
         * @member {string} source
         * @memberof datatype.GetMarkReq
         * @instance
         */
        GetMarkReq.prototype.source = "";

        /**
         * Creates a new GetMarkReq instance using the specified properties.
         * @function create
         * @memberof datatype.GetMarkReq
         * @static
         * @param {datatype.IGetMarkReq=} [properties] Properties to set
         * @returns {datatype.GetMarkReq} GetMarkReq instance
         */
        GetMarkReq.create = function create(properties) {
            return new GetMarkReq(properties);
        };

        /**
         * Encodes the specified GetMarkReq message. Does not implicitly {@link datatype.GetMarkReq.verify|verify} messages.
         * @function encode
         * @memberof datatype.GetMarkReq
         * @static
         * @param {datatype.IGetMarkReq} message GetMarkReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMarkReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.symbol);
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.from);
            if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.to);
            if (message.resolution != null && Object.hasOwnProperty.call(message, "resolution"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.resolution);
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                writer.uint32(/* id 100, wireType 2 =*/802).string(message.source);
            return writer;
        };

        /**
         * Encodes the specified GetMarkReq message, length delimited. Does not implicitly {@link datatype.GetMarkReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.GetMarkReq
         * @static
         * @param {datatype.IGetMarkReq} message GetMarkReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMarkReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMarkReq message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.GetMarkReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.GetMarkReq} GetMarkReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMarkReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.GetMarkReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.symbol = reader.string();
                    break;
                case 2:
                    message.from = reader.uint64();
                    break;
                case 3:
                    message.to = reader.uint64();
                    break;
                case 4:
                    message.resolution = reader.string();
                    break;
                case 100:
                    message.source = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMarkReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.GetMarkReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.GetMarkReq} GetMarkReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMarkReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMarkReq message.
         * @function verify
         * @memberof datatype.GetMarkReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMarkReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                if (!$util.isString(message.symbol))
                    return "symbol: string expected";
            if (message.from != null && message.hasOwnProperty("from"))
                if (!$util.isInteger(message.from) && !(message.from && $util.isInteger(message.from.low) && $util.isInteger(message.from.high)))
                    return "from: integer|Long expected";
            if (message.to != null && message.hasOwnProperty("to"))
                if (!$util.isInteger(message.to) && !(message.to && $util.isInteger(message.to.low) && $util.isInteger(message.to.high)))
                    return "to: integer|Long expected";
            if (message.resolution != null && message.hasOwnProperty("resolution"))
                if (!$util.isString(message.resolution))
                    return "resolution: string expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!$util.isString(message.source))
                    return "source: string expected";
            return null;
        };

        /**
         * Creates a GetMarkReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.GetMarkReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.GetMarkReq} GetMarkReq
         */
        GetMarkReq.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.GetMarkReq)
                return object;
            let message = new $root.datatype.GetMarkReq();
            if (object.symbol != null)
                message.symbol = String(object.symbol);
            if (object.from != null)
                if ($util.Long)
                    (message.from = $util.Long.fromValue(object.from)).unsigned = true;
                else if (typeof object.from === "string")
                    message.from = parseInt(object.from, 10);
                else if (typeof object.from === "number")
                    message.from = object.from;
                else if (typeof object.from === "object")
                    message.from = new $util.LongBits(object.from.low >>> 0, object.from.high >>> 0).toNumber(true);
            if (object.to != null)
                if ($util.Long)
                    (message.to = $util.Long.fromValue(object.to)).unsigned = true;
                else if (typeof object.to === "string")
                    message.to = parseInt(object.to, 10);
                else if (typeof object.to === "number")
                    message.to = object.to;
                else if (typeof object.to === "object")
                    message.to = new $util.LongBits(object.to.low >>> 0, object.to.high >>> 0).toNumber(true);
            if (object.resolution != null)
                message.resolution = String(object.resolution);
            if (object.source != null)
                message.source = String(object.source);
            return message;
        };

        /**
         * Creates a plain object from a GetMarkReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.GetMarkReq
         * @static
         * @param {datatype.GetMarkReq} message GetMarkReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetMarkReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.symbol = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.from = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.from = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.to = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.to = options.longs === String ? "0" : 0;
                object.resolution = "";
                object.source = "";
            }
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                object.symbol = message.symbol;
            if (message.from != null && message.hasOwnProperty("from"))
                if (typeof message.from === "number")
                    object.from = options.longs === String ? String(message.from) : message.from;
                else
                    object.from = options.longs === String ? $util.Long.prototype.toString.call(message.from) : options.longs === Number ? new $util.LongBits(message.from.low >>> 0, message.from.high >>> 0).toNumber(true) : message.from;
            if (message.to != null && message.hasOwnProperty("to"))
                if (typeof message.to === "number")
                    object.to = options.longs === String ? String(message.to) : message.to;
                else
                    object.to = options.longs === String ? $util.Long.prototype.toString.call(message.to) : options.longs === Number ? new $util.LongBits(message.to.low >>> 0, message.to.high >>> 0).toNumber(true) : message.to;
            if (message.resolution != null && message.hasOwnProperty("resolution"))
                object.resolution = message.resolution;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = message.source;
            return object;
        };

        /**
         * Converts this GetMarkReq to JSON.
         * @function toJSON
         * @memberof datatype.GetMarkReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetMarkReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetMarkReq;
    })();

    datatype.Mark = (function() {

        /**
         * Properties of a Mark.
         * @memberof datatype
         * @interface IMark
         * @property {string|null} [id] Mark id
         * @property {number|null} [time] Mark time
         * @property {string|null} [color] Mark color
         * @property {string|null} [text] Mark text
         * @property {string|null} [label] Mark label
         * @property {string|null} [labelFontColor] Mark labelFontColor
         * @property {number|null} [minSize] Mark minSize
         */

        /**
         * Constructs a new Mark.
         * @memberof datatype
         * @classdesc Represents a Mark.
         * @implements IMark
         * @constructor
         * @param {datatype.IMark=} [properties] Properties to set
         */
        function Mark(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Mark id.
         * @member {string} id
         * @memberof datatype.Mark
         * @instance
         */
        Mark.prototype.id = "";

        /**
         * Mark time.
         * @member {number} time
         * @memberof datatype.Mark
         * @instance
         */
        Mark.prototype.time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Mark color.
         * @member {string} color
         * @memberof datatype.Mark
         * @instance
         */
        Mark.prototype.color = "";

        /**
         * Mark text.
         * @member {string} text
         * @memberof datatype.Mark
         * @instance
         */
        Mark.prototype.text = "";

        /**
         * Mark label.
         * @member {string} label
         * @memberof datatype.Mark
         * @instance
         */
        Mark.prototype.label = "";

        /**
         * Mark labelFontColor.
         * @member {string} labelFontColor
         * @memberof datatype.Mark
         * @instance
         */
        Mark.prototype.labelFontColor = "";

        /**
         * Mark minSize.
         * @member {number} minSize
         * @memberof datatype.Mark
         * @instance
         */
        Mark.prototype.minSize = 0;

        /**
         * Creates a new Mark instance using the specified properties.
         * @function create
         * @memberof datatype.Mark
         * @static
         * @param {datatype.IMark=} [properties] Properties to set
         * @returns {datatype.Mark} Mark instance
         */
        Mark.create = function create(properties) {
            return new Mark(properties);
        };

        /**
         * Encodes the specified Mark message. Does not implicitly {@link datatype.Mark.verify|verify} messages.
         * @function encode
         * @memberof datatype.Mark
         * @static
         * @param {datatype.IMark} message Mark message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Mark.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.time);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.color);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.text);
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.label);
            if (message.labelFontColor != null && Object.hasOwnProperty.call(message, "labelFontColor"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.labelFontColor);
            if (message.minSize != null && Object.hasOwnProperty.call(message, "minSize"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.minSize);
            return writer;
        };

        /**
         * Encodes the specified Mark message, length delimited. Does not implicitly {@link datatype.Mark.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.Mark
         * @static
         * @param {datatype.IMark} message Mark message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Mark.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Mark message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.Mark
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.Mark} Mark
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Mark.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.Mark();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.time = reader.uint64();
                    break;
                case 3:
                    message.color = reader.string();
                    break;
                case 4:
                    message.text = reader.string();
                    break;
                case 5:
                    message.label = reader.string();
                    break;
                case 6:
                    message.labelFontColor = reader.string();
                    break;
                case 7:
                    message.minSize = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Mark message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.Mark
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.Mark} Mark
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Mark.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Mark message.
         * @function verify
         * @memberof datatype.Mark
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Mark.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isString(message.color))
                    return "color: string expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.label != null && message.hasOwnProperty("label"))
                if (!$util.isString(message.label))
                    return "label: string expected";
            if (message.labelFontColor != null && message.hasOwnProperty("labelFontColor"))
                if (!$util.isString(message.labelFontColor))
                    return "labelFontColor: string expected";
            if (message.minSize != null && message.hasOwnProperty("minSize"))
                if (!$util.isInteger(message.minSize))
                    return "minSize: integer expected";
            return null;
        };

        /**
         * Creates a Mark message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.Mark
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.Mark} Mark
         */
        Mark.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.Mark)
                return object;
            let message = new $root.datatype.Mark();
            if (object.id != null)
                message.id = String(object.id);
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = true;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber(true);
            if (object.color != null)
                message.color = String(object.color);
            if (object.text != null)
                message.text = String(object.text);
            if (object.label != null)
                message.label = String(object.label);
            if (object.labelFontColor != null)
                message.labelFontColor = String(object.labelFontColor);
            if (object.minSize != null)
                message.minSize = object.minSize >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Mark message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.Mark
         * @static
         * @param {datatype.Mark} message Mark
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Mark.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
                object.color = "";
                object.text = "";
                object.label = "";
                object.labelFontColor = "";
                object.minSize = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber(true) : message.time;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.label != null && message.hasOwnProperty("label"))
                object.label = message.label;
            if (message.labelFontColor != null && message.hasOwnProperty("labelFontColor"))
                object.labelFontColor = message.labelFontColor;
            if (message.minSize != null && message.hasOwnProperty("minSize"))
                object.minSize = message.minSize;
            return object;
        };

        /**
         * Converts this Mark to JSON.
         * @function toJSON
         * @memberof datatype.Mark
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Mark.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Mark;
    })();

    datatype.GetMarkResp = (function() {

        /**
         * Properties of a GetMarkResp.
         * @memberof datatype
         * @interface IGetMarkResp
         * @property {Array.<string>|null} [id] GetMarkResp id
         * @property {Array.<number>|null} [time] GetMarkResp time
         * @property {Array.<string>|null} [color] GetMarkResp color
         * @property {Array.<string>|null} [text] GetMarkResp text
         * @property {Array.<string>|null} [label] GetMarkResp label
         * @property {Array.<string>|null} [labelFontColor] GetMarkResp labelFontColor
         * @property {Array.<number>|null} [minSize] GetMarkResp minSize
         */

        /**
         * Constructs a new GetMarkResp.
         * @memberof datatype
         * @classdesc Represents a GetMarkResp.
         * @implements IGetMarkResp
         * @constructor
         * @param {datatype.IGetMarkResp=} [properties] Properties to set
         */
        function GetMarkResp(properties) {
            this.id = [];
            this.time = [];
            this.color = [];
            this.text = [];
            this.label = [];
            this.labelFontColor = [];
            this.minSize = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetMarkResp id.
         * @member {Array.<string>} id
         * @memberof datatype.GetMarkResp
         * @instance
         */
        GetMarkResp.prototype.id = $util.emptyArray;

        /**
         * GetMarkResp time.
         * @member {Array.<number>} time
         * @memberof datatype.GetMarkResp
         * @instance
         */
        GetMarkResp.prototype.time = $util.emptyArray;

        /**
         * GetMarkResp color.
         * @member {Array.<string>} color
         * @memberof datatype.GetMarkResp
         * @instance
         */
        GetMarkResp.prototype.color = $util.emptyArray;

        /**
         * GetMarkResp text.
         * @member {Array.<string>} text
         * @memberof datatype.GetMarkResp
         * @instance
         */
        GetMarkResp.prototype.text = $util.emptyArray;

        /**
         * GetMarkResp label.
         * @member {Array.<string>} label
         * @memberof datatype.GetMarkResp
         * @instance
         */
        GetMarkResp.prototype.label = $util.emptyArray;

        /**
         * GetMarkResp labelFontColor.
         * @member {Array.<string>} labelFontColor
         * @memberof datatype.GetMarkResp
         * @instance
         */
        GetMarkResp.prototype.labelFontColor = $util.emptyArray;

        /**
         * GetMarkResp minSize.
         * @member {Array.<number>} minSize
         * @memberof datatype.GetMarkResp
         * @instance
         */
        GetMarkResp.prototype.minSize = $util.emptyArray;

        /**
         * Creates a new GetMarkResp instance using the specified properties.
         * @function create
         * @memberof datatype.GetMarkResp
         * @static
         * @param {datatype.IGetMarkResp=} [properties] Properties to set
         * @returns {datatype.GetMarkResp} GetMarkResp instance
         */
        GetMarkResp.create = function create(properties) {
            return new GetMarkResp(properties);
        };

        /**
         * Encodes the specified GetMarkResp message. Does not implicitly {@link datatype.GetMarkResp.verify|verify} messages.
         * @function encode
         * @memberof datatype.GetMarkResp
         * @static
         * @param {datatype.IGetMarkResp} message GetMarkResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMarkResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.id.length)
                for (let i = 0; i < message.id.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id[i]);
            if (message.time != null && message.time.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (let i = 0; i < message.time.length; ++i)
                    writer.uint64(message.time[i]);
                writer.ldelim();
            }
            if (message.color != null && message.color.length)
                for (let i = 0; i < message.color.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.color[i]);
            if (message.text != null && message.text.length)
                for (let i = 0; i < message.text.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.text[i]);
            if (message.label != null && message.label.length)
                for (let i = 0; i < message.label.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.label[i]);
            if (message.labelFontColor != null && message.labelFontColor.length)
                for (let i = 0; i < message.labelFontColor.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.labelFontColor[i]);
            if (message.minSize != null && message.minSize.length) {
                writer.uint32(/* id 7, wireType 2 =*/58).fork();
                for (let i = 0; i < message.minSize.length; ++i)
                    writer.uint32(message.minSize[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetMarkResp message, length delimited. Does not implicitly {@link datatype.GetMarkResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.GetMarkResp
         * @static
         * @param {datatype.IGetMarkResp} message GetMarkResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMarkResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMarkResp message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.GetMarkResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.GetMarkResp} GetMarkResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMarkResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.GetMarkResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.id && message.id.length))
                        message.id = [];
                    message.id.push(reader.string());
                    break;
                case 2:
                    if (!(message.time && message.time.length))
                        message.time = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.time.push(reader.uint64());
                    } else
                        message.time.push(reader.uint64());
                    break;
                case 3:
                    if (!(message.color && message.color.length))
                        message.color = [];
                    message.color.push(reader.string());
                    break;
                case 4:
                    if (!(message.text && message.text.length))
                        message.text = [];
                    message.text.push(reader.string());
                    break;
                case 5:
                    if (!(message.label && message.label.length))
                        message.label = [];
                    message.label.push(reader.string());
                    break;
                case 6:
                    if (!(message.labelFontColor && message.labelFontColor.length))
                        message.labelFontColor = [];
                    message.labelFontColor.push(reader.string());
                    break;
                case 7:
                    if (!(message.minSize && message.minSize.length))
                        message.minSize = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.minSize.push(reader.uint32());
                    } else
                        message.minSize.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMarkResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.GetMarkResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.GetMarkResp} GetMarkResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMarkResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMarkResp message.
         * @function verify
         * @memberof datatype.GetMarkResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMarkResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                if (!Array.isArray(message.id))
                    return "id: array expected";
                for (let i = 0; i < message.id.length; ++i)
                    if (!$util.isString(message.id[i]))
                        return "id: string[] expected";
            }
            if (message.time != null && message.hasOwnProperty("time")) {
                if (!Array.isArray(message.time))
                    return "time: array expected";
                for (let i = 0; i < message.time.length; ++i)
                    if (!$util.isInteger(message.time[i]) && !(message.time[i] && $util.isInteger(message.time[i].low) && $util.isInteger(message.time[i].high)))
                        return "time: integer|Long[] expected";
            }
            if (message.color != null && message.hasOwnProperty("color")) {
                if (!Array.isArray(message.color))
                    return "color: array expected";
                for (let i = 0; i < message.color.length; ++i)
                    if (!$util.isString(message.color[i]))
                        return "color: string[] expected";
            }
            if (message.text != null && message.hasOwnProperty("text")) {
                if (!Array.isArray(message.text))
                    return "text: array expected";
                for (let i = 0; i < message.text.length; ++i)
                    if (!$util.isString(message.text[i]))
                        return "text: string[] expected";
            }
            if (message.label != null && message.hasOwnProperty("label")) {
                if (!Array.isArray(message.label))
                    return "label: array expected";
                for (let i = 0; i < message.label.length; ++i)
                    if (!$util.isString(message.label[i]))
                        return "label: string[] expected";
            }
            if (message.labelFontColor != null && message.hasOwnProperty("labelFontColor")) {
                if (!Array.isArray(message.labelFontColor))
                    return "labelFontColor: array expected";
                for (let i = 0; i < message.labelFontColor.length; ++i)
                    if (!$util.isString(message.labelFontColor[i]))
                        return "labelFontColor: string[] expected";
            }
            if (message.minSize != null && message.hasOwnProperty("minSize")) {
                if (!Array.isArray(message.minSize))
                    return "minSize: array expected";
                for (let i = 0; i < message.minSize.length; ++i)
                    if (!$util.isInteger(message.minSize[i]))
                        return "minSize: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a GetMarkResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.GetMarkResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.GetMarkResp} GetMarkResp
         */
        GetMarkResp.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.GetMarkResp)
                return object;
            let message = new $root.datatype.GetMarkResp();
            if (object.id) {
                if (!Array.isArray(object.id))
                    throw TypeError(".datatype.GetMarkResp.id: array expected");
                message.id = [];
                for (let i = 0; i < object.id.length; ++i)
                    message.id[i] = String(object.id[i]);
            }
            if (object.time) {
                if (!Array.isArray(object.time))
                    throw TypeError(".datatype.GetMarkResp.time: array expected");
                message.time = [];
                for (let i = 0; i < object.time.length; ++i)
                    if ($util.Long)
                        (message.time[i] = $util.Long.fromValue(object.time[i])).unsigned = true;
                    else if (typeof object.time[i] === "string")
                        message.time[i] = parseInt(object.time[i], 10);
                    else if (typeof object.time[i] === "number")
                        message.time[i] = object.time[i];
                    else if (typeof object.time[i] === "object")
                        message.time[i] = new $util.LongBits(object.time[i].low >>> 0, object.time[i].high >>> 0).toNumber(true);
            }
            if (object.color) {
                if (!Array.isArray(object.color))
                    throw TypeError(".datatype.GetMarkResp.color: array expected");
                message.color = [];
                for (let i = 0; i < object.color.length; ++i)
                    message.color[i] = String(object.color[i]);
            }
            if (object.text) {
                if (!Array.isArray(object.text))
                    throw TypeError(".datatype.GetMarkResp.text: array expected");
                message.text = [];
                for (let i = 0; i < object.text.length; ++i)
                    message.text[i] = String(object.text[i]);
            }
            if (object.label) {
                if (!Array.isArray(object.label))
                    throw TypeError(".datatype.GetMarkResp.label: array expected");
                message.label = [];
                for (let i = 0; i < object.label.length; ++i)
                    message.label[i] = String(object.label[i]);
            }
            if (object.labelFontColor) {
                if (!Array.isArray(object.labelFontColor))
                    throw TypeError(".datatype.GetMarkResp.labelFontColor: array expected");
                message.labelFontColor = [];
                for (let i = 0; i < object.labelFontColor.length; ++i)
                    message.labelFontColor[i] = String(object.labelFontColor[i]);
            }
            if (object.minSize) {
                if (!Array.isArray(object.minSize))
                    throw TypeError(".datatype.GetMarkResp.minSize: array expected");
                message.minSize = [];
                for (let i = 0; i < object.minSize.length; ++i)
                    message.minSize[i] = object.minSize[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a GetMarkResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.GetMarkResp
         * @static
         * @param {datatype.GetMarkResp} message GetMarkResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetMarkResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.id = [];
                object.time = [];
                object.color = [];
                object.text = [];
                object.label = [];
                object.labelFontColor = [];
                object.minSize = [];
            }
            if (message.id && message.id.length) {
                object.id = [];
                for (let j = 0; j < message.id.length; ++j)
                    object.id[j] = message.id[j];
            }
            if (message.time && message.time.length) {
                object.time = [];
                for (let j = 0; j < message.time.length; ++j)
                    if (typeof message.time[j] === "number")
                        object.time[j] = options.longs === String ? String(message.time[j]) : message.time[j];
                    else
                        object.time[j] = options.longs === String ? $util.Long.prototype.toString.call(message.time[j]) : options.longs === Number ? new $util.LongBits(message.time[j].low >>> 0, message.time[j].high >>> 0).toNumber(true) : message.time[j];
            }
            if (message.color && message.color.length) {
                object.color = [];
                for (let j = 0; j < message.color.length; ++j)
                    object.color[j] = message.color[j];
            }
            if (message.text && message.text.length) {
                object.text = [];
                for (let j = 0; j < message.text.length; ++j)
                    object.text[j] = message.text[j];
            }
            if (message.label && message.label.length) {
                object.label = [];
                for (let j = 0; j < message.label.length; ++j)
                    object.label[j] = message.label[j];
            }
            if (message.labelFontColor && message.labelFontColor.length) {
                object.labelFontColor = [];
                for (let j = 0; j < message.labelFontColor.length; ++j)
                    object.labelFontColor[j] = message.labelFontColor[j];
            }
            if (message.minSize && message.minSize.length) {
                object.minSize = [];
                for (let j = 0; j < message.minSize.length; ++j)
                    object.minSize[j] = message.minSize[j];
            }
            return object;
        };

        /**
         * Converts this GetMarkResp to JSON.
         * @function toJSON
         * @memberof datatype.GetMarkResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetMarkResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetMarkResp;
    })();

    datatype.SearchSymbolReq = (function() {

        /**
         * Properties of a SearchSymbolReq.
         * @memberof datatype
         * @interface ISearchSymbolReq
         * @property {string|null} [query] SearchSymbolReq query
         * @property {string|null} [exchange] SearchSymbolReq exchange
         * @property {number|null} [limit] SearchSymbolReq limit
         * @property {string|null} [type] SearchSymbolReq type
         * @property {string|null} [source] SearchSymbolReq source
         */

        /**
         * Constructs a new SearchSymbolReq.
         * @memberof datatype
         * @classdesc Represents a SearchSymbolReq.
         * @implements ISearchSymbolReq
         * @constructor
         * @param {datatype.ISearchSymbolReq=} [properties] Properties to set
         */
        function SearchSymbolReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchSymbolReq query.
         * @member {string} query
         * @memberof datatype.SearchSymbolReq
         * @instance
         */
        SearchSymbolReq.prototype.query = "";

        /**
         * SearchSymbolReq exchange.
         * @member {string} exchange
         * @memberof datatype.SearchSymbolReq
         * @instance
         */
        SearchSymbolReq.prototype.exchange = "";

        /**
         * SearchSymbolReq limit.
         * @member {number} limit
         * @memberof datatype.SearchSymbolReq
         * @instance
         */
        SearchSymbolReq.prototype.limit = 0;

        /**
         * SearchSymbolReq type.
         * @member {string} type
         * @memberof datatype.SearchSymbolReq
         * @instance
         */
        SearchSymbolReq.prototype.type = "";

        /**
         * SearchSymbolReq source.
         * @member {string} source
         * @memberof datatype.SearchSymbolReq
         * @instance
         */
        SearchSymbolReq.prototype.source = "";

        /**
         * Creates a new SearchSymbolReq instance using the specified properties.
         * @function create
         * @memberof datatype.SearchSymbolReq
         * @static
         * @param {datatype.ISearchSymbolReq=} [properties] Properties to set
         * @returns {datatype.SearchSymbolReq} SearchSymbolReq instance
         */
        SearchSymbolReq.create = function create(properties) {
            return new SearchSymbolReq(properties);
        };

        /**
         * Encodes the specified SearchSymbolReq message. Does not implicitly {@link datatype.SearchSymbolReq.verify|verify} messages.
         * @function encode
         * @memberof datatype.SearchSymbolReq
         * @static
         * @param {datatype.ISearchSymbolReq} message SearchSymbolReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchSymbolReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
            if (message.exchange != null && Object.hasOwnProperty.call(message, "exchange"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.exchange);
            if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.limit);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.type);
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                writer.uint32(/* id 100, wireType 2 =*/802).string(message.source);
            return writer;
        };

        /**
         * Encodes the specified SearchSymbolReq message, length delimited. Does not implicitly {@link datatype.SearchSymbolReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.SearchSymbolReq
         * @static
         * @param {datatype.ISearchSymbolReq} message SearchSymbolReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchSymbolReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchSymbolReq message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.SearchSymbolReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.SearchSymbolReq} SearchSymbolReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchSymbolReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.SearchSymbolReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.query = reader.string();
                    break;
                case 2:
                    message.exchange = reader.string();
                    break;
                case 3:
                    message.limit = reader.uint32();
                    break;
                case 4:
                    message.type = reader.string();
                    break;
                case 100:
                    message.source = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchSymbolReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.SearchSymbolReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.SearchSymbolReq} SearchSymbolReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchSymbolReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchSymbolReq message.
         * @function verify
         * @memberof datatype.SearchSymbolReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchSymbolReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message.exchange != null && message.hasOwnProperty("exchange"))
                if (!$util.isString(message.exchange))
                    return "exchange: string expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit))
                    return "limit: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!$util.isString(message.source))
                    return "source: string expected";
            return null;
        };

        /**
         * Creates a SearchSymbolReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.SearchSymbolReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.SearchSymbolReq} SearchSymbolReq
         */
        SearchSymbolReq.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.SearchSymbolReq)
                return object;
            let message = new $root.datatype.SearchSymbolReq();
            if (object.query != null)
                message.query = String(object.query);
            if (object.exchange != null)
                message.exchange = String(object.exchange);
            if (object.limit != null)
                message.limit = object.limit >>> 0;
            if (object.type != null)
                message.type = String(object.type);
            if (object.source != null)
                message.source = String(object.source);
            return message;
        };

        /**
         * Creates a plain object from a SearchSymbolReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.SearchSymbolReq
         * @static
         * @param {datatype.SearchSymbolReq} message SearchSymbolReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchSymbolReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.query = "";
                object.exchange = "";
                object.limit = 0;
                object.type = "";
                object.source = "";
            }
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.exchange != null && message.hasOwnProperty("exchange"))
                object.exchange = message.exchange;
            if (message.limit != null && message.hasOwnProperty("limit"))
                object.limit = message.limit;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = message.source;
            return object;
        };

        /**
         * Converts this SearchSymbolReq to JSON.
         * @function toJSON
         * @memberof datatype.SearchSymbolReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchSymbolReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SearchSymbolReq;
    })();

    datatype.SearchSymbolResp = (function() {

        /**
         * Properties of a SearchSymbolResp.
         * @memberof datatype
         * @interface ISearchSymbolResp
         * @property {Array.<datatype.ISymbolInfo>|null} [result] SearchSymbolResp result
         */

        /**
         * Constructs a new SearchSymbolResp.
         * @memberof datatype
         * @classdesc Represents a SearchSymbolResp.
         * @implements ISearchSymbolResp
         * @constructor
         * @param {datatype.ISearchSymbolResp=} [properties] Properties to set
         */
        function SearchSymbolResp(properties) {
            this.result = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchSymbolResp result.
         * @member {Array.<datatype.ISymbolInfo>} result
         * @memberof datatype.SearchSymbolResp
         * @instance
         */
        SearchSymbolResp.prototype.result = $util.emptyArray;

        /**
         * Creates a new SearchSymbolResp instance using the specified properties.
         * @function create
         * @memberof datatype.SearchSymbolResp
         * @static
         * @param {datatype.ISearchSymbolResp=} [properties] Properties to set
         * @returns {datatype.SearchSymbolResp} SearchSymbolResp instance
         */
        SearchSymbolResp.create = function create(properties) {
            return new SearchSymbolResp(properties);
        };

        /**
         * Encodes the specified SearchSymbolResp message. Does not implicitly {@link datatype.SearchSymbolResp.verify|verify} messages.
         * @function encode
         * @memberof datatype.SearchSymbolResp
         * @static
         * @param {datatype.ISearchSymbolResp} message SearchSymbolResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchSymbolResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.result.length)
                for (let i = 0; i < message.result.length; ++i)
                    $root.datatype.SymbolInfo.encode(message.result[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SearchSymbolResp message, length delimited. Does not implicitly {@link datatype.SearchSymbolResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.SearchSymbolResp
         * @static
         * @param {datatype.ISearchSymbolResp} message SearchSymbolResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchSymbolResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchSymbolResp message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.SearchSymbolResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.SearchSymbolResp} SearchSymbolResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchSymbolResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.SearchSymbolResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.result && message.result.length))
                        message.result = [];
                    message.result.push($root.datatype.SymbolInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchSymbolResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.SearchSymbolResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.SearchSymbolResp} SearchSymbolResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchSymbolResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchSymbolResp message.
         * @function verify
         * @memberof datatype.SearchSymbolResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchSymbolResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result")) {
                if (!Array.isArray(message.result))
                    return "result: array expected";
                for (let i = 0; i < message.result.length; ++i) {
                    let error = $root.datatype.SymbolInfo.verify(message.result[i]);
                    if (error)
                        return "result." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SearchSymbolResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.SearchSymbolResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.SearchSymbolResp} SearchSymbolResp
         */
        SearchSymbolResp.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.SearchSymbolResp)
                return object;
            let message = new $root.datatype.SearchSymbolResp();
            if (object.result) {
                if (!Array.isArray(object.result))
                    throw TypeError(".datatype.SearchSymbolResp.result: array expected");
                message.result = [];
                for (let i = 0; i < object.result.length; ++i) {
                    if (typeof object.result[i] !== "object")
                        throw TypeError(".datatype.SearchSymbolResp.result: object expected");
                    message.result[i] = $root.datatype.SymbolInfo.fromObject(object.result[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SearchSymbolResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.SearchSymbolResp
         * @static
         * @param {datatype.SearchSymbolResp} message SearchSymbolResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SearchSymbolResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.result = [];
            if (message.result && message.result.length) {
                object.result = [];
                for (let j = 0; j < message.result.length; ++j)
                    object.result[j] = $root.datatype.SymbolInfo.toObject(message.result[j], options);
            }
            return object;
        };

        /**
         * Converts this SearchSymbolResp to JSON.
         * @function toJSON
         * @memberof datatype.SearchSymbolResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SearchSymbolResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SearchSymbolResp;
    })();

    /**
     * PlatformType enum.
     * @name datatype.PlatformType
     * @enum {number}
     * @property {number} DEFAULT_TYPE=0 DEFAULT_TYPE value
     * @property {number} BYBIT_X=1 BYBIT_X value
     */
    datatype.PlatformType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_TYPE"] = 0;
        values[valuesById[1] = "BYBIT_X"] = 1;
        return values;
    })();

    /**
     * TradeSymbol enum.
     * @name datatype.TradeSymbol
     * @enum {number}
     * @property {number} DEFAULT_SYMBOL=0 DEFAULT_SYMBOL value
     * @property {number} BTCUSDT_FU=1 BTCUSDT_FU value
     */
    datatype.TradeSymbol = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_SYMBOL"] = 0;
        values[valuesById[1] = "BTCUSDT_FU"] = 1;
        return values;
    })();

    /**
     * ActionType enum.
     * @name datatype.ActionType
     * @enum {number}
     * @property {number} DEFAULT_ACTION=0 DEFAULT_ACTION value
     * @property {number} ADD=1 ADD value
     */
    datatype.ActionType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_ACTION"] = 0;
        values[valuesById[1] = "ADD"] = 1;
        return values;
    })();

    datatype.QueryTradeLogReq = (function() {

        /**
         * Properties of a QueryTradeLogReq.
         * @memberof datatype
         * @interface IQueryTradeLogReq
         * @property {string|null} [symbol] QueryTradeLogReq symbol
         * @property {number|null} [limit] QueryTradeLogReq limit
         * @property {number|null} [cursor] QueryTradeLogReq cursor
         * @property {string|null} [source] QueryTradeLogReq source
         */

        /**
         * Constructs a new QueryTradeLogReq.
         * @memberof datatype
         * @classdesc Represents a QueryTradeLogReq.
         * @implements IQueryTradeLogReq
         * @constructor
         * @param {datatype.IQueryTradeLogReq=} [properties] Properties to set
         */
        function QueryTradeLogReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryTradeLogReq symbol.
         * @member {string} symbol
         * @memberof datatype.QueryTradeLogReq
         * @instance
         */
        QueryTradeLogReq.prototype.symbol = "";

        /**
         * QueryTradeLogReq limit.
         * @member {number} limit
         * @memberof datatype.QueryTradeLogReq
         * @instance
         */
        QueryTradeLogReq.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * QueryTradeLogReq cursor.
         * @member {number} cursor
         * @memberof datatype.QueryTradeLogReq
         * @instance
         */
        QueryTradeLogReq.prototype.cursor = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QueryTradeLogReq source.
         * @member {string} source
         * @memberof datatype.QueryTradeLogReq
         * @instance
         */
        QueryTradeLogReq.prototype.source = "";

        /**
         * Creates a new QueryTradeLogReq instance using the specified properties.
         * @function create
         * @memberof datatype.QueryTradeLogReq
         * @static
         * @param {datatype.IQueryTradeLogReq=} [properties] Properties to set
         * @returns {datatype.QueryTradeLogReq} QueryTradeLogReq instance
         */
        QueryTradeLogReq.create = function create(properties) {
            return new QueryTradeLogReq(properties);
        };

        /**
         * Encodes the specified QueryTradeLogReq message. Does not implicitly {@link datatype.QueryTradeLogReq.verify|verify} messages.
         * @function encode
         * @memberof datatype.QueryTradeLogReq
         * @static
         * @param {datatype.IQueryTradeLogReq} message QueryTradeLogReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryTradeLogReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.symbol);
            if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.limit);
            if (message.cursor != null && Object.hasOwnProperty.call(message, "cursor"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.cursor);
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                writer.uint32(/* id 100, wireType 2 =*/802).string(message.source);
            return writer;
        };

        /**
         * Encodes the specified QueryTradeLogReq message, length delimited. Does not implicitly {@link datatype.QueryTradeLogReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.QueryTradeLogReq
         * @static
         * @param {datatype.IQueryTradeLogReq} message QueryTradeLogReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryTradeLogReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryTradeLogReq message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.QueryTradeLogReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.QueryTradeLogReq} QueryTradeLogReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryTradeLogReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.QueryTradeLogReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.symbol = reader.string();
                    break;
                case 2:
                    message.limit = reader.uint64();
                    break;
                case 3:
                    message.cursor = reader.int64();
                    break;
                case 100:
                    message.source = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryTradeLogReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.QueryTradeLogReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.QueryTradeLogReq} QueryTradeLogReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryTradeLogReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryTradeLogReq message.
         * @function verify
         * @memberof datatype.QueryTradeLogReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryTradeLogReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                if (!$util.isString(message.symbol))
                    return "symbol: string expected";
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                    return "limit: integer|Long expected";
            if (message.cursor != null && message.hasOwnProperty("cursor"))
                if (!$util.isInteger(message.cursor) && !(message.cursor && $util.isInteger(message.cursor.low) && $util.isInteger(message.cursor.high)))
                    return "cursor: integer|Long expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!$util.isString(message.source))
                    return "source: string expected";
            return null;
        };

        /**
         * Creates a QueryTradeLogReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.QueryTradeLogReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.QueryTradeLogReq} QueryTradeLogReq
         */
        QueryTradeLogReq.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.QueryTradeLogReq)
                return object;
            let message = new $root.datatype.QueryTradeLogReq();
            if (object.symbol != null)
                message.symbol = String(object.symbol);
            if (object.limit != null)
                if ($util.Long)
                    (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                else if (typeof object.limit === "string")
                    message.limit = parseInt(object.limit, 10);
                else if (typeof object.limit === "number")
                    message.limit = object.limit;
                else if (typeof object.limit === "object")
                    message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
            if (object.cursor != null)
                if ($util.Long)
                    (message.cursor = $util.Long.fromValue(object.cursor)).unsigned = false;
                else if (typeof object.cursor === "string")
                    message.cursor = parseInt(object.cursor, 10);
                else if (typeof object.cursor === "number")
                    message.cursor = object.cursor;
                else if (typeof object.cursor === "object")
                    message.cursor = new $util.LongBits(object.cursor.low >>> 0, object.cursor.high >>> 0).toNumber();
            if (object.source != null)
                message.source = String(object.source);
            return message;
        };

        /**
         * Creates a plain object from a QueryTradeLogReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.QueryTradeLogReq
         * @static
         * @param {datatype.QueryTradeLogReq} message QueryTradeLogReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryTradeLogReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.symbol = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.limit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.cursor = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cursor = options.longs === String ? "0" : 0;
                object.source = "";
            }
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                object.symbol = message.symbol;
            if (message.limit != null && message.hasOwnProperty("limit"))
                if (typeof message.limit === "number")
                    object.limit = options.longs === String ? String(message.limit) : message.limit;
                else
                    object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
            if (message.cursor != null && message.hasOwnProperty("cursor"))
                if (typeof message.cursor === "number")
                    object.cursor = options.longs === String ? String(message.cursor) : message.cursor;
                else
                    object.cursor = options.longs === String ? $util.Long.prototype.toString.call(message.cursor) : options.longs === Number ? new $util.LongBits(message.cursor.low >>> 0, message.cursor.high >>> 0).toNumber() : message.cursor;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = message.source;
            return object;
        };

        /**
         * Converts this QueryTradeLogReq to JSON.
         * @function toJSON
         * @memberof datatype.QueryTradeLogReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryTradeLogReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryTradeLogReq;
    })();

    datatype.TradeLogDo = (function() {

        /**
         * Properties of a TradeLogDo.
         * @memberof datatype
         * @interface ITradeLogDo
         * @property {number|null} [tsUsec] TradeLogDo tsUsec
         * @property {datatype.ActionType|null} [actionType] TradeLogDo actionType
         * @property {datatype.PlatformType|null} [platformType] TradeLogDo platformType
         * @property {datatype.TradeSymbol|null} [tradeSymbol] TradeLogDo tradeSymbol
         * @property {string|null} [info] TradeLogDo info
         */

        /**
         * Constructs a new TradeLogDo.
         * @memberof datatype
         * @classdesc Represents a TradeLogDo.
         * @implements ITradeLogDo
         * @constructor
         * @param {datatype.ITradeLogDo=} [properties] Properties to set
         */
        function TradeLogDo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeLogDo tsUsec.
         * @member {number} tsUsec
         * @memberof datatype.TradeLogDo
         * @instance
         */
        TradeLogDo.prototype.tsUsec = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TradeLogDo actionType.
         * @member {datatype.ActionType} actionType
         * @memberof datatype.TradeLogDo
         * @instance
         */
        TradeLogDo.prototype.actionType = 0;

        /**
         * TradeLogDo platformType.
         * @member {datatype.PlatformType} platformType
         * @memberof datatype.TradeLogDo
         * @instance
         */
        TradeLogDo.prototype.platformType = 0;

        /**
         * TradeLogDo tradeSymbol.
         * @member {datatype.TradeSymbol} tradeSymbol
         * @memberof datatype.TradeLogDo
         * @instance
         */
        TradeLogDo.prototype.tradeSymbol = 0;

        /**
         * TradeLogDo info.
         * @member {string} info
         * @memberof datatype.TradeLogDo
         * @instance
         */
        TradeLogDo.prototype.info = "";

        /**
         * Creates a new TradeLogDo instance using the specified properties.
         * @function create
         * @memberof datatype.TradeLogDo
         * @static
         * @param {datatype.ITradeLogDo=} [properties] Properties to set
         * @returns {datatype.TradeLogDo} TradeLogDo instance
         */
        TradeLogDo.create = function create(properties) {
            return new TradeLogDo(properties);
        };

        /**
         * Encodes the specified TradeLogDo message. Does not implicitly {@link datatype.TradeLogDo.verify|verify} messages.
         * @function encode
         * @memberof datatype.TradeLogDo
         * @static
         * @param {datatype.ITradeLogDo} message TradeLogDo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeLogDo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tsUsec != null && Object.hasOwnProperty.call(message, "tsUsec"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tsUsec);
            if (message.actionType != null && Object.hasOwnProperty.call(message, "actionType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.actionType);
            if (message.platformType != null && Object.hasOwnProperty.call(message, "platformType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.platformType);
            if (message.tradeSymbol != null && Object.hasOwnProperty.call(message, "tradeSymbol"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.tradeSymbol);
            if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.info);
            return writer;
        };

        /**
         * Encodes the specified TradeLogDo message, length delimited. Does not implicitly {@link datatype.TradeLogDo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.TradeLogDo
         * @static
         * @param {datatype.ITradeLogDo} message TradeLogDo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeLogDo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeLogDo message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.TradeLogDo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.TradeLogDo} TradeLogDo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeLogDo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.TradeLogDo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tsUsec = reader.uint64();
                    break;
                case 2:
                    message.actionType = reader.int32();
                    break;
                case 3:
                    message.platformType = reader.int32();
                    break;
                case 4:
                    message.tradeSymbol = reader.int32();
                    break;
                case 5:
                    message.info = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TradeLogDo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.TradeLogDo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.TradeLogDo} TradeLogDo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeLogDo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeLogDo message.
         * @function verify
         * @memberof datatype.TradeLogDo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeLogDo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tsUsec != null && message.hasOwnProperty("tsUsec"))
                if (!$util.isInteger(message.tsUsec) && !(message.tsUsec && $util.isInteger(message.tsUsec.low) && $util.isInteger(message.tsUsec.high)))
                    return "tsUsec: integer|Long expected";
            if (message.actionType != null && message.hasOwnProperty("actionType"))
                switch (message.actionType) {
                default:
                    return "actionType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.platformType != null && message.hasOwnProperty("platformType"))
                switch (message.platformType) {
                default:
                    return "platformType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.tradeSymbol != null && message.hasOwnProperty("tradeSymbol"))
                switch (message.tradeSymbol) {
                default:
                    return "tradeSymbol: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.info != null && message.hasOwnProperty("info"))
                if (!$util.isString(message.info))
                    return "info: string expected";
            return null;
        };

        /**
         * Creates a TradeLogDo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.TradeLogDo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.TradeLogDo} TradeLogDo
         */
        TradeLogDo.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.TradeLogDo)
                return object;
            let message = new $root.datatype.TradeLogDo();
            if (object.tsUsec != null)
                if ($util.Long)
                    (message.tsUsec = $util.Long.fromValue(object.tsUsec)).unsigned = true;
                else if (typeof object.tsUsec === "string")
                    message.tsUsec = parseInt(object.tsUsec, 10);
                else if (typeof object.tsUsec === "number")
                    message.tsUsec = object.tsUsec;
                else if (typeof object.tsUsec === "object")
                    message.tsUsec = new $util.LongBits(object.tsUsec.low >>> 0, object.tsUsec.high >>> 0).toNumber(true);
            switch (object.actionType) {
            case "DEFAULT_ACTION":
            case 0:
                message.actionType = 0;
                break;
            case "ADD":
            case 1:
                message.actionType = 1;
                break;
            }
            switch (object.platformType) {
            case "DEFAULT_TYPE":
            case 0:
                message.platformType = 0;
                break;
            case "BYBIT_X":
            case 1:
                message.platformType = 1;
                break;
            }
            switch (object.tradeSymbol) {
            case "DEFAULT_SYMBOL":
            case 0:
                message.tradeSymbol = 0;
                break;
            case "BTCUSDT_FU":
            case 1:
                message.tradeSymbol = 1;
                break;
            }
            if (object.info != null)
                message.info = String(object.info);
            return message;
        };

        /**
         * Creates a plain object from a TradeLogDo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.TradeLogDo
         * @static
         * @param {datatype.TradeLogDo} message TradeLogDo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeLogDo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.tsUsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.tsUsec = options.longs === String ? "0" : 0;
                object.actionType = options.enums === String ? "DEFAULT_ACTION" : 0;
                object.platformType = options.enums === String ? "DEFAULT_TYPE" : 0;
                object.tradeSymbol = options.enums === String ? "DEFAULT_SYMBOL" : 0;
                object.info = "";
            }
            if (message.tsUsec != null && message.hasOwnProperty("tsUsec"))
                if (typeof message.tsUsec === "number")
                    object.tsUsec = options.longs === String ? String(message.tsUsec) : message.tsUsec;
                else
                    object.tsUsec = options.longs === String ? $util.Long.prototype.toString.call(message.tsUsec) : options.longs === Number ? new $util.LongBits(message.tsUsec.low >>> 0, message.tsUsec.high >>> 0).toNumber(true) : message.tsUsec;
            if (message.actionType != null && message.hasOwnProperty("actionType"))
                object.actionType = options.enums === String ? $root.datatype.ActionType[message.actionType] : message.actionType;
            if (message.platformType != null && message.hasOwnProperty("platformType"))
                object.platformType = options.enums === String ? $root.datatype.PlatformType[message.platformType] : message.platformType;
            if (message.tradeSymbol != null && message.hasOwnProperty("tradeSymbol"))
                object.tradeSymbol = options.enums === String ? $root.datatype.TradeSymbol[message.tradeSymbol] : message.tradeSymbol;
            if (message.info != null && message.hasOwnProperty("info"))
                object.info = message.info;
            return object;
        };

        /**
         * Converts this TradeLogDo to JSON.
         * @function toJSON
         * @memberof datatype.TradeLogDo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeLogDo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeLogDo;
    })();

    datatype.QueryTradeLogResp = (function() {

        /**
         * Properties of a QueryTradeLogResp.
         * @memberof datatype
         * @interface IQueryTradeLogResp
         * @property {Array.<st.ITradeLog>|null} [logs] QueryTradeLogResp logs
         * @property {number|null} [nextCursor] QueryTradeLogResp nextCursor
         * @property {boolean|null} [more] QueryTradeLogResp more
         * @property {number|null} [maxCanFound] QueryTradeLogResp maxCanFound
         */

        /**
         * Constructs a new QueryTradeLogResp.
         * @memberof datatype
         * @classdesc Represents a QueryTradeLogResp.
         * @implements IQueryTradeLogResp
         * @constructor
         * @param {datatype.IQueryTradeLogResp=} [properties] Properties to set
         */
        function QueryTradeLogResp(properties) {
            this.logs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryTradeLogResp logs.
         * @member {Array.<st.ITradeLog>} logs
         * @memberof datatype.QueryTradeLogResp
         * @instance
         */
        QueryTradeLogResp.prototype.logs = $util.emptyArray;

        /**
         * QueryTradeLogResp nextCursor.
         * @member {number} nextCursor
         * @memberof datatype.QueryTradeLogResp
         * @instance
         */
        QueryTradeLogResp.prototype.nextCursor = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * QueryTradeLogResp more.
         * @member {boolean} more
         * @memberof datatype.QueryTradeLogResp
         * @instance
         */
        QueryTradeLogResp.prototype.more = false;

        /**
         * QueryTradeLogResp maxCanFound.
         * @member {number} maxCanFound
         * @memberof datatype.QueryTradeLogResp
         * @instance
         */
        QueryTradeLogResp.prototype.maxCanFound = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new QueryTradeLogResp instance using the specified properties.
         * @function create
         * @memberof datatype.QueryTradeLogResp
         * @static
         * @param {datatype.IQueryTradeLogResp=} [properties] Properties to set
         * @returns {datatype.QueryTradeLogResp} QueryTradeLogResp instance
         */
        QueryTradeLogResp.create = function create(properties) {
            return new QueryTradeLogResp(properties);
        };

        /**
         * Encodes the specified QueryTradeLogResp message. Does not implicitly {@link datatype.QueryTradeLogResp.verify|verify} messages.
         * @function encode
         * @memberof datatype.QueryTradeLogResp
         * @static
         * @param {datatype.IQueryTradeLogResp} message QueryTradeLogResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryTradeLogResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logs != null && message.logs.length)
                for (let i = 0; i < message.logs.length; ++i)
                    $root.st.TradeLog.encode(message.logs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nextCursor != null && Object.hasOwnProperty.call(message, "nextCursor"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.nextCursor);
            if (message.more != null && Object.hasOwnProperty.call(message, "more"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.more);
            if (message.maxCanFound != null && Object.hasOwnProperty.call(message, "maxCanFound"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.maxCanFound);
            return writer;
        };

        /**
         * Encodes the specified QueryTradeLogResp message, length delimited. Does not implicitly {@link datatype.QueryTradeLogResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof datatype.QueryTradeLogResp
         * @static
         * @param {datatype.IQueryTradeLogResp} message QueryTradeLogResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryTradeLogResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryTradeLogResp message from the specified reader or buffer.
         * @function decode
         * @memberof datatype.QueryTradeLogResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {datatype.QueryTradeLogResp} QueryTradeLogResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryTradeLogResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.datatype.QueryTradeLogResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.logs && message.logs.length))
                        message.logs = [];
                    message.logs.push($root.st.TradeLog.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.nextCursor = reader.uint64();
                    break;
                case 3:
                    message.more = reader.bool();
                    break;
                case 4:
                    message.maxCanFound = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryTradeLogResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof datatype.QueryTradeLogResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {datatype.QueryTradeLogResp} QueryTradeLogResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryTradeLogResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryTradeLogResp message.
         * @function verify
         * @memberof datatype.QueryTradeLogResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryTradeLogResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logs != null && message.hasOwnProperty("logs")) {
                if (!Array.isArray(message.logs))
                    return "logs: array expected";
                for (let i = 0; i < message.logs.length; ++i) {
                    let error = $root.st.TradeLog.verify(message.logs[i]);
                    if (error)
                        return "logs." + error;
                }
            }
            if (message.nextCursor != null && message.hasOwnProperty("nextCursor"))
                if (!$util.isInteger(message.nextCursor) && !(message.nextCursor && $util.isInteger(message.nextCursor.low) && $util.isInteger(message.nextCursor.high)))
                    return "nextCursor: integer|Long expected";
            if (message.more != null && message.hasOwnProperty("more"))
                if (typeof message.more !== "boolean")
                    return "more: boolean expected";
            if (message.maxCanFound != null && message.hasOwnProperty("maxCanFound"))
                if (!$util.isInteger(message.maxCanFound) && !(message.maxCanFound && $util.isInteger(message.maxCanFound.low) && $util.isInteger(message.maxCanFound.high)))
                    return "maxCanFound: integer|Long expected";
            return null;
        };

        /**
         * Creates a QueryTradeLogResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof datatype.QueryTradeLogResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {datatype.QueryTradeLogResp} QueryTradeLogResp
         */
        QueryTradeLogResp.fromObject = function fromObject(object) {
            if (object instanceof $root.datatype.QueryTradeLogResp)
                return object;
            let message = new $root.datatype.QueryTradeLogResp();
            if (object.logs) {
                if (!Array.isArray(object.logs))
                    throw TypeError(".datatype.QueryTradeLogResp.logs: array expected");
                message.logs = [];
                for (let i = 0; i < object.logs.length; ++i) {
                    if (typeof object.logs[i] !== "object")
                        throw TypeError(".datatype.QueryTradeLogResp.logs: object expected");
                    message.logs[i] = $root.st.TradeLog.fromObject(object.logs[i]);
                }
            }
            if (object.nextCursor != null)
                if ($util.Long)
                    (message.nextCursor = $util.Long.fromValue(object.nextCursor)).unsigned = true;
                else if (typeof object.nextCursor === "string")
                    message.nextCursor = parseInt(object.nextCursor, 10);
                else if (typeof object.nextCursor === "number")
                    message.nextCursor = object.nextCursor;
                else if (typeof object.nextCursor === "object")
                    message.nextCursor = new $util.LongBits(object.nextCursor.low >>> 0, object.nextCursor.high >>> 0).toNumber(true);
            if (object.more != null)
                message.more = Boolean(object.more);
            if (object.maxCanFound != null)
                if ($util.Long)
                    (message.maxCanFound = $util.Long.fromValue(object.maxCanFound)).unsigned = true;
                else if (typeof object.maxCanFound === "string")
                    message.maxCanFound = parseInt(object.maxCanFound, 10);
                else if (typeof object.maxCanFound === "number")
                    message.maxCanFound = object.maxCanFound;
                else if (typeof object.maxCanFound === "object")
                    message.maxCanFound = new $util.LongBits(object.maxCanFound.low >>> 0, object.maxCanFound.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a QueryTradeLogResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof datatype.QueryTradeLogResp
         * @static
         * @param {datatype.QueryTradeLogResp} message QueryTradeLogResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryTradeLogResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.logs = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.nextCursor = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nextCursor = options.longs === String ? "0" : 0;
                object.more = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxCanFound = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxCanFound = options.longs === String ? "0" : 0;
            }
            if (message.logs && message.logs.length) {
                object.logs = [];
                for (let j = 0; j < message.logs.length; ++j)
                    object.logs[j] = $root.st.TradeLog.toObject(message.logs[j], options);
            }
            if (message.nextCursor != null && message.hasOwnProperty("nextCursor"))
                if (typeof message.nextCursor === "number")
                    object.nextCursor = options.longs === String ? String(message.nextCursor) : message.nextCursor;
                else
                    object.nextCursor = options.longs === String ? $util.Long.prototype.toString.call(message.nextCursor) : options.longs === Number ? new $util.LongBits(message.nextCursor.low >>> 0, message.nextCursor.high >>> 0).toNumber(true) : message.nextCursor;
            if (message.more != null && message.hasOwnProperty("more"))
                object.more = message.more;
            if (message.maxCanFound != null && message.hasOwnProperty("maxCanFound"))
                if (typeof message.maxCanFound === "number")
                    object.maxCanFound = options.longs === String ? String(message.maxCanFound) : message.maxCanFound;
                else
                    object.maxCanFound = options.longs === String ? $util.Long.prototype.toString.call(message.maxCanFound) : options.longs === Number ? new $util.LongBits(message.maxCanFound.low >>> 0, message.maxCanFound.high >>> 0).toNumber(true) : message.maxCanFound;
            return object;
        };

        /**
         * Converts this QueryTradeLogResp to JSON.
         * @function toJSON
         * @memberof datatype.QueryTradeLogResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryTradeLogResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryTradeLogResp;
    })();

    return datatype;
})();

export const symbology = $root.symbology = (() => {

    /**
     * Namespace symbology.
     * @exports symbology
     * @namespace
     */
    const symbology = {};

    /**
     * SymbolType enum.
     * @name symbology.SymbolType
     * @enum {number}
     * @property {number} STOCK=0 STOCK value
     * @property {number} INDEX=1 INDEX value
     * @property {number} FUTURE_SW=2 FUTURE_SW value
     * @property {number} FUTURE_SW_REV=3 FUTURE_SW_REV value
     */
    symbology.SymbolType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "STOCK"] = 0;
        values[valuesById[1] = "INDEX"] = 1;
        values[valuesById[2] = "FUTURE_SW"] = 2;
        values[valuesById[3] = "FUTURE_SW_REV"] = 3;
        return values;
    })();

    /**
     * Currency enum.
     * @name symbology.Currency
     * @enum {number}
     * @property {number} USD=0 USD value
     * @property {number} USDT=1 USDT value
     * @property {number} BTC=2 BTC value
     * @property {number} ETH=3 ETH value
     * @property {number} XRP=4 XRP value
     * @property {number} EOS=5 EOS value
     */
    symbology.Currency = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "USD"] = 0;
        values[valuesById[1] = "USDT"] = 1;
        values[valuesById[2] = "BTC"] = 2;
        values[valuesById[3] = "ETH"] = 3;
        values[valuesById[4] = "XRP"] = 4;
        values[valuesById[5] = "EOS"] = 5;
        return values;
    })();

    symbology.SymbolInfoPo = (function() {

        /**
         * Properties of a SymbolInfoPo.
         * @memberof symbology
         * @interface ISymbolInfoPo
         * @property {string|null} [symbolId] SymbolInfoPo symbolId
         * @property {string|null} [innerSymbol] SymbolInfoPo innerSymbol
         * @property {string|null} [exchangeSymbol] SymbolInfoPo exchangeSymbol
         * @property {symbology.Currency|null} [baseCurreny] SymbolInfoPo baseCurreny
         * @property {symbology.Currency|null} [commodityCurrency] SymbolInfoPo commodityCurrency
         * @property {symbology.SymbolType|null} [type] SymbolInfoPo type
         * @property {string|null} [session] SymbolInfoPo session
         * @property {string|null} [holidays] SymbolInfoPo holidays
         * @property {st.Platform|null} [platform] SymbolInfoPo platform
         * @property {string|null} [priceSlot] SymbolInfoPo priceSlot
         * @property {string|null} [sizeSlot] SymbolInfoPo sizeSlot
         */

        /**
         * Constructs a new SymbolInfoPo.
         * @memberof symbology
         * @classdesc Represents a SymbolInfoPo.
         * @implements ISymbolInfoPo
         * @constructor
         * @param {symbology.ISymbolInfoPo=} [properties] Properties to set
         */
        function SymbolInfoPo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SymbolInfoPo symbolId.
         * @member {string} symbolId
         * @memberof symbology.SymbolInfoPo
         * @instance
         */
        SymbolInfoPo.prototype.symbolId = "";

        /**
         * SymbolInfoPo innerSymbol.
         * @member {string} innerSymbol
         * @memberof symbology.SymbolInfoPo
         * @instance
         */
        SymbolInfoPo.prototype.innerSymbol = "";

        /**
         * SymbolInfoPo exchangeSymbol.
         * @member {string} exchangeSymbol
         * @memberof symbology.SymbolInfoPo
         * @instance
         */
        SymbolInfoPo.prototype.exchangeSymbol = "";

        /**
         * SymbolInfoPo baseCurreny.
         * @member {symbology.Currency} baseCurreny
         * @memberof symbology.SymbolInfoPo
         * @instance
         */
        SymbolInfoPo.prototype.baseCurreny = 0;

        /**
         * SymbolInfoPo commodityCurrency.
         * @member {symbology.Currency} commodityCurrency
         * @memberof symbology.SymbolInfoPo
         * @instance
         */
        SymbolInfoPo.prototype.commodityCurrency = 0;

        /**
         * SymbolInfoPo type.
         * @member {symbology.SymbolType} type
         * @memberof symbology.SymbolInfoPo
         * @instance
         */
        SymbolInfoPo.prototype.type = 0;

        /**
         * SymbolInfoPo session.
         * @member {string} session
         * @memberof symbology.SymbolInfoPo
         * @instance
         */
        SymbolInfoPo.prototype.session = "";

        /**
         * SymbolInfoPo holidays.
         * @member {string} holidays
         * @memberof symbology.SymbolInfoPo
         * @instance
         */
        SymbolInfoPo.prototype.holidays = "";

        /**
         * SymbolInfoPo platform.
         * @member {st.Platform} platform
         * @memberof symbology.SymbolInfoPo
         * @instance
         */
        SymbolInfoPo.prototype.platform = 0;

        /**
         * SymbolInfoPo priceSlot.
         * @member {string} priceSlot
         * @memberof symbology.SymbolInfoPo
         * @instance
         */
        SymbolInfoPo.prototype.priceSlot = "";

        /**
         * SymbolInfoPo sizeSlot.
         * @member {string} sizeSlot
         * @memberof symbology.SymbolInfoPo
         * @instance
         */
        SymbolInfoPo.prototype.sizeSlot = "";

        /**
         * Creates a new SymbolInfoPo instance using the specified properties.
         * @function create
         * @memberof symbology.SymbolInfoPo
         * @static
         * @param {symbology.ISymbolInfoPo=} [properties] Properties to set
         * @returns {symbology.SymbolInfoPo} SymbolInfoPo instance
         */
        SymbolInfoPo.create = function create(properties) {
            return new SymbolInfoPo(properties);
        };

        /**
         * Encodes the specified SymbolInfoPo message. Does not implicitly {@link symbology.SymbolInfoPo.verify|verify} messages.
         * @function encode
         * @memberof symbology.SymbolInfoPo
         * @static
         * @param {symbology.ISymbolInfoPo} message SymbolInfoPo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolInfoPo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.symbolId != null && Object.hasOwnProperty.call(message, "symbolId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.symbolId);
            if (message.innerSymbol != null && Object.hasOwnProperty.call(message, "innerSymbol"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.innerSymbol);
            if (message.exchangeSymbol != null && Object.hasOwnProperty.call(message, "exchangeSymbol"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.exchangeSymbol);
            if (message.baseCurreny != null && Object.hasOwnProperty.call(message, "baseCurreny"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.baseCurreny);
            if (message.commodityCurrency != null && Object.hasOwnProperty.call(message, "commodityCurrency"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.commodityCurrency);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
            if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.session);
            if (message.holidays != null && Object.hasOwnProperty.call(message, "holidays"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.holidays);
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.platform);
            if (message.priceSlot != null && Object.hasOwnProperty.call(message, "priceSlot"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.priceSlot);
            if (message.sizeSlot != null && Object.hasOwnProperty.call(message, "sizeSlot"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.sizeSlot);
            return writer;
        };

        /**
         * Encodes the specified SymbolInfoPo message, length delimited. Does not implicitly {@link symbology.SymbolInfoPo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof symbology.SymbolInfoPo
         * @static
         * @param {symbology.ISymbolInfoPo} message SymbolInfoPo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolInfoPo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SymbolInfoPo message from the specified reader or buffer.
         * @function decode
         * @memberof symbology.SymbolInfoPo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {symbology.SymbolInfoPo} SymbolInfoPo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolInfoPo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.symbology.SymbolInfoPo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.symbolId = reader.string();
                    break;
                case 2:
                    message.innerSymbol = reader.string();
                    break;
                case 3:
                    message.exchangeSymbol = reader.string();
                    break;
                case 4:
                    message.baseCurreny = reader.int32();
                    break;
                case 5:
                    message.commodityCurrency = reader.int32();
                    break;
                case 6:
                    message.type = reader.int32();
                    break;
                case 7:
                    message.session = reader.string();
                    break;
                case 8:
                    message.holidays = reader.string();
                    break;
                case 9:
                    message.platform = reader.int32();
                    break;
                case 10:
                    message.priceSlot = reader.string();
                    break;
                case 11:
                    message.sizeSlot = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SymbolInfoPo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof symbology.SymbolInfoPo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {symbology.SymbolInfoPo} SymbolInfoPo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolInfoPo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SymbolInfoPo message.
         * @function verify
         * @memberof symbology.SymbolInfoPo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SymbolInfoPo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.symbolId != null && message.hasOwnProperty("symbolId"))
                if (!$util.isString(message.symbolId))
                    return "symbolId: string expected";
            if (message.innerSymbol != null && message.hasOwnProperty("innerSymbol"))
                if (!$util.isString(message.innerSymbol))
                    return "innerSymbol: string expected";
            if (message.exchangeSymbol != null && message.hasOwnProperty("exchangeSymbol"))
                if (!$util.isString(message.exchangeSymbol))
                    return "exchangeSymbol: string expected";
            if (message.baseCurreny != null && message.hasOwnProperty("baseCurreny"))
                switch (message.baseCurreny) {
                default:
                    return "baseCurreny: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.commodityCurrency != null && message.hasOwnProperty("commodityCurrency"))
                switch (message.commodityCurrency) {
                default:
                    return "commodityCurrency: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.session != null && message.hasOwnProperty("session"))
                if (!$util.isString(message.session))
                    return "session: string expected";
            if (message.holidays != null && message.hasOwnProperty("holidays"))
                if (!$util.isString(message.holidays))
                    return "holidays: string expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                switch (message.platform) {
                default:
                    return "platform: enum value expected";
                case 0:
                case 2:
                case 3:
                    break;
                }
            if (message.priceSlot != null && message.hasOwnProperty("priceSlot"))
                if (!$util.isString(message.priceSlot))
                    return "priceSlot: string expected";
            if (message.sizeSlot != null && message.hasOwnProperty("sizeSlot"))
                if (!$util.isString(message.sizeSlot))
                    return "sizeSlot: string expected";
            return null;
        };

        /**
         * Creates a SymbolInfoPo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof symbology.SymbolInfoPo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {symbology.SymbolInfoPo} SymbolInfoPo
         */
        SymbolInfoPo.fromObject = function fromObject(object) {
            if (object instanceof $root.symbology.SymbolInfoPo)
                return object;
            let message = new $root.symbology.SymbolInfoPo();
            if (object.symbolId != null)
                message.symbolId = String(object.symbolId);
            if (object.innerSymbol != null)
                message.innerSymbol = String(object.innerSymbol);
            if (object.exchangeSymbol != null)
                message.exchangeSymbol = String(object.exchangeSymbol);
            switch (object.baseCurreny) {
            case "USD":
            case 0:
                message.baseCurreny = 0;
                break;
            case "USDT":
            case 1:
                message.baseCurreny = 1;
                break;
            case "BTC":
            case 2:
                message.baseCurreny = 2;
                break;
            case "ETH":
            case 3:
                message.baseCurreny = 3;
                break;
            case "XRP":
            case 4:
                message.baseCurreny = 4;
                break;
            case "EOS":
            case 5:
                message.baseCurreny = 5;
                break;
            }
            switch (object.commodityCurrency) {
            case "USD":
            case 0:
                message.commodityCurrency = 0;
                break;
            case "USDT":
            case 1:
                message.commodityCurrency = 1;
                break;
            case "BTC":
            case 2:
                message.commodityCurrency = 2;
                break;
            case "ETH":
            case 3:
                message.commodityCurrency = 3;
                break;
            case "XRP":
            case 4:
                message.commodityCurrency = 4;
                break;
            case "EOS":
            case 5:
                message.commodityCurrency = 5;
                break;
            }
            switch (object.type) {
            case "STOCK":
            case 0:
                message.type = 0;
                break;
            case "INDEX":
            case 1:
                message.type = 1;
                break;
            case "FUTURE_SW":
            case 2:
                message.type = 2;
                break;
            case "FUTURE_SW_REV":
            case 3:
                message.type = 3;
                break;
            }
            if (object.session != null)
                message.session = String(object.session);
            if (object.holidays != null)
                message.holidays = String(object.holidays);
            switch (object.platform) {
            case "FAKE":
            case 0:
                message.platform = 0;
                break;
            case "HUOBI":
            case 2:
                message.platform = 2;
                break;
            case "BYBIT":
            case 3:
                message.platform = 3;
                break;
            }
            if (object.priceSlot != null)
                message.priceSlot = String(object.priceSlot);
            if (object.sizeSlot != null)
                message.sizeSlot = String(object.sizeSlot);
            return message;
        };

        /**
         * Creates a plain object from a SymbolInfoPo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof symbology.SymbolInfoPo
         * @static
         * @param {symbology.SymbolInfoPo} message SymbolInfoPo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SymbolInfoPo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.symbolId = "";
                object.innerSymbol = "";
                object.exchangeSymbol = "";
                object.baseCurreny = options.enums === String ? "USD" : 0;
                object.commodityCurrency = options.enums === String ? "USD" : 0;
                object.type = options.enums === String ? "STOCK" : 0;
                object.session = "";
                object.holidays = "";
                object.platform = options.enums === String ? "FAKE" : 0;
                object.priceSlot = "";
                object.sizeSlot = "";
            }
            if (message.symbolId != null && message.hasOwnProperty("symbolId"))
                object.symbolId = message.symbolId;
            if (message.innerSymbol != null && message.hasOwnProperty("innerSymbol"))
                object.innerSymbol = message.innerSymbol;
            if (message.exchangeSymbol != null && message.hasOwnProperty("exchangeSymbol"))
                object.exchangeSymbol = message.exchangeSymbol;
            if (message.baseCurreny != null && message.hasOwnProperty("baseCurreny"))
                object.baseCurreny = options.enums === String ? $root.symbology.Currency[message.baseCurreny] : message.baseCurreny;
            if (message.commodityCurrency != null && message.hasOwnProperty("commodityCurrency"))
                object.commodityCurrency = options.enums === String ? $root.symbology.Currency[message.commodityCurrency] : message.commodityCurrency;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.symbology.SymbolType[message.type] : message.type;
            if (message.session != null && message.hasOwnProperty("session"))
                object.session = message.session;
            if (message.holidays != null && message.hasOwnProperty("holidays"))
                object.holidays = message.holidays;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = options.enums === String ? $root.st.Platform[message.platform] : message.platform;
            if (message.priceSlot != null && message.hasOwnProperty("priceSlot"))
                object.priceSlot = message.priceSlot;
            if (message.sizeSlot != null && message.hasOwnProperty("sizeSlot"))
                object.sizeSlot = message.sizeSlot;
            return object;
        };

        /**
         * Converts this SymbolInfoPo to JSON.
         * @function toJSON
         * @memberof symbology.SymbolInfoPo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SymbolInfoPo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SymbolInfoPo;
    })();

    return symbology;
})();

export const trade = $root.trade = (() => {

    /**
     * Namespace trade.
     * @exports trade
     * @namespace
     */
    const trade = {};

    trade.Signal = (function() {

        /**
         * Properties of a Signal.
         * @memberof trade
         * @interface ISignal
         * @property {string|null} [signalId] Signal signalId
         * @property {number|null} [ts] Signal ts
         */

        /**
         * Constructs a new Signal.
         * @memberof trade
         * @classdesc Represents a Signal.
         * @implements ISignal
         * @constructor
         * @param {trade.ISignal=} [properties] Properties to set
         */
        function Signal(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Signal signalId.
         * @member {string} signalId
         * @memberof trade.Signal
         * @instance
         */
        Signal.prototype.signalId = "";

        /**
         * Signal ts.
         * @member {number} ts
         * @memberof trade.Signal
         * @instance
         */
        Signal.prototype.ts = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Signal instance using the specified properties.
         * @function create
         * @memberof trade.Signal
         * @static
         * @param {trade.ISignal=} [properties] Properties to set
         * @returns {trade.Signal} Signal instance
         */
        Signal.create = function create(properties) {
            return new Signal(properties);
        };

        /**
         * Encodes the specified Signal message. Does not implicitly {@link trade.Signal.verify|verify} messages.
         * @function encode
         * @memberof trade.Signal
         * @static
         * @param {trade.ISignal} message Signal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Signal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signalId != null && Object.hasOwnProperty.call(message, "signalId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.signalId);
            if (message.ts != null && Object.hasOwnProperty.call(message, "ts"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.ts);
            return writer;
        };

        /**
         * Encodes the specified Signal message, length delimited. Does not implicitly {@link trade.Signal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof trade.Signal
         * @static
         * @param {trade.ISignal} message Signal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Signal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Signal message from the specified reader or buffer.
         * @function decode
         * @memberof trade.Signal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {trade.Signal} Signal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Signal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.trade.Signal();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signalId = reader.string();
                    break;
                case 2:
                    message.ts = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Signal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof trade.Signal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {trade.Signal} Signal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Signal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Signal message.
         * @function verify
         * @memberof trade.Signal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Signal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signalId != null && message.hasOwnProperty("signalId"))
                if (!$util.isString(message.signalId))
                    return "signalId: string expected";
            if (message.ts != null && message.hasOwnProperty("ts"))
                if (!$util.isInteger(message.ts) && !(message.ts && $util.isInteger(message.ts.low) && $util.isInteger(message.ts.high)))
                    return "ts: integer|Long expected";
            return null;
        };

        /**
         * Creates a Signal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof trade.Signal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {trade.Signal} Signal
         */
        Signal.fromObject = function fromObject(object) {
            if (object instanceof $root.trade.Signal)
                return object;
            let message = new $root.trade.Signal();
            if (object.signalId != null)
                message.signalId = String(object.signalId);
            if (object.ts != null)
                if ($util.Long)
                    (message.ts = $util.Long.fromValue(object.ts)).unsigned = true;
                else if (typeof object.ts === "string")
                    message.ts = parseInt(object.ts, 10);
                else if (typeof object.ts === "number")
                    message.ts = object.ts;
                else if (typeof object.ts === "object")
                    message.ts = new $util.LongBits(object.ts.low >>> 0, object.ts.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a Signal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof trade.Signal
         * @static
         * @param {trade.Signal} message Signal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Signal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.signalId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ts = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ts = options.longs === String ? "0" : 0;
            }
            if (message.signalId != null && message.hasOwnProperty("signalId"))
                object.signalId = message.signalId;
            if (message.ts != null && message.hasOwnProperty("ts"))
                if (typeof message.ts === "number")
                    object.ts = options.longs === String ? String(message.ts) : message.ts;
                else
                    object.ts = options.longs === String ? $util.Long.prototype.toString.call(message.ts) : options.longs === Number ? new $util.LongBits(message.ts.low >>> 0, message.ts.high >>> 0).toNumber(true) : message.ts;
            return object;
        };

        /**
         * Converts this Signal to JSON.
         * @function toJSON
         * @memberof trade.Signal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Signal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Signal;
    })();

    /**
     * PlatformType enum.
     * @name trade.PlatformType
     * @enum {number}
     * @property {number} BYBIT=1 BYBIT value
     */
    trade.PlatformType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "BYBIT"] = 1;
        return values;
    })();

    /**
     * TradeSymbol enum.
     * @name trade.TradeSymbol
     * @enum {number}
     * @property {number} BTCUSDT_FU=1 BTCUSDT_FU value
     */
    trade.TradeSymbol = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "BTCUSDT_FU"] = 1;
        return values;
    })();

    /**
     * ActionType enum.
     * @name trade.ActionType
     * @enum {number}
     * @property {number} ADD=1 ADD value
     */
    trade.ActionType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "ADD"] = 1;
        return values;
    })();

    trade.TradeLog = (function() {

        /**
         * Properties of a TradeLog.
         * @memberof trade
         * @interface ITradeLog
         * @property {number|null} [tsUsec] TradeLog tsUsec
         * @property {trade.ActionType|null} [actionType] TradeLog actionType
         * @property {trade.PlatformType|null} [platform] TradeLog platform
         * @property {trade.TradeSymbol|null} [tradeSymbol] TradeLog tradeSymbol
         * @property {string|null} [info] TradeLog info
         */

        /**
         * Constructs a new TradeLog.
         * @memberof trade
         * @classdesc Represents a TradeLog.
         * @implements ITradeLog
         * @constructor
         * @param {trade.ITradeLog=} [properties] Properties to set
         */
        function TradeLog(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeLog tsUsec.
         * @member {number} tsUsec
         * @memberof trade.TradeLog
         * @instance
         */
        TradeLog.prototype.tsUsec = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TradeLog actionType.
         * @member {trade.ActionType} actionType
         * @memberof trade.TradeLog
         * @instance
         */
        TradeLog.prototype.actionType = 1;

        /**
         * TradeLog platform.
         * @member {trade.PlatformType} platform
         * @memberof trade.TradeLog
         * @instance
         */
        TradeLog.prototype.platform = 1;

        /**
         * TradeLog tradeSymbol.
         * @member {trade.TradeSymbol} tradeSymbol
         * @memberof trade.TradeLog
         * @instance
         */
        TradeLog.prototype.tradeSymbol = 1;

        /**
         * TradeLog info.
         * @member {string} info
         * @memberof trade.TradeLog
         * @instance
         */
        TradeLog.prototype.info = "";

        /**
         * Creates a new TradeLog instance using the specified properties.
         * @function create
         * @memberof trade.TradeLog
         * @static
         * @param {trade.ITradeLog=} [properties] Properties to set
         * @returns {trade.TradeLog} TradeLog instance
         */
        TradeLog.create = function create(properties) {
            return new TradeLog(properties);
        };

        /**
         * Encodes the specified TradeLog message. Does not implicitly {@link trade.TradeLog.verify|verify} messages.
         * @function encode
         * @memberof trade.TradeLog
         * @static
         * @param {trade.ITradeLog} message TradeLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tsUsec != null && Object.hasOwnProperty.call(message, "tsUsec"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tsUsec);
            if (message.actionType != null && Object.hasOwnProperty.call(message, "actionType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.actionType);
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.platform);
            if (message.tradeSymbol != null && Object.hasOwnProperty.call(message, "tradeSymbol"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.tradeSymbol);
            if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.info);
            return writer;
        };

        /**
         * Encodes the specified TradeLog message, length delimited. Does not implicitly {@link trade.TradeLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof trade.TradeLog
         * @static
         * @param {trade.ITradeLog} message TradeLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeLog message from the specified reader or buffer.
         * @function decode
         * @memberof trade.TradeLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {trade.TradeLog} TradeLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.trade.TradeLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tsUsec = reader.uint64();
                    break;
                case 2:
                    message.actionType = reader.int32();
                    break;
                case 3:
                    message.platform = reader.int32();
                    break;
                case 4:
                    message.tradeSymbol = reader.int32();
                    break;
                case 5:
                    message.info = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TradeLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof trade.TradeLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {trade.TradeLog} TradeLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeLog message.
         * @function verify
         * @memberof trade.TradeLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tsUsec != null && message.hasOwnProperty("tsUsec"))
                if (!$util.isInteger(message.tsUsec) && !(message.tsUsec && $util.isInteger(message.tsUsec.low) && $util.isInteger(message.tsUsec.high)))
                    return "tsUsec: integer|Long expected";
            if (message.actionType != null && message.hasOwnProperty("actionType"))
                switch (message.actionType) {
                default:
                    return "actionType: enum value expected";
                case 1:
                    break;
                }
            if (message.platform != null && message.hasOwnProperty("platform"))
                switch (message.platform) {
                default:
                    return "platform: enum value expected";
                case 1:
                    break;
                }
            if (message.tradeSymbol != null && message.hasOwnProperty("tradeSymbol"))
                switch (message.tradeSymbol) {
                default:
                    return "tradeSymbol: enum value expected";
                case 1:
                    break;
                }
            if (message.info != null && message.hasOwnProperty("info"))
                if (!$util.isString(message.info))
                    return "info: string expected";
            return null;
        };

        /**
         * Creates a TradeLog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof trade.TradeLog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {trade.TradeLog} TradeLog
         */
        TradeLog.fromObject = function fromObject(object) {
            if (object instanceof $root.trade.TradeLog)
                return object;
            let message = new $root.trade.TradeLog();
            if (object.tsUsec != null)
                if ($util.Long)
                    (message.tsUsec = $util.Long.fromValue(object.tsUsec)).unsigned = true;
                else if (typeof object.tsUsec === "string")
                    message.tsUsec = parseInt(object.tsUsec, 10);
                else if (typeof object.tsUsec === "number")
                    message.tsUsec = object.tsUsec;
                else if (typeof object.tsUsec === "object")
                    message.tsUsec = new $util.LongBits(object.tsUsec.low >>> 0, object.tsUsec.high >>> 0).toNumber(true);
            switch (object.actionType) {
            case "ADD":
            case 1:
                message.actionType = 1;
                break;
            }
            switch (object.platform) {
            case "BYBIT":
            case 1:
                message.platform = 1;
                break;
            }
            switch (object.tradeSymbol) {
            case "BTCUSDT_FU":
            case 1:
                message.tradeSymbol = 1;
                break;
            }
            if (object.info != null)
                message.info = String(object.info);
            return message;
        };

        /**
         * Creates a plain object from a TradeLog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof trade.TradeLog
         * @static
         * @param {trade.TradeLog} message TradeLog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeLog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.tsUsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.tsUsec = options.longs === String ? "0" : 0;
                object.actionType = options.enums === String ? "ADD" : 1;
                object.platform = options.enums === String ? "BYBIT" : 1;
                object.tradeSymbol = options.enums === String ? "BTCUSDT_FU" : 1;
                object.info = "";
            }
            if (message.tsUsec != null && message.hasOwnProperty("tsUsec"))
                if (typeof message.tsUsec === "number")
                    object.tsUsec = options.longs === String ? String(message.tsUsec) : message.tsUsec;
                else
                    object.tsUsec = options.longs === String ? $util.Long.prototype.toString.call(message.tsUsec) : options.longs === Number ? new $util.LongBits(message.tsUsec.low >>> 0, message.tsUsec.high >>> 0).toNumber(true) : message.tsUsec;
            if (message.actionType != null && message.hasOwnProperty("actionType"))
                object.actionType = options.enums === String ? $root.trade.ActionType[message.actionType] : message.actionType;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = options.enums === String ? $root.trade.PlatformType[message.platform] : message.platform;
            if (message.tradeSymbol != null && message.hasOwnProperty("tradeSymbol"))
                object.tradeSymbol = options.enums === String ? $root.trade.TradeSymbol[message.tradeSymbol] : message.tradeSymbol;
            if (message.info != null && message.hasOwnProperty("info"))
                object.info = message.info;
            return object;
        };

        /**
         * Converts this TradeLog to JSON.
         * @function toJSON
         * @memberof trade.TradeLog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeLog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TradeLog;
    })();

    trade.QueryTradeLogReq = (function() {

        /**
         * Properties of a QueryTradeLogReq.
         * @memberof trade
         * @interface IQueryTradeLogReq
         * @property {string|null} [symbol] QueryTradeLogReq symbol
         * @property {string|null} [source] QueryTradeLogReq source
         */

        /**
         * Constructs a new QueryTradeLogReq.
         * @memberof trade
         * @classdesc Represents a QueryTradeLogReq.
         * @implements IQueryTradeLogReq
         * @constructor
         * @param {trade.IQueryTradeLogReq=} [properties] Properties to set
         */
        function QueryTradeLogReq(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryTradeLogReq symbol.
         * @member {string} symbol
         * @memberof trade.QueryTradeLogReq
         * @instance
         */
        QueryTradeLogReq.prototype.symbol = "";

        /**
         * QueryTradeLogReq source.
         * @member {string} source
         * @memberof trade.QueryTradeLogReq
         * @instance
         */
        QueryTradeLogReq.prototype.source = "";

        /**
         * Creates a new QueryTradeLogReq instance using the specified properties.
         * @function create
         * @memberof trade.QueryTradeLogReq
         * @static
         * @param {trade.IQueryTradeLogReq=} [properties] Properties to set
         * @returns {trade.QueryTradeLogReq} QueryTradeLogReq instance
         */
        QueryTradeLogReq.create = function create(properties) {
            return new QueryTradeLogReq(properties);
        };

        /**
         * Encodes the specified QueryTradeLogReq message. Does not implicitly {@link trade.QueryTradeLogReq.verify|verify} messages.
         * @function encode
         * @memberof trade.QueryTradeLogReq
         * @static
         * @param {trade.IQueryTradeLogReq} message QueryTradeLogReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryTradeLogReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.symbol);
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                writer.uint32(/* id 100, wireType 2 =*/802).string(message.source);
            return writer;
        };

        /**
         * Encodes the specified QueryTradeLogReq message, length delimited. Does not implicitly {@link trade.QueryTradeLogReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof trade.QueryTradeLogReq
         * @static
         * @param {trade.IQueryTradeLogReq} message QueryTradeLogReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryTradeLogReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryTradeLogReq message from the specified reader or buffer.
         * @function decode
         * @memberof trade.QueryTradeLogReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {trade.QueryTradeLogReq} QueryTradeLogReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryTradeLogReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.trade.QueryTradeLogReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.symbol = reader.string();
                    break;
                case 100:
                    message.source = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryTradeLogReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof trade.QueryTradeLogReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {trade.QueryTradeLogReq} QueryTradeLogReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryTradeLogReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryTradeLogReq message.
         * @function verify
         * @memberof trade.QueryTradeLogReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryTradeLogReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                if (!$util.isString(message.symbol))
                    return "symbol: string expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!$util.isString(message.source))
                    return "source: string expected";
            return null;
        };

        /**
         * Creates a QueryTradeLogReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof trade.QueryTradeLogReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {trade.QueryTradeLogReq} QueryTradeLogReq
         */
        QueryTradeLogReq.fromObject = function fromObject(object) {
            if (object instanceof $root.trade.QueryTradeLogReq)
                return object;
            let message = new $root.trade.QueryTradeLogReq();
            if (object.symbol != null)
                message.symbol = String(object.symbol);
            if (object.source != null)
                message.source = String(object.source);
            return message;
        };

        /**
         * Creates a plain object from a QueryTradeLogReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof trade.QueryTradeLogReq
         * @static
         * @param {trade.QueryTradeLogReq} message QueryTradeLogReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryTradeLogReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.symbol = "";
                object.source = "";
            }
            if (message.symbol != null && message.hasOwnProperty("symbol"))
                object.symbol = message.symbol;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = message.source;
            return object;
        };

        /**
         * Converts this QueryTradeLogReq to JSON.
         * @function toJSON
         * @memberof trade.QueryTradeLogReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryTradeLogReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryTradeLogReq;
    })();

    trade.QueryTradeLogResp = (function() {

        /**
         * Properties of a QueryTradeLogResp.
         * @memberof trade
         * @interface IQueryTradeLogResp
         * @property {Array.<trade.ITradeLog>|null} [logs] QueryTradeLogResp logs
         */

        /**
         * Constructs a new QueryTradeLogResp.
         * @memberof trade
         * @classdesc Represents a QueryTradeLogResp.
         * @implements IQueryTradeLogResp
         * @constructor
         * @param {trade.IQueryTradeLogResp=} [properties] Properties to set
         */
        function QueryTradeLogResp(properties) {
            this.logs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryTradeLogResp logs.
         * @member {Array.<trade.ITradeLog>} logs
         * @memberof trade.QueryTradeLogResp
         * @instance
         */
        QueryTradeLogResp.prototype.logs = $util.emptyArray;

        /**
         * Creates a new QueryTradeLogResp instance using the specified properties.
         * @function create
         * @memberof trade.QueryTradeLogResp
         * @static
         * @param {trade.IQueryTradeLogResp=} [properties] Properties to set
         * @returns {trade.QueryTradeLogResp} QueryTradeLogResp instance
         */
        QueryTradeLogResp.create = function create(properties) {
            return new QueryTradeLogResp(properties);
        };

        /**
         * Encodes the specified QueryTradeLogResp message. Does not implicitly {@link trade.QueryTradeLogResp.verify|verify} messages.
         * @function encode
         * @memberof trade.QueryTradeLogResp
         * @static
         * @param {trade.IQueryTradeLogResp} message QueryTradeLogResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryTradeLogResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logs != null && message.logs.length)
                for (let i = 0; i < message.logs.length; ++i)
                    $root.trade.TradeLog.encode(message.logs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryTradeLogResp message, length delimited. Does not implicitly {@link trade.QueryTradeLogResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof trade.QueryTradeLogResp
         * @static
         * @param {trade.IQueryTradeLogResp} message QueryTradeLogResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryTradeLogResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryTradeLogResp message from the specified reader or buffer.
         * @function decode
         * @memberof trade.QueryTradeLogResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {trade.QueryTradeLogResp} QueryTradeLogResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryTradeLogResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.trade.QueryTradeLogResp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.logs && message.logs.length))
                        message.logs = [];
                    message.logs.push($root.trade.TradeLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryTradeLogResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof trade.QueryTradeLogResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {trade.QueryTradeLogResp} QueryTradeLogResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryTradeLogResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryTradeLogResp message.
         * @function verify
         * @memberof trade.QueryTradeLogResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryTradeLogResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logs != null && message.hasOwnProperty("logs")) {
                if (!Array.isArray(message.logs))
                    return "logs: array expected";
                for (let i = 0; i < message.logs.length; ++i) {
                    let error = $root.trade.TradeLog.verify(message.logs[i]);
                    if (error)
                        return "logs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a QueryTradeLogResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof trade.QueryTradeLogResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {trade.QueryTradeLogResp} QueryTradeLogResp
         */
        QueryTradeLogResp.fromObject = function fromObject(object) {
            if (object instanceof $root.trade.QueryTradeLogResp)
                return object;
            let message = new $root.trade.QueryTradeLogResp();
            if (object.logs) {
                if (!Array.isArray(object.logs))
                    throw TypeError(".trade.QueryTradeLogResp.logs: array expected");
                message.logs = [];
                for (let i = 0; i < object.logs.length; ++i) {
                    if (typeof object.logs[i] !== "object")
                        throw TypeError(".trade.QueryTradeLogResp.logs: object expected");
                    message.logs[i] = $root.trade.TradeLog.fromObject(object.logs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryTradeLogResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof trade.QueryTradeLogResp
         * @static
         * @param {trade.QueryTradeLogResp} message QueryTradeLogResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryTradeLogResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.logs = [];
            if (message.logs && message.logs.length) {
                object.logs = [];
                for (let j = 0; j < message.logs.length; ++j)
                    object.logs[j] = $root.trade.TradeLog.toObject(message.logs[j], options);
            }
            return object;
        };

        /**
         * Converts this QueryTradeLogResp to JSON.
         * @function toJSON
         * @memberof trade.QueryTradeLogResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryTradeLogResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryTradeLogResp;
    })();

    return trade;
})();

export { $root as default };
